// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cg_packets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cg_5fpackets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cg_5fpackets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "protobuf_data.h"
#include "protobuf_data_player.h"
#include "protobuf_data_item.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cg_5fpackets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cg_5fpackets_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cg_5fpackets_2eproto;
namespace network {
class CGAcceRefineAcceptPacket;
struct CGAcceRefineAcceptPacketDefaultTypeInternal;
extern CGAcceRefineAcceptPacketDefaultTypeInternal _CGAcceRefineAcceptPacket_default_instance_;
class CGAcceRefineCheckinPacket;
struct CGAcceRefineCheckinPacketDefaultTypeInternal;
extern CGAcceRefineCheckinPacketDefaultTypeInternal _CGAcceRefineCheckinPacket_default_instance_;
class CGAcceRefineCheckoutPacket;
struct CGAcceRefineCheckoutPacketDefaultTypeInternal;
extern CGAcceRefineCheckoutPacketDefaultTypeInternal _CGAcceRefineCheckoutPacket_default_instance_;
class CGAddFlyTargetPacket;
struct CGAddFlyTargetPacketDefaultTypeInternal;
extern CGAddFlyTargetPacketDefaultTypeInternal _CGAddFlyTargetPacket_default_instance_;
class CGAttackPacket;
struct CGAttackPacketDefaultTypeInternal;
extern CGAttackPacketDefaultTypeInternal _CGAttackPacket_default_instance_;
class CGAuctionBuyItemPacket;
struct CGAuctionBuyItemPacketDefaultTypeInternal;
extern CGAuctionBuyItemPacketDefaultTypeInternal _CGAuctionBuyItemPacket_default_instance_;
class CGAuctionExtendedSearchItemsPacket;
struct CGAuctionExtendedSearchItemsPacketDefaultTypeInternal;
extern CGAuctionExtendedSearchItemsPacketDefaultTypeInternal _CGAuctionExtendedSearchItemsPacket_default_instance_;
class CGAuctionInsertItemPacket;
struct CGAuctionInsertItemPacketDefaultTypeInternal;
extern CGAuctionInsertItemPacketDefaultTypeInternal _CGAuctionInsertItemPacket_default_instance_;
class CGAuctionMarkShopPacket;
struct CGAuctionMarkShopPacketDefaultTypeInternal;
extern CGAuctionMarkShopPacketDefaultTypeInternal _CGAuctionMarkShopPacket_default_instance_;
class CGAuctionRequestAveragePricePacket;
struct CGAuctionRequestAveragePricePacketDefaultTypeInternal;
extern CGAuctionRequestAveragePricePacketDefaultTypeInternal _CGAuctionRequestAveragePricePacket_default_instance_;
class CGAuctionSearchItemsPacket;
struct CGAuctionSearchItemsPacketDefaultTypeInternal;
extern CGAuctionSearchItemsPacketDefaultTypeInternal _CGAuctionSearchItemsPacket_default_instance_;
class CGAuctionShopClosePacket;
struct CGAuctionShopClosePacketDefaultTypeInternal;
extern CGAuctionShopClosePacketDefaultTypeInternal _CGAuctionShopClosePacket_default_instance_;
class CGAuctionShopOpenPacket;
struct CGAuctionShopOpenPacketDefaultTypeInternal;
extern CGAuctionShopOpenPacketDefaultTypeInternal _CGAuctionShopOpenPacket_default_instance_;
class CGAuctionShopTakeGoldPacket;
struct CGAuctionShopTakeGoldPacketDefaultTypeInternal;
extern CGAuctionShopTakeGoldPacketDefaultTypeInternal _CGAuctionShopTakeGoldPacket_default_instance_;
class CGAuctionTakeGoldPacket;
struct CGAuctionTakeGoldPacketDefaultTypeInternal;
extern CGAuctionTakeGoldPacketDefaultTypeInternal _CGAuctionTakeGoldPacket_default_instance_;
class CGAuctionTakeItemPacket;
struct CGAuctionTakeItemPacketDefaultTypeInternal;
extern CGAuctionTakeItemPacketDefaultTypeInternal _CGAuctionTakeItemPacket_default_instance_;
class CGAuthLoginPacket;
struct CGAuthLoginPacketDefaultTypeInternal;
extern CGAuthLoginPacketDefaultTypeInternal _CGAuthLoginPacket_default_instance_;
class CGAuthOpenIDLoginPacket;
struct CGAuthOpenIDLoginPacketDefaultTypeInternal;
extern CGAuthOpenIDLoginPacketDefaultTypeInternal _CGAuthOpenIDLoginPacket_default_instance_;
class CGAuthPasspodAnswerPacket;
struct CGAuthPasspodAnswerPacketDefaultTypeInternal;
extern CGAuthPasspodAnswerPacketDefaultTypeInternal _CGAuthPasspodAnswerPacket_default_instance_;
class CGBotReportLogPacket;
struct CGBotReportLogPacketDefaultTypeInternal;
extern CGBotReportLogPacketDefaultTypeInternal _CGBotReportLogPacket_default_instance_;
class CGChatPacket;
struct CGChatPacketDefaultTypeInternal;
extern CGChatPacketDefaultTypeInternal _CGChatPacket_default_instance_;
class CGClientVersionPacket;
struct CGClientVersionPacketDefaultTypeInternal;
extern CGClientVersionPacketDefaultTypeInternal _CGClientVersionPacket_default_instance_;
class CGCombatZoneRequestActionPacket;
struct CGCombatZoneRequestActionPacketDefaultTypeInternal;
extern CGCombatZoneRequestActionPacketDefaultTypeInternal _CGCombatZoneRequestActionPacket_default_instance_;
class CGCostumeBonusTransferPacket;
struct CGCostumeBonusTransferPacketDefaultTypeInternal;
extern CGCostumeBonusTransferPacketDefaultTypeInternal _CGCostumeBonusTransferPacket_default_instance_;
class CGCostumeVisibilityPacket;
struct CGCostumeVisibilityPacketDefaultTypeInternal;
extern CGCostumeVisibilityPacketDefaultTypeInternal _CGCostumeVisibilityPacket_default_instance_;
class CGCrystalRefinePacket;
struct CGCrystalRefinePacketDefaultTypeInternal;
extern CGCrystalRefinePacketDefaultTypeInternal _CGCrystalRefinePacket_default_instance_;
class CGDragonSoulRefinePacket;
struct CGDragonSoulRefinePacketDefaultTypeInternal;
extern CGDragonSoulRefinePacketDefaultTypeInternal _CGDragonSoulRefinePacket_default_instance_;
class CGEmpirePacket;
struct CGEmpirePacketDefaultTypeInternal;
extern CGEmpirePacketDefaultTypeInternal _CGEmpirePacket_default_instance_;
class CGEquipmentPageAddPacket;
struct CGEquipmentPageAddPacketDefaultTypeInternal;
extern CGEquipmentPageAddPacketDefaultTypeInternal _CGEquipmentPageAddPacket_default_instance_;
class CGEquipmentPageDeletePacket;
struct CGEquipmentPageDeletePacketDefaultTypeInternal;
extern CGEquipmentPageDeletePacketDefaultTypeInternal _CGEquipmentPageDeletePacket_default_instance_;
class CGEquipmentPageSelectPacket;
struct CGEquipmentPageSelectPacketDefaultTypeInternal;
extern CGEquipmentPageSelectPacketDefaultTypeInternal _CGEquipmentPageSelectPacket_default_instance_;
class CGEventRequestAnswerPacket;
struct CGEventRequestAnswerPacketDefaultTypeInternal;
extern CGEventRequestAnswerPacketDefaultTypeInternal _CGEventRequestAnswerPacket_default_instance_;
class CGExchangeGoldAddPacket;
struct CGExchangeGoldAddPacketDefaultTypeInternal;
extern CGExchangeGoldAddPacketDefaultTypeInternal _CGExchangeGoldAddPacket_default_instance_;
class CGExchangeItemAddPacket;
struct CGExchangeItemAddPacketDefaultTypeInternal;
extern CGExchangeItemAddPacketDefaultTypeInternal _CGExchangeItemAddPacket_default_instance_;
class CGExchangeItemDelPacket;
struct CGExchangeItemDelPacketDefaultTypeInternal;
extern CGExchangeItemDelPacketDefaultTypeInternal _CGExchangeItemDelPacket_default_instance_;
class CGExchangeStartPacket;
struct CGExchangeStartPacketDefaultTypeInternal;
extern CGExchangeStartPacketDefaultTypeInternal _CGExchangeStartPacket_default_instance_;
class CGFishingPacket;
struct CGFishingPacketDefaultTypeInternal;
extern CGFishingPacketDefaultTypeInternal _CGFishingPacket_default_instance_;
class CGFlyTargetPacket;
struct CGFlyTargetPacketDefaultTypeInternal;
extern CGFlyTargetPacketDefaultTypeInternal _CGFlyTargetPacket_default_instance_;
class CGForcedRewarpPacket;
struct CGForcedRewarpPacketDefaultTypeInternal;
extern CGForcedRewarpPacketDefaultTypeInternal _CGForcedRewarpPacket_default_instance_;
class CGGiveItemPacket;
struct CGGiveItemPacketDefaultTypeInternal;
extern CGGiveItemPacketDefaultTypeInternal _CGGiveItemPacket_default_instance_;
class CGGuildAddMemberPacket;
struct CGGuildAddMemberPacketDefaultTypeInternal;
extern CGGuildAddMemberPacketDefaultTypeInternal _CGGuildAddMemberPacket_default_instance_;
class CGGuildAnswerMakePacket;
struct CGGuildAnswerMakePacketDefaultTypeInternal;
extern CGGuildAnswerMakePacketDefaultTypeInternal _CGGuildAnswerMakePacket_default_instance_;
class CGGuildChangeGradeAuthorityPacket;
struct CGGuildChangeGradeAuthorityPacketDefaultTypeInternal;
extern CGGuildChangeGradeAuthorityPacketDefaultTypeInternal _CGGuildChangeGradeAuthorityPacket_default_instance_;
class CGGuildChangeGradeNamePacket;
struct CGGuildChangeGradeNamePacketDefaultTypeInternal;
extern CGGuildChangeGradeNamePacketDefaultTypeInternal _CGGuildChangeGradeNamePacket_default_instance_;
class CGGuildChangeMemberGeneralPacket;
struct CGGuildChangeMemberGeneralPacketDefaultTypeInternal;
extern CGGuildChangeMemberGeneralPacketDefaultTypeInternal _CGGuildChangeMemberGeneralPacket_default_instance_;
class CGGuildChangeMemberGradePacket;
struct CGGuildChangeMemberGradePacketDefaultTypeInternal;
extern CGGuildChangeMemberGradePacketDefaultTypeInternal _CGGuildChangeMemberGradePacket_default_instance_;
class CGGuildChargeGSPPacket;
struct CGGuildChargeGSPPacketDefaultTypeInternal;
extern CGGuildChargeGSPPacketDefaultTypeInternal _CGGuildChargeGSPPacket_default_instance_;
class CGGuildDeleteCommentPacket;
struct CGGuildDeleteCommentPacketDefaultTypeInternal;
extern CGGuildDeleteCommentPacketDefaultTypeInternal _CGGuildDeleteCommentPacket_default_instance_;
class CGGuildDepositMoneyPacket;
struct CGGuildDepositMoneyPacketDefaultTypeInternal;
extern CGGuildDepositMoneyPacketDefaultTypeInternal _CGGuildDepositMoneyPacket_default_instance_;
class CGGuildInviteAnswerPacket;
struct CGGuildInviteAnswerPacketDefaultTypeInternal;
extern CGGuildInviteAnswerPacketDefaultTypeInternal _CGGuildInviteAnswerPacket_default_instance_;
class CGGuildOfferExpPacket;
struct CGGuildOfferExpPacketDefaultTypeInternal;
extern CGGuildOfferExpPacketDefaultTypeInternal _CGGuildOfferExpPacket_default_instance_;
class CGGuildPostCommentPacket;
struct CGGuildPostCommentPacketDefaultTypeInternal;
extern CGGuildPostCommentPacketDefaultTypeInternal _CGGuildPostCommentPacket_default_instance_;
class CGGuildRemoveMemberPacket;
struct CGGuildRemoveMemberPacketDefaultTypeInternal;
extern CGGuildRemoveMemberPacketDefaultTypeInternal _CGGuildRemoveMemberPacket_default_instance_;
class CGGuildRequestListPacket;
struct CGGuildRequestListPacketDefaultTypeInternal;
extern CGGuildRequestListPacketDefaultTypeInternal _CGGuildRequestListPacket_default_instance_;
class CGGuildSafeboxCheckinPacket;
struct CGGuildSafeboxCheckinPacketDefaultTypeInternal;
extern CGGuildSafeboxCheckinPacketDefaultTypeInternal _CGGuildSafeboxCheckinPacket_default_instance_;
class CGGuildSafeboxCheckoutPacket;
struct CGGuildSafeboxCheckoutPacketDefaultTypeInternal;
extern CGGuildSafeboxCheckoutPacketDefaultTypeInternal _CGGuildSafeboxCheckoutPacket_default_instance_;
class CGGuildSafeboxGetGoldPacket;
struct CGGuildSafeboxGetGoldPacketDefaultTypeInternal;
extern CGGuildSafeboxGetGoldPacketDefaultTypeInternal _CGGuildSafeboxGetGoldPacket_default_instance_;
class CGGuildSafeboxGiveGoldPacket;
struct CGGuildSafeboxGiveGoldPacketDefaultTypeInternal;
extern CGGuildSafeboxGiveGoldPacketDefaultTypeInternal _CGGuildSafeboxGiveGoldPacket_default_instance_;
class CGGuildSafeboxItemMovePacket;
struct CGGuildSafeboxItemMovePacketDefaultTypeInternal;
extern CGGuildSafeboxItemMovePacketDefaultTypeInternal _CGGuildSafeboxItemMovePacket_default_instance_;
class CGGuildSearchPacket;
struct CGGuildSearchPacketDefaultTypeInternal;
extern CGGuildSearchPacketDefaultTypeInternal _CGGuildSearchPacket_default_instance_;
class CGGuildSymbolCRCPacket;
struct CGGuildSymbolCRCPacketDefaultTypeInternal;
extern CGGuildSymbolCRCPacketDefaultTypeInternal _CGGuildSymbolCRCPacket_default_instance_;
class CGGuildSymbolUploadPacket;
struct CGGuildSymbolUploadPacketDefaultTypeInternal;
extern CGGuildSymbolUploadPacketDefaultTypeInternal _CGGuildSymbolUploadPacket_default_instance_;
class CGGuildUseSkillPacket;
struct CGGuildUseSkillPacketDefaultTypeInternal;
extern CGGuildUseSkillPacketDefaultTypeInternal _CGGuildUseSkillPacket_default_instance_;
class CGGuildWithdrawMoneyPacket;
struct CGGuildWithdrawMoneyPacketDefaultTypeInternal;
extern CGGuildWithdrawMoneyPacketDefaultTypeInternal _CGGuildWithdrawMoneyPacket_default_instance_;
class CGHackPacket;
struct CGHackPacketDefaultTypeInternal;
extern CGHackPacketDefaultTypeInternal _CGHackPacket_default_instance_;
class CGHandshakePacket;
struct CGHandshakePacketDefaultTypeInternal;
extern CGHandshakePacketDefaultTypeInternal _CGHandshakePacket_default_instance_;
class CGItemDestroyPacket;
struct CGItemDestroyPacketDefaultTypeInternal;
extern CGItemDestroyPacketDefaultTypeInternal _CGItemDestroyPacket_default_instance_;
class CGItemDropPacket;
struct CGItemDropPacketDefaultTypeInternal;
extern CGItemDropPacketDefaultTypeInternal _CGItemDropPacket_default_instance_;
class CGItemMovePacket;
struct CGItemMovePacketDefaultTypeInternal;
extern CGItemMovePacketDefaultTypeInternal _CGItemMovePacket_default_instance_;
class CGItemMultiUsePacket;
struct CGItemMultiUsePacketDefaultTypeInternal;
extern CGItemMultiUsePacketDefaultTypeInternal _CGItemMultiUsePacket_default_instance_;
class CGItemPickupPacket;
struct CGItemPickupPacketDefaultTypeInternal;
extern CGItemPickupPacketDefaultTypeInternal _CGItemPickupPacket_default_instance_;
class CGItemUsePacket;
struct CGItemUsePacketDefaultTypeInternal;
extern CGItemUsePacketDefaultTypeInternal _CGItemUsePacket_default_instance_;
class CGItemUseToItemPacket;
struct CGItemUseToItemPacketDefaultTypeInternal;
extern CGItemUseToItemPacketDefaultTypeInternal _CGItemUseToItemPacket_default_instance_;
class CGKeyAgreementPacket;
struct CGKeyAgreementPacketDefaultTypeInternal;
extern CGKeyAgreementPacketDefaultTypeInternal _CGKeyAgreementPacket_default_instance_;
class CGLoginByKeyPacket;
struct CGLoginByKeyPacketDefaultTypeInternal;
extern CGLoginByKeyPacketDefaultTypeInternal _CGLoginByKeyPacket_default_instance_;
class CGLoginVersionCheckPacket;
struct CGLoginVersionCheckPacketDefaultTypeInternal;
extern CGLoginVersionCheckPacketDefaultTypeInternal _CGLoginVersionCheckPacket_default_instance_;
class CGMarkCRCListPacket;
struct CGMarkCRCListPacketDefaultTypeInternal;
extern CGMarkCRCListPacketDefaultTypeInternal _CGMarkCRCListPacket_default_instance_;
class CGMarkUploadPacket;
struct CGMarkUploadPacketDefaultTypeInternal;
extern CGMarkUploadPacketDefaultTypeInternal _CGMarkUploadPacket_default_instance_;
class CGMessengerAddBlockByNamePacket;
struct CGMessengerAddBlockByNamePacketDefaultTypeInternal;
extern CGMessengerAddBlockByNamePacketDefaultTypeInternal _CGMessengerAddBlockByNamePacket_default_instance_;
class CGMessengerAddBlockByVIDPacket;
struct CGMessengerAddBlockByVIDPacketDefaultTypeInternal;
extern CGMessengerAddBlockByVIDPacketDefaultTypeInternal _CGMessengerAddBlockByVIDPacket_default_instance_;
class CGMessengerAddByNamePacket;
struct CGMessengerAddByNamePacketDefaultTypeInternal;
extern CGMessengerAddByNamePacketDefaultTypeInternal _CGMessengerAddByNamePacket_default_instance_;
class CGMessengerAddByVIDPacket;
struct CGMessengerAddByVIDPacketDefaultTypeInternal;
extern CGMessengerAddByVIDPacketDefaultTypeInternal _CGMessengerAddByVIDPacket_default_instance_;
class CGMessengerRemoveBlockPacket;
struct CGMessengerRemoveBlockPacketDefaultTypeInternal;
extern CGMessengerRemoveBlockPacketDefaultTypeInternal _CGMessengerRemoveBlockPacket_default_instance_;
class CGMessengerRemovePacket;
struct CGMessengerRemovePacketDefaultTypeInternal;
extern CGMessengerRemovePacketDefaultTypeInternal _CGMessengerRemovePacket_default_instance_;
class CGMovePacket;
struct CGMovePacketDefaultTypeInternal;
extern CGMovePacketDefaultTypeInternal _CGMovePacket_default_instance_;
class CGMyShopPacket;
struct CGMyShopPacketDefaultTypeInternal;
extern CGMyShopPacketDefaultTypeInternal _CGMyShopPacket_default_instance_;
class CGNextSkillUsePacket;
struct CGNextSkillUsePacketDefaultTypeInternal;
extern CGNextSkillUsePacketDefaultTypeInternal _CGNextSkillUsePacket_default_instance_;
class CGOnClickPacket;
struct CGOnClickPacketDefaultTypeInternal;
extern CGOnClickPacketDefaultTypeInternal _CGOnClickPacket_default_instance_;
class CGOnQuestTriggerPacket;
struct CGOnQuestTriggerPacketDefaultTypeInternal;
extern CGOnQuestTriggerPacketDefaultTypeInternal _CGOnQuestTriggerPacket_default_instance_;
class CGPartyInviteAnswerPacket;
struct CGPartyInviteAnswerPacketDefaultTypeInternal;
extern CGPartyInviteAnswerPacketDefaultTypeInternal _CGPartyInviteAnswerPacket_default_instance_;
class CGPartyInvitePacket;
struct CGPartyInvitePacketDefaultTypeInternal;
extern CGPartyInvitePacketDefaultTypeInternal _CGPartyInvitePacket_default_instance_;
class CGPartyParameterPacket;
struct CGPartyParameterPacketDefaultTypeInternal;
extern CGPartyParameterPacketDefaultTypeInternal _CGPartyParameterPacket_default_instance_;
class CGPartyRemovePacket;
struct CGPartyRemovePacketDefaultTypeInternal;
extern CGPartyRemovePacketDefaultTypeInternal _CGPartyRemovePacket_default_instance_;
class CGPartySetStatePacket;
struct CGPartySetStatePacketDefaultTypeInternal;
extern CGPartySetStatePacketDefaultTypeInternal _CGPartySetStatePacket_default_instance_;
class CGPartyUseSkillPacket;
struct CGPartyUseSkillPacketDefaultTypeInternal;
extern CGPartyUseSkillPacketDefaultTypeInternal _CGPartyUseSkillPacket_default_instance_;
class CGPetAttrRefineInfoPacket;
struct CGPetAttrRefineInfoPacketDefaultTypeInternal;
extern CGPetAttrRefineInfoPacketDefaultTypeInternal _CGPetAttrRefineInfoPacket_default_instance_;
class CGPetAttrRefinePacket;
struct CGPetAttrRefinePacketDefaultTypeInternal;
extern CGPetAttrRefinePacketDefaultTypeInternal _CGPetAttrRefinePacket_default_instance_;
class CGPetResetSkillPacket;
struct CGPetResetSkillPacketDefaultTypeInternal;
extern CGPetResetSkillPacketDefaultTypeInternal _CGPetResetSkillPacket_default_instance_;
class CGPetUseEggPacket;
struct CGPetUseEggPacketDefaultTypeInternal;
extern CGPetUseEggPacketDefaultTypeInternal _CGPetUseEggPacket_default_instance_;
class CGPlayerChangeNamePacket;
struct CGPlayerChangeNamePacketDefaultTypeInternal;
extern CGPlayerChangeNamePacketDefaultTypeInternal _CGPlayerChangeNamePacket_default_instance_;
class CGPlayerCreatePacket;
struct CGPlayerCreatePacketDefaultTypeInternal;
extern CGPlayerCreatePacketDefaultTypeInternal _CGPlayerCreatePacket_default_instance_;
class CGPlayerDeletePacket;
struct CGPlayerDeletePacketDefaultTypeInternal;
extern CGPlayerDeletePacketDefaultTypeInternal _CGPlayerDeletePacket_default_instance_;
class CGPlayerHairSelectPacket;
struct CGPlayerHairSelectPacketDefaultTypeInternal;
extern CGPlayerHairSelectPacketDefaultTypeInternal _CGPlayerHairSelectPacket_default_instance_;
class CGPlayerLanguageInformationPacket;
struct CGPlayerLanguageInformationPacketDefaultTypeInternal;
extern CGPlayerLanguageInformationPacketDefaultTypeInternal _CGPlayerLanguageInformationPacket_default_instance_;
class CGPlayerSelectPacket;
struct CGPlayerSelectPacketDefaultTypeInternal;
extern CGPlayerSelectPacketDefaultTypeInternal _CGPlayerSelectPacket_default_instance_;
class CGPositionPacket;
struct CGPositionPacketDefaultTypeInternal;
extern CGPositionPacketDefaultTypeInternal _CGPositionPacket_default_instance_;
class CGQuestConfirmPacket;
struct CGQuestConfirmPacketDefaultTypeInternal;
extern CGQuestConfirmPacketDefaultTypeInternal _CGQuestConfirmPacket_default_instance_;
class CGQuestInputStringPacket;
struct CGQuestInputStringPacketDefaultTypeInternal;
extern CGQuestInputStringPacketDefaultTypeInternal _CGQuestInputStringPacket_default_instance_;
class CGQuickslotAddPacket;
struct CGQuickslotAddPacketDefaultTypeInternal;
extern CGQuickslotAddPacketDefaultTypeInternal _CGQuickslotAddPacket_default_instance_;
class CGQuickslotDeletePacket;
struct CGQuickslotDeletePacketDefaultTypeInternal;
extern CGQuickslotDeletePacketDefaultTypeInternal _CGQuickslotDeletePacket_default_instance_;
class CGQuickslotSwapPacket;
struct CGQuickslotSwapPacketDefaultTypeInternal;
extern CGQuickslotSwapPacketDefaultTypeInternal _CGQuickslotSwapPacket_default_instance_;
class CGRecvWikiPacket;
struct CGRecvWikiPacketDefaultTypeInternal;
extern CGRecvWikiPacketDefaultTypeInternal _CGRecvWikiPacket_default_instance_;
class CGRefinePacket;
struct CGRefinePacketDefaultTypeInternal;
extern CGRefinePacketDefaultTypeInternal _CGRefinePacket_default_instance_;
class CGReportPacket;
struct CGReportPacketDefaultTypeInternal;
extern CGReportPacketDefaultTypeInternal _CGReportPacket_default_instance_;
class CGRunePagePacket;
struct CGRunePagePacketDefaultTypeInternal;
extern CGRunePagePacketDefaultTypeInternal _CGRunePagePacket_default_instance_;
class CGSafeboxCheckinPacket;
struct CGSafeboxCheckinPacketDefaultTypeInternal;
extern CGSafeboxCheckinPacketDefaultTypeInternal _CGSafeboxCheckinPacket_default_instance_;
class CGSafeboxCheckoutPacket;
struct CGSafeboxCheckoutPacketDefaultTypeInternal;
extern CGSafeboxCheckoutPacketDefaultTypeInternal _CGSafeboxCheckoutPacket_default_instance_;
class CGSafeboxItemMovePacket;
struct CGSafeboxItemMovePacketDefaultTypeInternal;
extern CGSafeboxItemMovePacketDefaultTypeInternal _CGSafeboxItemMovePacket_default_instance_;
class CGScriptAnswerPacket;
struct CGScriptAnswerPacketDefaultTypeInternal;
extern CGScriptAnswerPacketDefaultTypeInternal _CGScriptAnswerPacket_default_instance_;
class CGScriptButtonPacket;
struct CGScriptButtonPacketDefaultTypeInternal;
extern CGScriptButtonPacketDefaultTypeInternal _CGScriptButtonPacket_default_instance_;
class CGScriptSelectItemPacket;
struct CGScriptSelectItemPacketDefaultTypeInternal;
extern CGScriptSelectItemPacketDefaultTypeInternal _CGScriptSelectItemPacket_default_instance_;
class CGSetSkillColorPacket;
struct CGSetSkillColorPacketDefaultTypeInternal;
extern CGSetSkillColorPacketDefaultTypeInternal _CGSetSkillColorPacket_default_instance_;
class CGShootPacket;
struct CGShootPacketDefaultTypeInternal;
extern CGShootPacketDefaultTypeInternal _CGShootPacket_default_instance_;
class CGShopBuyPacket;
struct CGShopBuyPacketDefaultTypeInternal;
extern CGShopBuyPacketDefaultTypeInternal _CGShopBuyPacket_default_instance_;
class CGShopSellPacket;
struct CGShopSellPacketDefaultTypeInternal;
extern CGShopSellPacketDefaultTypeInternal _CGShopSellPacket_default_instance_;
class CGSyncPositionPacket;
struct CGSyncPositionPacketDefaultTypeInternal;
extern CGSyncPositionPacketDefaultTypeInternal _CGSyncPositionPacket_default_instance_;
class CGTargetMonsterDropInfoPacket;
struct CGTargetMonsterDropInfoPacketDefaultTypeInternal;
extern CGTargetMonsterDropInfoPacketDefaultTypeInternal _CGTargetMonsterDropInfoPacket_default_instance_;
class CGTargetPacket;
struct CGTargetPacketDefaultTypeInternal;
extern CGTargetPacketDefaultTypeInternal _CGTargetPacket_default_instance_;
class CGUseDetachmentSinglePacket;
struct CGUseDetachmentSinglePacketDefaultTypeInternal;
extern CGUseDetachmentSinglePacketDefaultTypeInternal _CGUseDetachmentSinglePacket_default_instance_;
class CGUseSkillPacket;
struct CGUseSkillPacketDefaultTypeInternal;
extern CGUseSkillPacketDefaultTypeInternal _CGUseSkillPacket_default_instance_;
class CGWhisperPacket;
struct CGWhisperPacketDefaultTypeInternal;
extern CGWhisperPacketDefaultTypeInternal _CGWhisperPacket_default_instance_;
class CGXTRAPAckPacket;
struct CGXTRAPAckPacketDefaultTypeInternal;
extern CGXTRAPAckPacketDefaultTypeInternal _CGXTRAPAckPacket_default_instance_;
}  // namespace network
PROTOBUF_NAMESPACE_OPEN
template<> ::network::CGAcceRefineAcceptPacket* Arena::CreateMaybeMessage<::network::CGAcceRefineAcceptPacket>(Arena*);
template<> ::network::CGAcceRefineCheckinPacket* Arena::CreateMaybeMessage<::network::CGAcceRefineCheckinPacket>(Arena*);
template<> ::network::CGAcceRefineCheckoutPacket* Arena::CreateMaybeMessage<::network::CGAcceRefineCheckoutPacket>(Arena*);
template<> ::network::CGAddFlyTargetPacket* Arena::CreateMaybeMessage<::network::CGAddFlyTargetPacket>(Arena*);
template<> ::network::CGAttackPacket* Arena::CreateMaybeMessage<::network::CGAttackPacket>(Arena*);
template<> ::network::CGAuctionBuyItemPacket* Arena::CreateMaybeMessage<::network::CGAuctionBuyItemPacket>(Arena*);
template<> ::network::CGAuctionExtendedSearchItemsPacket* Arena::CreateMaybeMessage<::network::CGAuctionExtendedSearchItemsPacket>(Arena*);
template<> ::network::CGAuctionInsertItemPacket* Arena::CreateMaybeMessage<::network::CGAuctionInsertItemPacket>(Arena*);
template<> ::network::CGAuctionMarkShopPacket* Arena::CreateMaybeMessage<::network::CGAuctionMarkShopPacket>(Arena*);
template<> ::network::CGAuctionRequestAveragePricePacket* Arena::CreateMaybeMessage<::network::CGAuctionRequestAveragePricePacket>(Arena*);
template<> ::network::CGAuctionSearchItemsPacket* Arena::CreateMaybeMessage<::network::CGAuctionSearchItemsPacket>(Arena*);
template<> ::network::CGAuctionShopClosePacket* Arena::CreateMaybeMessage<::network::CGAuctionShopClosePacket>(Arena*);
template<> ::network::CGAuctionShopOpenPacket* Arena::CreateMaybeMessage<::network::CGAuctionShopOpenPacket>(Arena*);
template<> ::network::CGAuctionShopTakeGoldPacket* Arena::CreateMaybeMessage<::network::CGAuctionShopTakeGoldPacket>(Arena*);
template<> ::network::CGAuctionTakeGoldPacket* Arena::CreateMaybeMessage<::network::CGAuctionTakeGoldPacket>(Arena*);
template<> ::network::CGAuctionTakeItemPacket* Arena::CreateMaybeMessage<::network::CGAuctionTakeItemPacket>(Arena*);
template<> ::network::CGAuthLoginPacket* Arena::CreateMaybeMessage<::network::CGAuthLoginPacket>(Arena*);
template<> ::network::CGAuthOpenIDLoginPacket* Arena::CreateMaybeMessage<::network::CGAuthOpenIDLoginPacket>(Arena*);
template<> ::network::CGAuthPasspodAnswerPacket* Arena::CreateMaybeMessage<::network::CGAuthPasspodAnswerPacket>(Arena*);
template<> ::network::CGBotReportLogPacket* Arena::CreateMaybeMessage<::network::CGBotReportLogPacket>(Arena*);
template<> ::network::CGChatPacket* Arena::CreateMaybeMessage<::network::CGChatPacket>(Arena*);
template<> ::network::CGClientVersionPacket* Arena::CreateMaybeMessage<::network::CGClientVersionPacket>(Arena*);
template<> ::network::CGCombatZoneRequestActionPacket* Arena::CreateMaybeMessage<::network::CGCombatZoneRequestActionPacket>(Arena*);
template<> ::network::CGCostumeBonusTransferPacket* Arena::CreateMaybeMessage<::network::CGCostumeBonusTransferPacket>(Arena*);
template<> ::network::CGCostumeVisibilityPacket* Arena::CreateMaybeMessage<::network::CGCostumeVisibilityPacket>(Arena*);
template<> ::network::CGCrystalRefinePacket* Arena::CreateMaybeMessage<::network::CGCrystalRefinePacket>(Arena*);
template<> ::network::CGDragonSoulRefinePacket* Arena::CreateMaybeMessage<::network::CGDragonSoulRefinePacket>(Arena*);
template<> ::network::CGEmpirePacket* Arena::CreateMaybeMessage<::network::CGEmpirePacket>(Arena*);
template<> ::network::CGEquipmentPageAddPacket* Arena::CreateMaybeMessage<::network::CGEquipmentPageAddPacket>(Arena*);
template<> ::network::CGEquipmentPageDeletePacket* Arena::CreateMaybeMessage<::network::CGEquipmentPageDeletePacket>(Arena*);
template<> ::network::CGEquipmentPageSelectPacket* Arena::CreateMaybeMessage<::network::CGEquipmentPageSelectPacket>(Arena*);
template<> ::network::CGEventRequestAnswerPacket* Arena::CreateMaybeMessage<::network::CGEventRequestAnswerPacket>(Arena*);
template<> ::network::CGExchangeGoldAddPacket* Arena::CreateMaybeMessage<::network::CGExchangeGoldAddPacket>(Arena*);
template<> ::network::CGExchangeItemAddPacket* Arena::CreateMaybeMessage<::network::CGExchangeItemAddPacket>(Arena*);
template<> ::network::CGExchangeItemDelPacket* Arena::CreateMaybeMessage<::network::CGExchangeItemDelPacket>(Arena*);
template<> ::network::CGExchangeStartPacket* Arena::CreateMaybeMessage<::network::CGExchangeStartPacket>(Arena*);
template<> ::network::CGFishingPacket* Arena::CreateMaybeMessage<::network::CGFishingPacket>(Arena*);
template<> ::network::CGFlyTargetPacket* Arena::CreateMaybeMessage<::network::CGFlyTargetPacket>(Arena*);
template<> ::network::CGForcedRewarpPacket* Arena::CreateMaybeMessage<::network::CGForcedRewarpPacket>(Arena*);
template<> ::network::CGGiveItemPacket* Arena::CreateMaybeMessage<::network::CGGiveItemPacket>(Arena*);
template<> ::network::CGGuildAddMemberPacket* Arena::CreateMaybeMessage<::network::CGGuildAddMemberPacket>(Arena*);
template<> ::network::CGGuildAnswerMakePacket* Arena::CreateMaybeMessage<::network::CGGuildAnswerMakePacket>(Arena*);
template<> ::network::CGGuildChangeGradeAuthorityPacket* Arena::CreateMaybeMessage<::network::CGGuildChangeGradeAuthorityPacket>(Arena*);
template<> ::network::CGGuildChangeGradeNamePacket* Arena::CreateMaybeMessage<::network::CGGuildChangeGradeNamePacket>(Arena*);
template<> ::network::CGGuildChangeMemberGeneralPacket* Arena::CreateMaybeMessage<::network::CGGuildChangeMemberGeneralPacket>(Arena*);
template<> ::network::CGGuildChangeMemberGradePacket* Arena::CreateMaybeMessage<::network::CGGuildChangeMemberGradePacket>(Arena*);
template<> ::network::CGGuildChargeGSPPacket* Arena::CreateMaybeMessage<::network::CGGuildChargeGSPPacket>(Arena*);
template<> ::network::CGGuildDeleteCommentPacket* Arena::CreateMaybeMessage<::network::CGGuildDeleteCommentPacket>(Arena*);
template<> ::network::CGGuildDepositMoneyPacket* Arena::CreateMaybeMessage<::network::CGGuildDepositMoneyPacket>(Arena*);
template<> ::network::CGGuildInviteAnswerPacket* Arena::CreateMaybeMessage<::network::CGGuildInviteAnswerPacket>(Arena*);
template<> ::network::CGGuildOfferExpPacket* Arena::CreateMaybeMessage<::network::CGGuildOfferExpPacket>(Arena*);
template<> ::network::CGGuildPostCommentPacket* Arena::CreateMaybeMessage<::network::CGGuildPostCommentPacket>(Arena*);
template<> ::network::CGGuildRemoveMemberPacket* Arena::CreateMaybeMessage<::network::CGGuildRemoveMemberPacket>(Arena*);
template<> ::network::CGGuildRequestListPacket* Arena::CreateMaybeMessage<::network::CGGuildRequestListPacket>(Arena*);
template<> ::network::CGGuildSafeboxCheckinPacket* Arena::CreateMaybeMessage<::network::CGGuildSafeboxCheckinPacket>(Arena*);
template<> ::network::CGGuildSafeboxCheckoutPacket* Arena::CreateMaybeMessage<::network::CGGuildSafeboxCheckoutPacket>(Arena*);
template<> ::network::CGGuildSafeboxGetGoldPacket* Arena::CreateMaybeMessage<::network::CGGuildSafeboxGetGoldPacket>(Arena*);
template<> ::network::CGGuildSafeboxGiveGoldPacket* Arena::CreateMaybeMessage<::network::CGGuildSafeboxGiveGoldPacket>(Arena*);
template<> ::network::CGGuildSafeboxItemMovePacket* Arena::CreateMaybeMessage<::network::CGGuildSafeboxItemMovePacket>(Arena*);
template<> ::network::CGGuildSearchPacket* Arena::CreateMaybeMessage<::network::CGGuildSearchPacket>(Arena*);
template<> ::network::CGGuildSymbolCRCPacket* Arena::CreateMaybeMessage<::network::CGGuildSymbolCRCPacket>(Arena*);
template<> ::network::CGGuildSymbolUploadPacket* Arena::CreateMaybeMessage<::network::CGGuildSymbolUploadPacket>(Arena*);
template<> ::network::CGGuildUseSkillPacket* Arena::CreateMaybeMessage<::network::CGGuildUseSkillPacket>(Arena*);
template<> ::network::CGGuildWithdrawMoneyPacket* Arena::CreateMaybeMessage<::network::CGGuildWithdrawMoneyPacket>(Arena*);
template<> ::network::CGHackPacket* Arena::CreateMaybeMessage<::network::CGHackPacket>(Arena*);
template<> ::network::CGHandshakePacket* Arena::CreateMaybeMessage<::network::CGHandshakePacket>(Arena*);
template<> ::network::CGItemDestroyPacket* Arena::CreateMaybeMessage<::network::CGItemDestroyPacket>(Arena*);
template<> ::network::CGItemDropPacket* Arena::CreateMaybeMessage<::network::CGItemDropPacket>(Arena*);
template<> ::network::CGItemMovePacket* Arena::CreateMaybeMessage<::network::CGItemMovePacket>(Arena*);
template<> ::network::CGItemMultiUsePacket* Arena::CreateMaybeMessage<::network::CGItemMultiUsePacket>(Arena*);
template<> ::network::CGItemPickupPacket* Arena::CreateMaybeMessage<::network::CGItemPickupPacket>(Arena*);
template<> ::network::CGItemUsePacket* Arena::CreateMaybeMessage<::network::CGItemUsePacket>(Arena*);
template<> ::network::CGItemUseToItemPacket* Arena::CreateMaybeMessage<::network::CGItemUseToItemPacket>(Arena*);
template<> ::network::CGKeyAgreementPacket* Arena::CreateMaybeMessage<::network::CGKeyAgreementPacket>(Arena*);
template<> ::network::CGLoginByKeyPacket* Arena::CreateMaybeMessage<::network::CGLoginByKeyPacket>(Arena*);
template<> ::network::CGLoginVersionCheckPacket* Arena::CreateMaybeMessage<::network::CGLoginVersionCheckPacket>(Arena*);
template<> ::network::CGMarkCRCListPacket* Arena::CreateMaybeMessage<::network::CGMarkCRCListPacket>(Arena*);
template<> ::network::CGMarkUploadPacket* Arena::CreateMaybeMessage<::network::CGMarkUploadPacket>(Arena*);
template<> ::network::CGMessengerAddBlockByNamePacket* Arena::CreateMaybeMessage<::network::CGMessengerAddBlockByNamePacket>(Arena*);
template<> ::network::CGMessengerAddBlockByVIDPacket* Arena::CreateMaybeMessage<::network::CGMessengerAddBlockByVIDPacket>(Arena*);
template<> ::network::CGMessengerAddByNamePacket* Arena::CreateMaybeMessage<::network::CGMessengerAddByNamePacket>(Arena*);
template<> ::network::CGMessengerAddByVIDPacket* Arena::CreateMaybeMessage<::network::CGMessengerAddByVIDPacket>(Arena*);
template<> ::network::CGMessengerRemoveBlockPacket* Arena::CreateMaybeMessage<::network::CGMessengerRemoveBlockPacket>(Arena*);
template<> ::network::CGMessengerRemovePacket* Arena::CreateMaybeMessage<::network::CGMessengerRemovePacket>(Arena*);
template<> ::network::CGMovePacket* Arena::CreateMaybeMessage<::network::CGMovePacket>(Arena*);
template<> ::network::CGMyShopPacket* Arena::CreateMaybeMessage<::network::CGMyShopPacket>(Arena*);
template<> ::network::CGNextSkillUsePacket* Arena::CreateMaybeMessage<::network::CGNextSkillUsePacket>(Arena*);
template<> ::network::CGOnClickPacket* Arena::CreateMaybeMessage<::network::CGOnClickPacket>(Arena*);
template<> ::network::CGOnQuestTriggerPacket* Arena::CreateMaybeMessage<::network::CGOnQuestTriggerPacket>(Arena*);
template<> ::network::CGPartyInviteAnswerPacket* Arena::CreateMaybeMessage<::network::CGPartyInviteAnswerPacket>(Arena*);
template<> ::network::CGPartyInvitePacket* Arena::CreateMaybeMessage<::network::CGPartyInvitePacket>(Arena*);
template<> ::network::CGPartyParameterPacket* Arena::CreateMaybeMessage<::network::CGPartyParameterPacket>(Arena*);
template<> ::network::CGPartyRemovePacket* Arena::CreateMaybeMessage<::network::CGPartyRemovePacket>(Arena*);
template<> ::network::CGPartySetStatePacket* Arena::CreateMaybeMessage<::network::CGPartySetStatePacket>(Arena*);
template<> ::network::CGPartyUseSkillPacket* Arena::CreateMaybeMessage<::network::CGPartyUseSkillPacket>(Arena*);
template<> ::network::CGPetAttrRefineInfoPacket* Arena::CreateMaybeMessage<::network::CGPetAttrRefineInfoPacket>(Arena*);
template<> ::network::CGPetAttrRefinePacket* Arena::CreateMaybeMessage<::network::CGPetAttrRefinePacket>(Arena*);
template<> ::network::CGPetResetSkillPacket* Arena::CreateMaybeMessage<::network::CGPetResetSkillPacket>(Arena*);
template<> ::network::CGPetUseEggPacket* Arena::CreateMaybeMessage<::network::CGPetUseEggPacket>(Arena*);
template<> ::network::CGPlayerChangeNamePacket* Arena::CreateMaybeMessage<::network::CGPlayerChangeNamePacket>(Arena*);
template<> ::network::CGPlayerCreatePacket* Arena::CreateMaybeMessage<::network::CGPlayerCreatePacket>(Arena*);
template<> ::network::CGPlayerDeletePacket* Arena::CreateMaybeMessage<::network::CGPlayerDeletePacket>(Arena*);
template<> ::network::CGPlayerHairSelectPacket* Arena::CreateMaybeMessage<::network::CGPlayerHairSelectPacket>(Arena*);
template<> ::network::CGPlayerLanguageInformationPacket* Arena::CreateMaybeMessage<::network::CGPlayerLanguageInformationPacket>(Arena*);
template<> ::network::CGPlayerSelectPacket* Arena::CreateMaybeMessage<::network::CGPlayerSelectPacket>(Arena*);
template<> ::network::CGPositionPacket* Arena::CreateMaybeMessage<::network::CGPositionPacket>(Arena*);
template<> ::network::CGQuestConfirmPacket* Arena::CreateMaybeMessage<::network::CGQuestConfirmPacket>(Arena*);
template<> ::network::CGQuestInputStringPacket* Arena::CreateMaybeMessage<::network::CGQuestInputStringPacket>(Arena*);
template<> ::network::CGQuickslotAddPacket* Arena::CreateMaybeMessage<::network::CGQuickslotAddPacket>(Arena*);
template<> ::network::CGQuickslotDeletePacket* Arena::CreateMaybeMessage<::network::CGQuickslotDeletePacket>(Arena*);
template<> ::network::CGQuickslotSwapPacket* Arena::CreateMaybeMessage<::network::CGQuickslotSwapPacket>(Arena*);
template<> ::network::CGRecvWikiPacket* Arena::CreateMaybeMessage<::network::CGRecvWikiPacket>(Arena*);
template<> ::network::CGRefinePacket* Arena::CreateMaybeMessage<::network::CGRefinePacket>(Arena*);
template<> ::network::CGReportPacket* Arena::CreateMaybeMessage<::network::CGReportPacket>(Arena*);
template<> ::network::CGRunePagePacket* Arena::CreateMaybeMessage<::network::CGRunePagePacket>(Arena*);
template<> ::network::CGSafeboxCheckinPacket* Arena::CreateMaybeMessage<::network::CGSafeboxCheckinPacket>(Arena*);
template<> ::network::CGSafeboxCheckoutPacket* Arena::CreateMaybeMessage<::network::CGSafeboxCheckoutPacket>(Arena*);
template<> ::network::CGSafeboxItemMovePacket* Arena::CreateMaybeMessage<::network::CGSafeboxItemMovePacket>(Arena*);
template<> ::network::CGScriptAnswerPacket* Arena::CreateMaybeMessage<::network::CGScriptAnswerPacket>(Arena*);
template<> ::network::CGScriptButtonPacket* Arena::CreateMaybeMessage<::network::CGScriptButtonPacket>(Arena*);
template<> ::network::CGScriptSelectItemPacket* Arena::CreateMaybeMessage<::network::CGScriptSelectItemPacket>(Arena*);
template<> ::network::CGSetSkillColorPacket* Arena::CreateMaybeMessage<::network::CGSetSkillColorPacket>(Arena*);
template<> ::network::CGShootPacket* Arena::CreateMaybeMessage<::network::CGShootPacket>(Arena*);
template<> ::network::CGShopBuyPacket* Arena::CreateMaybeMessage<::network::CGShopBuyPacket>(Arena*);
template<> ::network::CGShopSellPacket* Arena::CreateMaybeMessage<::network::CGShopSellPacket>(Arena*);
template<> ::network::CGSyncPositionPacket* Arena::CreateMaybeMessage<::network::CGSyncPositionPacket>(Arena*);
template<> ::network::CGTargetMonsterDropInfoPacket* Arena::CreateMaybeMessage<::network::CGTargetMonsterDropInfoPacket>(Arena*);
template<> ::network::CGTargetPacket* Arena::CreateMaybeMessage<::network::CGTargetPacket>(Arena*);
template<> ::network::CGUseDetachmentSinglePacket* Arena::CreateMaybeMessage<::network::CGUseDetachmentSinglePacket>(Arena*);
template<> ::network::CGUseSkillPacket* Arena::CreateMaybeMessage<::network::CGUseSkillPacket>(Arena*);
template<> ::network::CGWhisperPacket* Arena::CreateMaybeMessage<::network::CGWhisperPacket>(Arena*);
template<> ::network::CGXTRAPAckPacket* Arena::CreateMaybeMessage<::network::CGXTRAPAckPacket>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace network {

// ===================================================================

class CGHandshakePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGHandshakePacket) */ {
 public:
  inline CGHandshakePacket() : CGHandshakePacket(nullptr) {}
  ~CGHandshakePacket() override;
  explicit PROTOBUF_CONSTEXPR CGHandshakePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGHandshakePacket(const CGHandshakePacket& from);
  CGHandshakePacket(CGHandshakePacket&& from) noexcept
    : CGHandshakePacket() {
    *this = ::std::move(from);
  }

  inline CGHandshakePacket& operator=(const CGHandshakePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGHandshakePacket& operator=(CGHandshakePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGHandshakePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGHandshakePacket* internal_default_instance() {
    return reinterpret_cast<const CGHandshakePacket*>(
               &_CGHandshakePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CGHandshakePacket& a, CGHandshakePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGHandshakePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGHandshakePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGHandshakePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGHandshakePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGHandshakePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGHandshakePacket& from) {
    CGHandshakePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGHandshakePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGHandshakePacket";
  }
  protected:
  explicit CGHandshakePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCryptDataFieldNumber = 4,
    kHandshakeFieldNumber = 1,
    kTimeFieldNumber = 2,
    kDeltaFieldNumber = 3,
  };
  // bytes crypt_data = 4;
  void clear_crypt_data();
  const std::string& crypt_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_crypt_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_crypt_data();
  PROTOBUF_NODISCARD std::string* release_crypt_data();
  void set_allocated_crypt_data(std::string* crypt_data);
  private:
  const std::string& _internal_crypt_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crypt_data(const std::string& value);
  std::string* _internal_mutable_crypt_data();
  public:

  // uint32 handshake = 1;
  void clear_handshake();
  uint32_t handshake() const;
  void set_handshake(uint32_t value);
  private:
  uint32_t _internal_handshake() const;
  void _internal_set_handshake(uint32_t value);
  public:

  // uint32 time = 2;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // sint32 delta = 3;
  void clear_delta();
  int32_t delta() const;
  void set_delta(int32_t value);
  private:
  int32_t _internal_delta() const;
  void _internal_set_delta(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGHandshakePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crypt_data_;
    uint32_t handshake_;
    uint32_t time_;
    int32_t delta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGKeyAgreementPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGKeyAgreementPacket) */ {
 public:
  inline CGKeyAgreementPacket() : CGKeyAgreementPacket(nullptr) {}
  ~CGKeyAgreementPacket() override;
  explicit PROTOBUF_CONSTEXPR CGKeyAgreementPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGKeyAgreementPacket(const CGKeyAgreementPacket& from);
  CGKeyAgreementPacket(CGKeyAgreementPacket&& from) noexcept
    : CGKeyAgreementPacket() {
    *this = ::std::move(from);
  }

  inline CGKeyAgreementPacket& operator=(const CGKeyAgreementPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGKeyAgreementPacket& operator=(CGKeyAgreementPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGKeyAgreementPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGKeyAgreementPacket* internal_default_instance() {
    return reinterpret_cast<const CGKeyAgreementPacket*>(
               &_CGKeyAgreementPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CGKeyAgreementPacket& a, CGKeyAgreementPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGKeyAgreementPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGKeyAgreementPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGKeyAgreementPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGKeyAgreementPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGKeyAgreementPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGKeyAgreementPacket& from) {
    CGKeyAgreementPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGKeyAgreementPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGKeyAgreementPacket";
  }
  protected:
  explicit CGKeyAgreementPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kAgreedLengthFieldNumber = 2,
    kDataLengthFieldNumber = 3,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 header = 1;
  void clear_header();
  uint32_t header() const;
  void set_header(uint32_t value);
  private:
  uint32_t _internal_header() const;
  void _internal_set_header(uint32_t value);
  public:

  // uint32 agreed_length = 2;
  void clear_agreed_length();
  uint32_t agreed_length() const;
  void set_agreed_length(uint32_t value);
  private:
  uint32_t _internal_agreed_length() const;
  void _internal_set_agreed_length(uint32_t value);
  public:

  // uint32 data_length = 3;
  void clear_data_length();
  uint32_t data_length() const;
  void set_data_length(uint32_t value);
  private:
  uint32_t _internal_data_length() const;
  void _internal_set_data_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGKeyAgreementPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint32_t header_;
    uint32_t agreed_length_;
    uint32_t data_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuthLoginPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuthLoginPacket) */ {
 public:
  inline CGAuthLoginPacket() : CGAuthLoginPacket(nullptr) {}
  ~CGAuthLoginPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuthLoginPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuthLoginPacket(const CGAuthLoginPacket& from);
  CGAuthLoginPacket(CGAuthLoginPacket&& from) noexcept
    : CGAuthLoginPacket() {
    *this = ::std::move(from);
  }

  inline CGAuthLoginPacket& operator=(const CGAuthLoginPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuthLoginPacket& operator=(CGAuthLoginPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuthLoginPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuthLoginPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuthLoginPacket*>(
               &_CGAuthLoginPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CGAuthLoginPacket& a, CGAuthLoginPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuthLoginPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuthLoginPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuthLoginPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuthLoginPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuthLoginPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuthLoginPacket& from) {
    CGAuthLoginPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuthLoginPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuthLoginPacket";
  }
  protected:
  explicit CGAuthLoginPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientKeysFieldNumber = 4,
    kLoginFieldNumber = 1,
    kPasswdFieldNumber = 2,
    kHwidFieldNumber = 3,
    kPcNameFieldNumber = 7,
    kUserNameFieldNumber = 8,
    kPcNameRealFieldNumber = 9,
    kUserNameRealFieldNumber = 10,
    kHashFieldNumber = 11,
    kVersionFieldNumber = 5,
    kLanguageFieldNumber = 6,
  };
  // repeated uint32 client_keys = 4;
  int client_keys_size() const;
  private:
  int _internal_client_keys_size() const;
  public:
  void clear_client_keys();
  private:
  uint32_t _internal_client_keys(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_client_keys() const;
  void _internal_add_client_keys(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_client_keys();
  public:
  uint32_t client_keys(int index) const;
  void set_client_keys(int index, uint32_t value);
  void add_client_keys(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      client_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_client_keys();

  // bytes login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // bytes passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // bytes hwid = 3;
  void clear_hwid();
  const std::string& hwid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hwid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hwid();
  PROTOBUF_NODISCARD std::string* release_hwid();
  void set_allocated_hwid(std::string* hwid);
  private:
  const std::string& _internal_hwid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hwid(const std::string& value);
  std::string* _internal_mutable_hwid();
  public:

  // bytes pc_name = 7;
  void clear_pc_name();
  const std::string& pc_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pc_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pc_name();
  PROTOBUF_NODISCARD std::string* release_pc_name();
  void set_allocated_pc_name(std::string* pc_name);
  private:
  const std::string& _internal_pc_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pc_name(const std::string& value);
  std::string* _internal_mutable_pc_name();
  public:

  // bytes user_name = 8;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bytes pc_name_real = 9;
  void clear_pc_name_real();
  const std::string& pc_name_real() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pc_name_real(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pc_name_real();
  PROTOBUF_NODISCARD std::string* release_pc_name_real();
  void set_allocated_pc_name_real(std::string* pc_name_real);
  private:
  const std::string& _internal_pc_name_real() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pc_name_real(const std::string& value);
  std::string* _internal_mutable_pc_name_real();
  public:

  // bytes user_name_real = 10;
  void clear_user_name_real();
  const std::string& user_name_real() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name_real(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name_real();
  PROTOBUF_NODISCARD std::string* release_user_name_real();
  void set_allocated_user_name_real(std::string* user_name_real);
  private:
  const std::string& _internal_user_name_real() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name_real(const std::string& value);
  std::string* _internal_mutable_user_name_real();
  public:

  // bytes hash = 11;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // uint32 version = 5;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // uint32 language = 6;
  void clear_language();
  uint32_t language() const;
  void set_language(uint32_t value);
  private:
  uint32_t _internal_language() const;
  void _internal_set_language(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuthLoginPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > client_keys_;
    mutable std::atomic<int> _client_keys_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hwid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pc_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pc_name_real_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_real_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    uint32_t version_;
    uint32_t language_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuthOpenIDLoginPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuthOpenIDLoginPacket) */ {
 public:
  inline CGAuthOpenIDLoginPacket() : CGAuthOpenIDLoginPacket(nullptr) {}
  ~CGAuthOpenIDLoginPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuthOpenIDLoginPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuthOpenIDLoginPacket(const CGAuthOpenIDLoginPacket& from);
  CGAuthOpenIDLoginPacket(CGAuthOpenIDLoginPacket&& from) noexcept
    : CGAuthOpenIDLoginPacket() {
    *this = ::std::move(from);
  }

  inline CGAuthOpenIDLoginPacket& operator=(const CGAuthOpenIDLoginPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuthOpenIDLoginPacket& operator=(CGAuthOpenIDLoginPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuthOpenIDLoginPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuthOpenIDLoginPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuthOpenIDLoginPacket*>(
               &_CGAuthOpenIDLoginPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CGAuthOpenIDLoginPacket& a, CGAuthOpenIDLoginPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuthOpenIDLoginPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuthOpenIDLoginPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuthOpenIDLoginPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuthOpenIDLoginPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuthOpenIDLoginPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuthOpenIDLoginPacket& from) {
    CGAuthOpenIDLoginPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuthOpenIDLoginPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuthOpenIDLoginPacket";
  }
  protected:
  explicit CGAuthOpenIDLoginPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientKeysFieldNumber = 2,
    kAuthKeyFieldNumber = 1,
  };
  // repeated uint32 client_keys = 2;
  int client_keys_size() const;
  private:
  int _internal_client_keys_size() const;
  public:
  void clear_client_keys();
  private:
  uint32_t _internal_client_keys(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_client_keys() const;
  void _internal_add_client_keys(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_client_keys();
  public:
  uint32_t client_keys(int index) const;
  void set_client_keys(int index, uint32_t value);
  void add_client_keys(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      client_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_client_keys();

  // bytes auth_key = 1;
  void clear_auth_key();
  const std::string& auth_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_key();
  PROTOBUF_NODISCARD std::string* release_auth_key();
  void set_allocated_auth_key(std::string* auth_key);
  private:
  const std::string& _internal_auth_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_key(const std::string& value);
  std::string* _internal_mutable_auth_key();
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuthOpenIDLoginPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > client_keys_;
    mutable std::atomic<int> _client_keys_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuthPasspodAnswerPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuthPasspodAnswerPacket) */ {
 public:
  inline CGAuthPasspodAnswerPacket() : CGAuthPasspodAnswerPacket(nullptr) {}
  ~CGAuthPasspodAnswerPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuthPasspodAnswerPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuthPasspodAnswerPacket(const CGAuthPasspodAnswerPacket& from);
  CGAuthPasspodAnswerPacket(CGAuthPasspodAnswerPacket&& from) noexcept
    : CGAuthPasspodAnswerPacket() {
    *this = ::std::move(from);
  }

  inline CGAuthPasspodAnswerPacket& operator=(const CGAuthPasspodAnswerPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuthPasspodAnswerPacket& operator=(CGAuthPasspodAnswerPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuthPasspodAnswerPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuthPasspodAnswerPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuthPasspodAnswerPacket*>(
               &_CGAuthPasspodAnswerPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CGAuthPasspodAnswerPacket& a, CGAuthPasspodAnswerPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuthPasspodAnswerPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuthPasspodAnswerPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuthPasspodAnswerPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuthPasspodAnswerPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuthPasspodAnswerPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuthPasspodAnswerPacket& from) {
    CGAuthPasspodAnswerPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuthPasspodAnswerPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuthPasspodAnswerPacket";
  }
  protected:
  explicit CGAuthPasspodAnswerPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnswerFieldNumber = 1,
  };
  // bytes answer = 1;
  void clear_answer();
  const std::string& answer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_answer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_answer();
  PROTOBUF_NODISCARD std::string* release_answer();
  void set_allocated_answer(std::string* answer);
  private:
  const std::string& _internal_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer(const std::string& value);
  std::string* _internal_mutable_answer();
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuthPasspodAnswerPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr answer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGLoginByKeyPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGLoginByKeyPacket) */ {
 public:
  inline CGLoginByKeyPacket() : CGLoginByKeyPacket(nullptr) {}
  ~CGLoginByKeyPacket() override;
  explicit PROTOBUF_CONSTEXPR CGLoginByKeyPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGLoginByKeyPacket(const CGLoginByKeyPacket& from);
  CGLoginByKeyPacket(CGLoginByKeyPacket&& from) noexcept
    : CGLoginByKeyPacket() {
    *this = ::std::move(from);
  }

  inline CGLoginByKeyPacket& operator=(const CGLoginByKeyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGLoginByKeyPacket& operator=(CGLoginByKeyPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGLoginByKeyPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGLoginByKeyPacket* internal_default_instance() {
    return reinterpret_cast<const CGLoginByKeyPacket*>(
               &_CGLoginByKeyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CGLoginByKeyPacket& a, CGLoginByKeyPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGLoginByKeyPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGLoginByKeyPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGLoginByKeyPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGLoginByKeyPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGLoginByKeyPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGLoginByKeyPacket& from) {
    CGLoginByKeyPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGLoginByKeyPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGLoginByKeyPacket";
  }
  protected:
  explicit CGLoginByKeyPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientKeyFieldNumber = 3,
    kLoginFieldNumber = 1,
    kLoginKeyFieldNumber = 2,
    kLocaleFieldNumber = 4,
  };
  // repeated uint32 client_key = 3;
  int client_key_size() const;
  private:
  int _internal_client_key_size() const;
  public:
  void clear_client_key();
  private:
  uint32_t _internal_client_key(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_client_key() const;
  void _internal_add_client_key(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_client_key();
  public:
  uint32_t client_key(int index) const;
  void set_client_key(int index, uint32_t value);
  void add_client_key(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      client_key() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_client_key();

  // bytes login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // uint32 login_key = 2;
  void clear_login_key();
  uint32_t login_key() const;
  void set_login_key(uint32_t value);
  private:
  uint32_t _internal_login_key() const;
  void _internal_set_login_key(uint32_t value);
  public:

  // uint32 locale = 4;
  void clear_locale();
  uint32_t locale() const;
  void set_locale(uint32_t value);
  private:
  uint32_t _internal_locale() const;
  void _internal_set_locale(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGLoginByKeyPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > client_key_;
    mutable std::atomic<int> _client_key_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    uint32_t login_key_;
    uint32_t locale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGEmpirePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGEmpirePacket) */ {
 public:
  inline CGEmpirePacket() : CGEmpirePacket(nullptr) {}
  ~CGEmpirePacket() override;
  explicit PROTOBUF_CONSTEXPR CGEmpirePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGEmpirePacket(const CGEmpirePacket& from);
  CGEmpirePacket(CGEmpirePacket&& from) noexcept
    : CGEmpirePacket() {
    *this = ::std::move(from);
  }

  inline CGEmpirePacket& operator=(const CGEmpirePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGEmpirePacket& operator=(CGEmpirePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGEmpirePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGEmpirePacket* internal_default_instance() {
    return reinterpret_cast<const CGEmpirePacket*>(
               &_CGEmpirePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CGEmpirePacket& a, CGEmpirePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGEmpirePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGEmpirePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGEmpirePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGEmpirePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGEmpirePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGEmpirePacket& from) {
    CGEmpirePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGEmpirePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGEmpirePacket";
  }
  protected:
  explicit CGEmpirePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmpireFieldNumber = 1,
  };
  // uint32 empire = 1;
  void clear_empire();
  uint32_t empire() const;
  void set_empire(uint32_t value);
  private:
  uint32_t _internal_empire() const;
  void _internal_set_empire(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGEmpirePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t empire_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPlayerSelectPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPlayerSelectPacket) */ {
 public:
  inline CGPlayerSelectPacket() : CGPlayerSelectPacket(nullptr) {}
  ~CGPlayerSelectPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPlayerSelectPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPlayerSelectPacket(const CGPlayerSelectPacket& from);
  CGPlayerSelectPacket(CGPlayerSelectPacket&& from) noexcept
    : CGPlayerSelectPacket() {
    *this = ::std::move(from);
  }

  inline CGPlayerSelectPacket& operator=(const CGPlayerSelectPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPlayerSelectPacket& operator=(CGPlayerSelectPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPlayerSelectPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPlayerSelectPacket* internal_default_instance() {
    return reinterpret_cast<const CGPlayerSelectPacket*>(
               &_CGPlayerSelectPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CGPlayerSelectPacket& a, CGPlayerSelectPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPlayerSelectPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPlayerSelectPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPlayerSelectPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPlayerSelectPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPlayerSelectPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPlayerSelectPacket& from) {
    CGPlayerSelectPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPlayerSelectPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPlayerSelectPacket";
  }
  protected:
  explicit CGPlayerSelectPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPlayerSelectPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPlayerCreatePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPlayerCreatePacket) */ {
 public:
  inline CGPlayerCreatePacket() : CGPlayerCreatePacket(nullptr) {}
  ~CGPlayerCreatePacket() override;
  explicit PROTOBUF_CONSTEXPR CGPlayerCreatePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPlayerCreatePacket(const CGPlayerCreatePacket& from);
  CGPlayerCreatePacket(CGPlayerCreatePacket&& from) noexcept
    : CGPlayerCreatePacket() {
    *this = ::std::move(from);
  }

  inline CGPlayerCreatePacket& operator=(const CGPlayerCreatePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPlayerCreatePacket& operator=(CGPlayerCreatePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPlayerCreatePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPlayerCreatePacket* internal_default_instance() {
    return reinterpret_cast<const CGPlayerCreatePacket*>(
               &_CGPlayerCreatePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CGPlayerCreatePacket& a, CGPlayerCreatePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPlayerCreatePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPlayerCreatePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPlayerCreatePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPlayerCreatePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPlayerCreatePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPlayerCreatePacket& from) {
    CGPlayerCreatePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPlayerCreatePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPlayerCreatePacket";
  }
  protected:
  explicit CGPlayerCreatePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIndexFieldNumber = 1,
    kJobFieldNumber = 3,
    kShapeFieldNumber = 4,
    kConFieldNumber = 5,
    kIntFieldNumber = 6,
    kStrFieldNumber = 7,
    kDexFieldNumber = 8,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // uint32 job = 3;
  void clear_job();
  uint32_t job() const;
  void set_job(uint32_t value);
  private:
  uint32_t _internal_job() const;
  void _internal_set_job(uint32_t value);
  public:

  // uint32 shape = 4;
  void clear_shape();
  uint32_t shape() const;
  void set_shape(uint32_t value);
  private:
  uint32_t _internal_shape() const;
  void _internal_set_shape(uint32_t value);
  public:

  // uint32 con = 5;
  void clear_con();
  uint32_t con() const;
  void set_con(uint32_t value);
  private:
  uint32_t _internal_con() const;
  void _internal_set_con(uint32_t value);
  public:

  // uint32 int = 6;
  void clear_int_();
  uint32_t int_() const;
  void set_int_(uint32_t value);
  private:
  uint32_t _internal_int_() const;
  void _internal_set_int_(uint32_t value);
  public:

  // uint32 str = 7;
  void clear_str();
  uint32_t str() const;
  void set_str(uint32_t value);
  private:
  uint32_t _internal_str() const;
  void _internal_set_str(uint32_t value);
  public:

  // uint32 dex = 8;
  void clear_dex();
  uint32_t dex() const;
  void set_dex(uint32_t value);
  private:
  uint32_t _internal_dex() const;
  void _internal_set_dex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPlayerCreatePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t index_;
    uint32_t job_;
    uint32_t shape_;
    uint32_t con_;
    uint32_t int__;
    uint32_t str_;
    uint32_t dex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPlayerChangeNamePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPlayerChangeNamePacket) */ {
 public:
  inline CGPlayerChangeNamePacket() : CGPlayerChangeNamePacket(nullptr) {}
  ~CGPlayerChangeNamePacket() override;
  explicit PROTOBUF_CONSTEXPR CGPlayerChangeNamePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPlayerChangeNamePacket(const CGPlayerChangeNamePacket& from);
  CGPlayerChangeNamePacket(CGPlayerChangeNamePacket&& from) noexcept
    : CGPlayerChangeNamePacket() {
    *this = ::std::move(from);
  }

  inline CGPlayerChangeNamePacket& operator=(const CGPlayerChangeNamePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPlayerChangeNamePacket& operator=(CGPlayerChangeNamePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPlayerChangeNamePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPlayerChangeNamePacket* internal_default_instance() {
    return reinterpret_cast<const CGPlayerChangeNamePacket*>(
               &_CGPlayerChangeNamePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CGPlayerChangeNamePacket& a, CGPlayerChangeNamePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPlayerChangeNamePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPlayerChangeNamePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPlayerChangeNamePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPlayerChangeNamePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPlayerChangeNamePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPlayerChangeNamePacket& from) {
    CGPlayerChangeNamePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPlayerChangeNamePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPlayerChangeNamePacket";
  }
  protected:
  explicit CGPlayerChangeNamePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIndexFieldNumber = 1,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPlayerChangeNamePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPlayerHairSelectPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPlayerHairSelectPacket) */ {
 public:
  inline CGPlayerHairSelectPacket() : CGPlayerHairSelectPacket(nullptr) {}
  ~CGPlayerHairSelectPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPlayerHairSelectPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPlayerHairSelectPacket(const CGPlayerHairSelectPacket& from);
  CGPlayerHairSelectPacket(CGPlayerHairSelectPacket&& from) noexcept
    : CGPlayerHairSelectPacket() {
    *this = ::std::move(from);
  }

  inline CGPlayerHairSelectPacket& operator=(const CGPlayerHairSelectPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPlayerHairSelectPacket& operator=(CGPlayerHairSelectPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPlayerHairSelectPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPlayerHairSelectPacket* internal_default_instance() {
    return reinterpret_cast<const CGPlayerHairSelectPacket*>(
               &_CGPlayerHairSelectPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CGPlayerHairSelectPacket& a, CGPlayerHairSelectPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPlayerHairSelectPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPlayerHairSelectPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPlayerHairSelectPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPlayerHairSelectPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPlayerHairSelectPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPlayerHairSelectPacket& from) {
    CGPlayerHairSelectPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPlayerHairSelectPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPlayerHairSelectPacket";
  }
  protected:
  explicit CGPlayerHairSelectPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kHairVnumFieldNumber = 2,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // uint32 hair_vnum = 2;
  void clear_hair_vnum();
  uint32_t hair_vnum() const;
  void set_hair_vnum(uint32_t value);
  private:
  uint32_t _internal_hair_vnum() const;
  void _internal_set_hair_vnum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPlayerHairSelectPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    uint32_t hair_vnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPlayerDeletePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPlayerDeletePacket) */ {
 public:
  inline CGPlayerDeletePacket() : CGPlayerDeletePacket(nullptr) {}
  ~CGPlayerDeletePacket() override;
  explicit PROTOBUF_CONSTEXPR CGPlayerDeletePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPlayerDeletePacket(const CGPlayerDeletePacket& from);
  CGPlayerDeletePacket(CGPlayerDeletePacket&& from) noexcept
    : CGPlayerDeletePacket() {
    *this = ::std::move(from);
  }

  inline CGPlayerDeletePacket& operator=(const CGPlayerDeletePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPlayerDeletePacket& operator=(CGPlayerDeletePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPlayerDeletePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPlayerDeletePacket* internal_default_instance() {
    return reinterpret_cast<const CGPlayerDeletePacket*>(
               &_CGPlayerDeletePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CGPlayerDeletePacket& a, CGPlayerDeletePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPlayerDeletePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPlayerDeletePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPlayerDeletePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPlayerDeletePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPlayerDeletePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPlayerDeletePacket& from) {
    CGPlayerDeletePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPlayerDeletePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPlayerDeletePacket";
  }
  protected:
  explicit CGPlayerDeletePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivateCodeFieldNumber = 2,
    kIndexFieldNumber = 1,
  };
  // bytes private_code = 2;
  void clear_private_code();
  const std::string& private_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_code();
  PROTOBUF_NODISCARD std::string* release_private_code();
  void set_allocated_private_code(std::string* private_code);
  private:
  const std::string& _internal_private_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_code(const std::string& value);
  std::string* _internal_mutable_private_code();
  public:

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPlayerDeletePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_code_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMarkCRCListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMarkCRCListPacket) */ {
 public:
  inline CGMarkCRCListPacket() : CGMarkCRCListPacket(nullptr) {}
  ~CGMarkCRCListPacket() override;
  explicit PROTOBUF_CONSTEXPR CGMarkCRCListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMarkCRCListPacket(const CGMarkCRCListPacket& from);
  CGMarkCRCListPacket(CGMarkCRCListPacket&& from) noexcept
    : CGMarkCRCListPacket() {
    *this = ::std::move(from);
  }

  inline CGMarkCRCListPacket& operator=(const CGMarkCRCListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMarkCRCListPacket& operator=(CGMarkCRCListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMarkCRCListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMarkCRCListPacket* internal_default_instance() {
    return reinterpret_cast<const CGMarkCRCListPacket*>(
               &_CGMarkCRCListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CGMarkCRCListPacket& a, CGMarkCRCListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMarkCRCListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMarkCRCListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMarkCRCListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMarkCRCListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMarkCRCListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMarkCRCListPacket& from) {
    CGMarkCRCListPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMarkCRCListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMarkCRCListPacket";
  }
  protected:
  explicit CGMarkCRCListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrclistFieldNumber = 2,
    kImageIndexFieldNumber = 1,
  };
  // repeated uint32 crclist = 2;
  int crclist_size() const;
  private:
  int _internal_crclist_size() const;
  public:
  void clear_crclist();
  private:
  uint32_t _internal_crclist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_crclist() const;
  void _internal_add_crclist(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_crclist();
  public:
  uint32_t crclist(int index) const;
  void set_crclist(int index, uint32_t value);
  void add_crclist(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      crclist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_crclist();

  // uint32 image_index = 1;
  void clear_image_index();
  uint32_t image_index() const;
  void set_image_index(uint32_t value);
  private:
  uint32_t _internal_image_index() const;
  void _internal_set_image_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGMarkCRCListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > crclist_;
    mutable std::atomic<int> _crclist_cached_byte_size_;
    uint32_t image_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMarkUploadPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMarkUploadPacket) */ {
 public:
  inline CGMarkUploadPacket() : CGMarkUploadPacket(nullptr) {}
  ~CGMarkUploadPacket() override;
  explicit PROTOBUF_CONSTEXPR CGMarkUploadPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMarkUploadPacket(const CGMarkUploadPacket& from);
  CGMarkUploadPacket(CGMarkUploadPacket&& from) noexcept
    : CGMarkUploadPacket() {
    *this = ::std::move(from);
  }

  inline CGMarkUploadPacket& operator=(const CGMarkUploadPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMarkUploadPacket& operator=(CGMarkUploadPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMarkUploadPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMarkUploadPacket* internal_default_instance() {
    return reinterpret_cast<const CGMarkUploadPacket*>(
               &_CGMarkUploadPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CGMarkUploadPacket& a, CGMarkUploadPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMarkUploadPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMarkUploadPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMarkUploadPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMarkUploadPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMarkUploadPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMarkUploadPacket& from) {
    CGMarkUploadPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMarkUploadPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMarkUploadPacket";
  }
  protected:
  explicit CGMarkUploadPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 2,
    kGuildIdFieldNumber = 1,
  };
  // bytes image = 2;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // uint32 guild_id = 1;
  void clear_guild_id();
  uint32_t guild_id() const;
  void set_guild_id(uint32_t value);
  private:
  uint32_t _internal_guild_id() const;
  void _internal_set_guild_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGMarkUploadPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    uint32_t guild_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildSymbolUploadPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildSymbolUploadPacket) */ {
 public:
  inline CGGuildSymbolUploadPacket() : CGGuildSymbolUploadPacket(nullptr) {}
  ~CGGuildSymbolUploadPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildSymbolUploadPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildSymbolUploadPacket(const CGGuildSymbolUploadPacket& from);
  CGGuildSymbolUploadPacket(CGGuildSymbolUploadPacket&& from) noexcept
    : CGGuildSymbolUploadPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildSymbolUploadPacket& operator=(const CGGuildSymbolUploadPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildSymbolUploadPacket& operator=(CGGuildSymbolUploadPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildSymbolUploadPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildSymbolUploadPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildSymbolUploadPacket*>(
               &_CGGuildSymbolUploadPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CGGuildSymbolUploadPacket& a, CGGuildSymbolUploadPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildSymbolUploadPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildSymbolUploadPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildSymbolUploadPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildSymbolUploadPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildSymbolUploadPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildSymbolUploadPacket& from) {
    CGGuildSymbolUploadPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildSymbolUploadPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildSymbolUploadPacket";
  }
  protected:
  explicit CGGuildSymbolUploadPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 2,
    kGuildIdFieldNumber = 1,
  };
  // bytes image = 2;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // uint32 guild_id = 1;
  void clear_guild_id();
  uint32_t guild_id() const;
  void set_guild_id(uint32_t value);
  private:
  uint32_t _internal_guild_id() const;
  void _internal_set_guild_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildSymbolUploadPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    uint32_t guild_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildSymbolCRCPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildSymbolCRCPacket) */ {
 public:
  inline CGGuildSymbolCRCPacket() : CGGuildSymbolCRCPacket(nullptr) {}
  ~CGGuildSymbolCRCPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildSymbolCRCPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildSymbolCRCPacket(const CGGuildSymbolCRCPacket& from);
  CGGuildSymbolCRCPacket(CGGuildSymbolCRCPacket&& from) noexcept
    : CGGuildSymbolCRCPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildSymbolCRCPacket& operator=(const CGGuildSymbolCRCPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildSymbolCRCPacket& operator=(CGGuildSymbolCRCPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildSymbolCRCPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildSymbolCRCPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildSymbolCRCPacket*>(
               &_CGGuildSymbolCRCPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CGGuildSymbolCRCPacket& a, CGGuildSymbolCRCPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildSymbolCRCPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildSymbolCRCPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildSymbolCRCPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildSymbolCRCPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildSymbolCRCPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildSymbolCRCPacket& from) {
    CGGuildSymbolCRCPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildSymbolCRCPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildSymbolCRCPacket";
  }
  protected:
  explicit CGGuildSymbolCRCPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuildIdFieldNumber = 1,
    kCrcFieldNumber = 2,
    kSymbolSizeFieldNumber = 3,
  };
  // uint32 guild_id = 1;
  void clear_guild_id();
  uint32_t guild_id() const;
  void set_guild_id(uint32_t value);
  private:
  uint32_t _internal_guild_id() const;
  void _internal_set_guild_id(uint32_t value);
  public:

  // uint32 crc = 2;
  void clear_crc();
  uint32_t crc() const;
  void set_crc(uint32_t value);
  private:
  uint32_t _internal_crc() const;
  void _internal_set_crc(uint32_t value);
  public:

  // uint32 symbol_size = 3;
  void clear_symbol_size();
  uint32_t symbol_size() const;
  void set_symbol_size(uint32_t value);
  private:
  uint32_t _internal_symbol_size() const;
  void _internal_set_symbol_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildSymbolCRCPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t guild_id_;
    uint32_t crc_;
    uint32_t symbol_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGClientVersionPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGClientVersionPacket) */ {
 public:
  inline CGClientVersionPacket() : CGClientVersionPacket(nullptr) {}
  ~CGClientVersionPacket() override;
  explicit PROTOBUF_CONSTEXPR CGClientVersionPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGClientVersionPacket(const CGClientVersionPacket& from);
  CGClientVersionPacket(CGClientVersionPacket&& from) noexcept
    : CGClientVersionPacket() {
    *this = ::std::move(from);
  }

  inline CGClientVersionPacket& operator=(const CGClientVersionPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGClientVersionPacket& operator=(CGClientVersionPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGClientVersionPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGClientVersionPacket* internal_default_instance() {
    return reinterpret_cast<const CGClientVersionPacket*>(
               &_CGClientVersionPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CGClientVersionPacket& a, CGClientVersionPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGClientVersionPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGClientVersionPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGClientVersionPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGClientVersionPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGClientVersionPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGClientVersionPacket& from) {
    CGClientVersionPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGClientVersionPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGClientVersionPacket";
  }
  protected:
  explicit CGClientVersionPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // bytes filename = 1;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // bytes timestamp = 2;
  void clear_timestamp();
  const std::string& timestamp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timestamp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* timestamp);
  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(const std::string& value);
  std::string* _internal_mutable_timestamp();
  public:

  // @@protoc_insertion_point(class_scope:network.CGClientVersionPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGLoginVersionCheckPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGLoginVersionCheckPacket) */ {
 public:
  inline CGLoginVersionCheckPacket() : CGLoginVersionCheckPacket(nullptr) {}
  ~CGLoginVersionCheckPacket() override;
  explicit PROTOBUF_CONSTEXPR CGLoginVersionCheckPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGLoginVersionCheckPacket(const CGLoginVersionCheckPacket& from);
  CGLoginVersionCheckPacket(CGLoginVersionCheckPacket&& from) noexcept
    : CGLoginVersionCheckPacket() {
    *this = ::std::move(from);
  }

  inline CGLoginVersionCheckPacket& operator=(const CGLoginVersionCheckPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGLoginVersionCheckPacket& operator=(CGLoginVersionCheckPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGLoginVersionCheckPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGLoginVersionCheckPacket* internal_default_instance() {
    return reinterpret_cast<const CGLoginVersionCheckPacket*>(
               &_CGLoginVersionCheckPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CGLoginVersionCheckPacket& a, CGLoginVersionCheckPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGLoginVersionCheckPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGLoginVersionCheckPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGLoginVersionCheckPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGLoginVersionCheckPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGLoginVersionCheckPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGLoginVersionCheckPacket& from) {
    CGLoginVersionCheckPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGLoginVersionCheckPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGLoginVersionCheckPacket";
  }
  protected:
  explicit CGLoginVersionCheckPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // bytes version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:network.CGLoginVersionCheckPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGXTRAPAckPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGXTRAPAckPacket) */ {
 public:
  inline CGXTRAPAckPacket() : CGXTRAPAckPacket(nullptr) {}
  ~CGXTRAPAckPacket() override;
  explicit PROTOBUF_CONSTEXPR CGXTRAPAckPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGXTRAPAckPacket(const CGXTRAPAckPacket& from);
  CGXTRAPAckPacket(CGXTRAPAckPacket&& from) noexcept
    : CGXTRAPAckPacket() {
    *this = ::std::move(from);
  }

  inline CGXTRAPAckPacket& operator=(const CGXTRAPAckPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGXTRAPAckPacket& operator=(CGXTRAPAckPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGXTRAPAckPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGXTRAPAckPacket* internal_default_instance() {
    return reinterpret_cast<const CGXTRAPAckPacket*>(
               &_CGXTRAPAckPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CGXTRAPAckPacket& a, CGXTRAPAckPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGXTRAPAckPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGXTRAPAckPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGXTRAPAckPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGXTRAPAckPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGXTRAPAckPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGXTRAPAckPacket& from) {
    CGXTRAPAckPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGXTRAPAckPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGXTRAPAckPacket";
  }
  protected:
  explicit CGXTRAPAckPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketDataFieldNumber = 1,
  };
  // bytes packet_data = 1;
  void clear_packet_data();
  const std::string& packet_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_packet_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_packet_data();
  PROTOBUF_NODISCARD std::string* release_packet_data();
  void set_allocated_packet_data(std::string* packet_data);
  private:
  const std::string& _internal_packet_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_data(const std::string& value);
  std::string* _internal_mutable_packet_data();
  public:

  // @@protoc_insertion_point(class_scope:network.CGXTRAPAckPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packet_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGHackPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGHackPacket) */ {
 public:
  inline CGHackPacket() : CGHackPacket(nullptr) {}
  ~CGHackPacket() override;
  explicit PROTOBUF_CONSTEXPR CGHackPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGHackPacket(const CGHackPacket& from);
  CGHackPacket(CGHackPacket&& from) noexcept
    : CGHackPacket() {
    *this = ::std::move(from);
  }

  inline CGHackPacket& operator=(const CGHackPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGHackPacket& operator=(CGHackPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGHackPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGHackPacket* internal_default_instance() {
    return reinterpret_cast<const CGHackPacket*>(
               &_CGHackPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CGHackPacket& a, CGHackPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGHackPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGHackPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGHackPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGHackPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGHackPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGHackPacket& from) {
    CGHackPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGHackPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGHackPacket";
  }
  protected:
  explicit CGHackPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufFieldNumber = 1,
  };
  // bytes buf = 1;
  void clear_buf();
  const std::string& buf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buf();
  PROTOBUF_NODISCARD std::string* release_buf();
  void set_allocated_buf(std::string* buf);
  private:
  const std::string& _internal_buf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buf(const std::string& value);
  std::string* _internal_mutable_buf();
  public:

  // @@protoc_insertion_point(class_scope:network.CGHackPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buf_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGCostumeVisibilityPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGCostumeVisibilityPacket) */ {
 public:
  inline CGCostumeVisibilityPacket() : CGCostumeVisibilityPacket(nullptr) {}
  ~CGCostumeVisibilityPacket() override;
  explicit PROTOBUF_CONSTEXPR CGCostumeVisibilityPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGCostumeVisibilityPacket(const CGCostumeVisibilityPacket& from);
  CGCostumeVisibilityPacket(CGCostumeVisibilityPacket&& from) noexcept
    : CGCostumeVisibilityPacket() {
    *this = ::std::move(from);
  }

  inline CGCostumeVisibilityPacket& operator=(const CGCostumeVisibilityPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGCostumeVisibilityPacket& operator=(CGCostumeVisibilityPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGCostumeVisibilityPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGCostumeVisibilityPacket* internal_default_instance() {
    return reinterpret_cast<const CGCostumeVisibilityPacket*>(
               &_CGCostumeVisibilityPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CGCostumeVisibilityPacket& a, CGCostumeVisibilityPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGCostumeVisibilityPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGCostumeVisibilityPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGCostumeVisibilityPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGCostumeVisibilityPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGCostumeVisibilityPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGCostumeVisibilityPacket& from) {
    CGCostumeVisibilityPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGCostumeVisibilityPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGCostumeVisibilityPacket";
  }
  protected:
  explicit CGCostumeVisibilityPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kVisibleFieldNumber = 2,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // bool visible = 2;
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGCostumeVisibilityPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    bool visible_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGChatPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGChatPacket) */ {
 public:
  inline CGChatPacket() : CGChatPacket(nullptr) {}
  ~CGChatPacket() override;
  explicit PROTOBUF_CONSTEXPR CGChatPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGChatPacket(const CGChatPacket& from);
  CGChatPacket(CGChatPacket&& from) noexcept
    : CGChatPacket() {
    *this = ::std::move(from);
  }

  inline CGChatPacket& operator=(const CGChatPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGChatPacket& operator=(CGChatPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGChatPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGChatPacket* internal_default_instance() {
    return reinterpret_cast<const CGChatPacket*>(
               &_CGChatPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CGChatPacket& a, CGChatPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGChatPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGChatPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGChatPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGChatPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGChatPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGChatPacket& from) {
    CGChatPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGChatPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGChatPacket";
  }
  protected:
  explicit CGChatPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGChatPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAttackPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAttackPacket) */ {
 public:
  inline CGAttackPacket() : CGAttackPacket(nullptr) {}
  ~CGAttackPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAttackPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAttackPacket(const CGAttackPacket& from);
  CGAttackPacket(CGAttackPacket&& from) noexcept
    : CGAttackPacket() {
    *this = ::std::move(from);
  }

  inline CGAttackPacket& operator=(const CGAttackPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAttackPacket& operator=(CGAttackPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAttackPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAttackPacket* internal_default_instance() {
    return reinterpret_cast<const CGAttackPacket*>(
               &_CGAttackPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CGAttackPacket& a, CGAttackPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAttackPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAttackPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAttackPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAttackPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAttackPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAttackPacket& from) {
    CGAttackPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAttackPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAttackPacket";
  }
  protected:
  explicit CGAttackPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kVidFieldNumber = 2,
    kCrcMagicCubeProcPieceFieldNumber = 3,
    kCrcMagicCubeFilePieceFieldNumber = 4,
    kRandomFieldNumber = 5,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 vid = 2;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // uint32 crc_magic_cube_proc_piece = 3;
  void clear_crc_magic_cube_proc_piece();
  uint32_t crc_magic_cube_proc_piece() const;
  void set_crc_magic_cube_proc_piece(uint32_t value);
  private:
  uint32_t _internal_crc_magic_cube_proc_piece() const;
  void _internal_set_crc_magic_cube_proc_piece(uint32_t value);
  public:

  // uint32 crc_magic_cube_file_piece = 4;
  void clear_crc_magic_cube_file_piece();
  uint32_t crc_magic_cube_file_piece() const;
  void set_crc_magic_cube_file_piece(uint32_t value);
  private:
  uint32_t _internal_crc_magic_cube_file_piece() const;
  void _internal_set_crc_magic_cube_file_piece(uint32_t value);
  public:

  // uint32 random = 5;
  void clear_random();
  uint32_t random() const;
  void set_random(uint32_t value);
  private:
  uint32_t _internal_random() const;
  void _internal_set_random(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAttackPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    uint32_t vid_;
    uint32_t crc_magic_cube_proc_piece_;
    uint32_t crc_magic_cube_file_piece_;
    uint32_t random_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGShootPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGShootPacket) */ {
 public:
  inline CGShootPacket() : CGShootPacket(nullptr) {}
  ~CGShootPacket() override;
  explicit PROTOBUF_CONSTEXPR CGShootPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGShootPacket(const CGShootPacket& from);
  CGShootPacket(CGShootPacket&& from) noexcept
    : CGShootPacket() {
    *this = ::std::move(from);
  }

  inline CGShootPacket& operator=(const CGShootPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGShootPacket& operator=(CGShootPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGShootPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGShootPacket* internal_default_instance() {
    return reinterpret_cast<const CGShootPacket*>(
               &_CGShootPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CGShootPacket& a, CGShootPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGShootPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGShootPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGShootPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGShootPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGShootPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGShootPacket& from) {
    CGShootPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGShootPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGShootPacket";
  }
  protected:
  explicit CGShootPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGShootPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGWhisperPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGWhisperPacket) */ {
 public:
  inline CGWhisperPacket() : CGWhisperPacket(nullptr) {}
  ~CGWhisperPacket() override;
  explicit PROTOBUF_CONSTEXPR CGWhisperPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGWhisperPacket(const CGWhisperPacket& from);
  CGWhisperPacket(CGWhisperPacket&& from) noexcept
    : CGWhisperPacket() {
    *this = ::std::move(from);
  }

  inline CGWhisperPacket& operator=(const CGWhisperPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGWhisperPacket& operator=(CGWhisperPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGWhisperPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGWhisperPacket* internal_default_instance() {
    return reinterpret_cast<const CGWhisperPacket*>(
               &_CGWhisperPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CGWhisperPacket& a, CGWhisperPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGWhisperPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGWhisperPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGWhisperPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGWhisperPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGWhisperPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGWhisperPacket& from) {
    CGWhisperPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGWhisperPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGWhisperPacket";
  }
  protected:
  explicit CGWhisperPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameToFieldNumber = 1,
    kMessageFieldNumber = 2,
    kSendOfflineFieldNumber = 3,
  };
  // bytes name_to = 1;
  void clear_name_to();
  const std::string& name_to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name_to();
  PROTOBUF_NODISCARD std::string* release_name_to();
  void set_allocated_name_to(std::string* name_to);
  private:
  const std::string& _internal_name_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_to(const std::string& value);
  std::string* _internal_mutable_name_to();
  public:

  // bytes message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool send_offline = 3;
  void clear_send_offline();
  bool send_offline() const;
  void set_send_offline(bool value);
  private:
  bool _internal_send_offline() const;
  void _internal_set_send_offline(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGWhisperPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_to_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool send_offline_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGOnClickPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGOnClickPacket) */ {
 public:
  inline CGOnClickPacket() : CGOnClickPacket(nullptr) {}
  ~CGOnClickPacket() override;
  explicit PROTOBUF_CONSTEXPR CGOnClickPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGOnClickPacket(const CGOnClickPacket& from);
  CGOnClickPacket(CGOnClickPacket&& from) noexcept
    : CGOnClickPacket() {
    *this = ::std::move(from);
  }

  inline CGOnClickPacket& operator=(const CGOnClickPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGOnClickPacket& operator=(CGOnClickPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGOnClickPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGOnClickPacket* internal_default_instance() {
    return reinterpret_cast<const CGOnClickPacket*>(
               &_CGOnClickPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CGOnClickPacket& a, CGOnClickPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGOnClickPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGOnClickPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGOnClickPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGOnClickPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGOnClickPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGOnClickPacket& from) {
    CGOnClickPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGOnClickPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGOnClickPacket";
  }
  protected:
  explicit CGOnClickPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVidFieldNumber = 1,
  };
  // uint32 vid = 1;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGOnClickPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPositionPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPositionPacket) */ {
 public:
  inline CGPositionPacket() : CGPositionPacket(nullptr) {}
  ~CGPositionPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPositionPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPositionPacket(const CGPositionPacket& from);
  CGPositionPacket(CGPositionPacket&& from) noexcept
    : CGPositionPacket() {
    *this = ::std::move(from);
  }

  inline CGPositionPacket& operator=(const CGPositionPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPositionPacket& operator=(CGPositionPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPositionPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPositionPacket* internal_default_instance() {
    return reinterpret_cast<const CGPositionPacket*>(
               &_CGPositionPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CGPositionPacket& a, CGPositionPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPositionPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPositionPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPositionPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPositionPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPositionPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPositionPacket& from) {
    CGPositionPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPositionPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPositionPacket";
  }
  protected:
  explicit CGPositionPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
  };
  // uint32 position = 1;
  void clear_position();
  uint32_t position() const;
  void set_position(uint32_t value);
  private:
  uint32_t _internal_position() const;
  void _internal_set_position(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPositionPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGNextSkillUsePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGNextSkillUsePacket) */ {
 public:
  inline CGNextSkillUsePacket() : CGNextSkillUsePacket(nullptr) {}
  ~CGNextSkillUsePacket() override;
  explicit PROTOBUF_CONSTEXPR CGNextSkillUsePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGNextSkillUsePacket(const CGNextSkillUsePacket& from);
  CGNextSkillUsePacket(CGNextSkillUsePacket&& from) noexcept
    : CGNextSkillUsePacket() {
    *this = ::std::move(from);
  }

  inline CGNextSkillUsePacket& operator=(const CGNextSkillUsePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGNextSkillUsePacket& operator=(CGNextSkillUsePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGNextSkillUsePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGNextSkillUsePacket* internal_default_instance() {
    return reinterpret_cast<const CGNextSkillUsePacket*>(
               &_CGNextSkillUsePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CGNextSkillUsePacket& a, CGNextSkillUsePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGNextSkillUsePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGNextSkillUsePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGNextSkillUsePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGNextSkillUsePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGNextSkillUsePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGNextSkillUsePacket& from) {
    CGNextSkillUsePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGNextSkillUsePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGNextSkillUsePacket";
  }
  protected:
  explicit CGNextSkillUsePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillVnumFieldNumber = 1,
  };
  // uint32 skill_vnum = 1;
  void clear_skill_vnum();
  uint32_t skill_vnum() const;
  void set_skill_vnum(uint32_t value);
  private:
  uint32_t _internal_skill_vnum() const;
  void _internal_set_skill_vnum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGNextSkillUsePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t skill_vnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMovePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMovePacket) */ {
 public:
  inline CGMovePacket() : CGMovePacket(nullptr) {}
  ~CGMovePacket() override;
  explicit PROTOBUF_CONSTEXPR CGMovePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMovePacket(const CGMovePacket& from);
  CGMovePacket(CGMovePacket&& from) noexcept
    : CGMovePacket() {
    *this = ::std::move(from);
  }

  inline CGMovePacket& operator=(const CGMovePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMovePacket& operator=(CGMovePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMovePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMovePacket* internal_default_instance() {
    return reinterpret_cast<const CGMovePacket*>(
               &_CGMovePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CGMovePacket& a, CGMovePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMovePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMovePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMovePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMovePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMovePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMovePacket& from) {
    CGMovePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMovePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMovePacket";
  }
  protected:
  explicit CGMovePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncFieldNumber = 1,
    kArgFieldNumber = 2,
    kRotFieldNumber = 3,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
    kTimeFieldNumber = 6,
  };
  // uint32 func = 1;
  void clear_func();
  uint32_t func() const;
  void set_func(uint32_t value);
  private:
  uint32_t _internal_func() const;
  void _internal_set_func(uint32_t value);
  public:

  // uint32 arg = 2;
  void clear_arg();
  uint32_t arg() const;
  void set_arg(uint32_t value);
  private:
  uint32_t _internal_arg() const;
  void _internal_set_arg(uint32_t value);
  public:

  // uint32 rot = 3;
  void clear_rot();
  uint32_t rot() const;
  void set_rot(uint32_t value);
  private:
  uint32_t _internal_rot() const;
  void _internal_set_rot(uint32_t value);
  public:

  // uint32 x = 4;
  void clear_x();
  uint32_t x() const;
  void set_x(uint32_t value);
  private:
  uint32_t _internal_x() const;
  void _internal_set_x(uint32_t value);
  public:

  // uint32 y = 5;
  void clear_y();
  uint32_t y() const;
  void set_y(uint32_t value);
  private:
  uint32_t _internal_y() const;
  void _internal_set_y(uint32_t value);
  public:

  // uint32 time = 6;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGMovePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t func_;
    uint32_t arg_;
    uint32_t rot_;
    uint32_t x_;
    uint32_t y_;
    uint32_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGSyncPositionPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGSyncPositionPacket) */ {
 public:
  inline CGSyncPositionPacket() : CGSyncPositionPacket(nullptr) {}
  ~CGSyncPositionPacket() override;
  explicit PROTOBUF_CONSTEXPR CGSyncPositionPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGSyncPositionPacket(const CGSyncPositionPacket& from);
  CGSyncPositionPacket(CGSyncPositionPacket&& from) noexcept
    : CGSyncPositionPacket() {
    *this = ::std::move(from);
  }

  inline CGSyncPositionPacket& operator=(const CGSyncPositionPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGSyncPositionPacket& operator=(CGSyncPositionPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGSyncPositionPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGSyncPositionPacket* internal_default_instance() {
    return reinterpret_cast<const CGSyncPositionPacket*>(
               &_CGSyncPositionPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CGSyncPositionPacket& a, CGSyncPositionPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGSyncPositionPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGSyncPositionPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGSyncPositionPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGSyncPositionPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGSyncPositionPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGSyncPositionPacket& from) {
    CGSyncPositionPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGSyncPositionPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGSyncPositionPacket";
  }
  protected:
  explicit CGSyncPositionPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 1,
  };
  // repeated .network.SyncPositionElement elements = 1;
  int elements_size() const;
  private:
  int _internal_elements_size() const;
  public:
  void clear_elements();
  ::network::SyncPositionElement* mutable_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::SyncPositionElement >*
      mutable_elements();
  private:
  const ::network::SyncPositionElement& _internal_elements(int index) const;
  ::network::SyncPositionElement* _internal_add_elements();
  public:
  const ::network::SyncPositionElement& elements(int index) const;
  ::network::SyncPositionElement* add_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::SyncPositionElement >&
      elements() const;

  // @@protoc_insertion_point(class_scope:network.CGSyncPositionPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::SyncPositionElement > elements_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGFlyTargetPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGFlyTargetPacket) */ {
 public:
  inline CGFlyTargetPacket() : CGFlyTargetPacket(nullptr) {}
  ~CGFlyTargetPacket() override;
  explicit PROTOBUF_CONSTEXPR CGFlyTargetPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGFlyTargetPacket(const CGFlyTargetPacket& from);
  CGFlyTargetPacket(CGFlyTargetPacket&& from) noexcept
    : CGFlyTargetPacket() {
    *this = ::std::move(from);
  }

  inline CGFlyTargetPacket& operator=(const CGFlyTargetPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGFlyTargetPacket& operator=(CGFlyTargetPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGFlyTargetPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGFlyTargetPacket* internal_default_instance() {
    return reinterpret_cast<const CGFlyTargetPacket*>(
               &_CGFlyTargetPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CGFlyTargetPacket& a, CGFlyTargetPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGFlyTargetPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGFlyTargetPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGFlyTargetPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGFlyTargetPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGFlyTargetPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGFlyTargetPacket& from) {
    CGFlyTargetPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGFlyTargetPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGFlyTargetPacket";
  }
  protected:
  explicit CGFlyTargetPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetVidFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // uint32 target_vid = 1;
  void clear_target_vid();
  uint32_t target_vid() const;
  void set_target_vid(uint32_t value);
  private:
  uint32_t _internal_target_vid() const;
  void _internal_set_target_vid(uint32_t value);
  public:

  // uint32 x = 2;
  void clear_x();
  uint32_t x() const;
  void set_x(uint32_t value);
  private:
  uint32_t _internal_x() const;
  void _internal_set_x(uint32_t value);
  public:

  // uint32 y = 3;
  void clear_y();
  uint32_t y() const;
  void set_y(uint32_t value);
  private:
  uint32_t _internal_y() const;
  void _internal_set_y(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGFlyTargetPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t target_vid_;
    uint32_t x_;
    uint32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAddFlyTargetPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAddFlyTargetPacket) */ {
 public:
  inline CGAddFlyTargetPacket() : CGAddFlyTargetPacket(nullptr) {}
  ~CGAddFlyTargetPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAddFlyTargetPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAddFlyTargetPacket(const CGAddFlyTargetPacket& from);
  CGAddFlyTargetPacket(CGAddFlyTargetPacket&& from) noexcept
    : CGAddFlyTargetPacket() {
    *this = ::std::move(from);
  }

  inline CGAddFlyTargetPacket& operator=(const CGAddFlyTargetPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAddFlyTargetPacket& operator=(CGAddFlyTargetPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAddFlyTargetPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAddFlyTargetPacket* internal_default_instance() {
    return reinterpret_cast<const CGAddFlyTargetPacket*>(
               &_CGAddFlyTargetPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CGAddFlyTargetPacket& a, CGAddFlyTargetPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAddFlyTargetPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAddFlyTargetPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAddFlyTargetPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAddFlyTargetPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAddFlyTargetPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAddFlyTargetPacket& from) {
    CGAddFlyTargetPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAddFlyTargetPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAddFlyTargetPacket";
  }
  protected:
  explicit CGAddFlyTargetPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetVidFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // uint32 target_vid = 1;
  void clear_target_vid();
  uint32_t target_vid() const;
  void set_target_vid(uint32_t value);
  private:
  uint32_t _internal_target_vid() const;
  void _internal_set_target_vid(uint32_t value);
  public:

  // uint32 x = 2;
  void clear_x();
  uint32_t x() const;
  void set_x(uint32_t value);
  private:
  uint32_t _internal_x() const;
  void _internal_set_x(uint32_t value);
  public:

  // uint32 y = 3;
  void clear_y();
  uint32_t y() const;
  void set_y(uint32_t value);
  private:
  uint32_t _internal_y() const;
  void _internal_set_y(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAddFlyTargetPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t target_vid_;
    uint32_t x_;
    uint32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGUseSkillPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGUseSkillPacket) */ {
 public:
  inline CGUseSkillPacket() : CGUseSkillPacket(nullptr) {}
  ~CGUseSkillPacket() override;
  explicit PROTOBUF_CONSTEXPR CGUseSkillPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGUseSkillPacket(const CGUseSkillPacket& from);
  CGUseSkillPacket(CGUseSkillPacket&& from) noexcept
    : CGUseSkillPacket() {
    *this = ::std::move(from);
  }

  inline CGUseSkillPacket& operator=(const CGUseSkillPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGUseSkillPacket& operator=(CGUseSkillPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGUseSkillPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGUseSkillPacket* internal_default_instance() {
    return reinterpret_cast<const CGUseSkillPacket*>(
               &_CGUseSkillPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CGUseSkillPacket& a, CGUseSkillPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGUseSkillPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGUseSkillPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGUseSkillPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGUseSkillPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGUseSkillPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGUseSkillPacket& from) {
    CGUseSkillPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGUseSkillPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGUseSkillPacket";
  }
  protected:
  explicit CGUseSkillPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVnumFieldNumber = 1,
    kVidFieldNumber = 2,
  };
  // uint32 vnum = 1;
  void clear_vnum();
  uint32_t vnum() const;
  void set_vnum(uint32_t value);
  private:
  uint32_t _internal_vnum() const;
  void _internal_set_vnum(uint32_t value);
  public:

  // uint32 vid = 2;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGUseSkillPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vnum_;
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGTargetPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGTargetPacket) */ {
 public:
  inline CGTargetPacket() : CGTargetPacket(nullptr) {}
  ~CGTargetPacket() override;
  explicit PROTOBUF_CONSTEXPR CGTargetPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGTargetPacket(const CGTargetPacket& from);
  CGTargetPacket(CGTargetPacket&& from) noexcept
    : CGTargetPacket() {
    *this = ::std::move(from);
  }

  inline CGTargetPacket& operator=(const CGTargetPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGTargetPacket& operator=(CGTargetPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGTargetPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGTargetPacket* internal_default_instance() {
    return reinterpret_cast<const CGTargetPacket*>(
               &_CGTargetPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CGTargetPacket& a, CGTargetPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGTargetPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGTargetPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGTargetPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGTargetPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGTargetPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGTargetPacket& from) {
    CGTargetPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGTargetPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGTargetPacket";
  }
  protected:
  explicit CGTargetPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVidFieldNumber = 1,
  };
  // uint32 vid = 1;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGTargetPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGTargetMonsterDropInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGTargetMonsterDropInfoPacket) */ {
 public:
  inline CGTargetMonsterDropInfoPacket() : CGTargetMonsterDropInfoPacket(nullptr) {}
  ~CGTargetMonsterDropInfoPacket() override;
  explicit PROTOBUF_CONSTEXPR CGTargetMonsterDropInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGTargetMonsterDropInfoPacket(const CGTargetMonsterDropInfoPacket& from);
  CGTargetMonsterDropInfoPacket(CGTargetMonsterDropInfoPacket&& from) noexcept
    : CGTargetMonsterDropInfoPacket() {
    *this = ::std::move(from);
  }

  inline CGTargetMonsterDropInfoPacket& operator=(const CGTargetMonsterDropInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGTargetMonsterDropInfoPacket& operator=(CGTargetMonsterDropInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGTargetMonsterDropInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGTargetMonsterDropInfoPacket* internal_default_instance() {
    return reinterpret_cast<const CGTargetMonsterDropInfoPacket*>(
               &_CGTargetMonsterDropInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CGTargetMonsterDropInfoPacket& a, CGTargetMonsterDropInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGTargetMonsterDropInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGTargetMonsterDropInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGTargetMonsterDropInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGTargetMonsterDropInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGTargetMonsterDropInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGTargetMonsterDropInfoPacket& from) {
    CGTargetMonsterDropInfoPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGTargetMonsterDropInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGTargetMonsterDropInfoPacket";
  }
  protected:
  explicit CGTargetMonsterDropInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaceNumFieldNumber = 1,
  };
  // uint32 race_num = 1;
  void clear_race_num();
  uint32_t race_num() const;
  void set_race_num(uint32_t value);
  private:
  uint32_t _internal_race_num() const;
  void _internal_set_race_num(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGTargetMonsterDropInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t race_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGFishingPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGFishingPacket) */ {
 public:
  inline CGFishingPacket() : CGFishingPacket(nullptr) {}
  ~CGFishingPacket() override;
  explicit PROTOBUF_CONSTEXPR CGFishingPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGFishingPacket(const CGFishingPacket& from);
  CGFishingPacket(CGFishingPacket&& from) noexcept
    : CGFishingPacket() {
    *this = ::std::move(from);
  }

  inline CGFishingPacket& operator=(const CGFishingPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGFishingPacket& operator=(CGFishingPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGFishingPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGFishingPacket* internal_default_instance() {
    return reinterpret_cast<const CGFishingPacket*>(
               &_CGFishingPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CGFishingPacket& a, CGFishingPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGFishingPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGFishingPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGFishingPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGFishingPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGFishingPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGFishingPacket& from) {
    CGFishingPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGFishingPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGFishingPacket";
  }
  protected:
  explicit CGFishingPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirFieldNumber = 1,
  };
  // uint32 dir = 1;
  void clear_dir();
  uint32_t dir() const;
  void set_dir(uint32_t value);
  private:
  uint32_t _internal_dir() const;
  void _internal_set_dir(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGFishingPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGiveItemPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGiveItemPacket) */ {
 public:
  inline CGGiveItemPacket() : CGGiveItemPacket(nullptr) {}
  ~CGGiveItemPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGiveItemPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGiveItemPacket(const CGGiveItemPacket& from);
  CGGiveItemPacket(CGGiveItemPacket&& from) noexcept
    : CGGiveItemPacket() {
    *this = ::std::move(from);
  }

  inline CGGiveItemPacket& operator=(const CGGiveItemPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGiveItemPacket& operator=(CGGiveItemPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGiveItemPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGiveItemPacket* internal_default_instance() {
    return reinterpret_cast<const CGGiveItemPacket*>(
               &_CGGiveItemPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CGGiveItemPacket& a, CGGiveItemPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGiveItemPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGiveItemPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGiveItemPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGiveItemPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGiveItemPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGiveItemPacket& from) {
    CGGiveItemPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGiveItemPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGiveItemPacket";
  }
  protected:
  explicit CGGiveItemPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 2,
    kTargetVidFieldNumber = 1,
    kItemCountFieldNumber = 3,
  };
  // .network.TItemPos cell = 2;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // uint32 target_vid = 1;
  void clear_target_vid();
  uint32_t target_vid() const;
  void set_target_vid(uint32_t value);
  private:
  uint32_t _internal_target_vid() const;
  void _internal_set_target_vid(uint32_t value);
  public:

  // uint32 item_count = 3;
  void clear_item_count();
  uint32_t item_count() const;
  void set_item_count(uint32_t value);
  private:
  uint32_t _internal_item_count() const;
  void _internal_set_item_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGiveItemPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    uint32_t target_vid_;
    uint32_t item_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMyShopPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMyShopPacket) */ {
 public:
  inline CGMyShopPacket() : CGMyShopPacket(nullptr) {}
  ~CGMyShopPacket() override;
  explicit PROTOBUF_CONSTEXPR CGMyShopPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMyShopPacket(const CGMyShopPacket& from);
  CGMyShopPacket(CGMyShopPacket&& from) noexcept
    : CGMyShopPacket() {
    *this = ::std::move(from);
  }

  inline CGMyShopPacket& operator=(const CGMyShopPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMyShopPacket& operator=(CGMyShopPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMyShopPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMyShopPacket* internal_default_instance() {
    return reinterpret_cast<const CGMyShopPacket*>(
               &_CGMyShopPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CGMyShopPacket& a, CGMyShopPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMyShopPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMyShopPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMyShopPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMyShopPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMyShopPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMyShopPacket& from) {
    CGMyShopPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMyShopPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMyShopPacket";
  }
  protected:
  explicit CGMyShopPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kSignFieldNumber = 1,
  };
  // repeated .network.TShopItemTable items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::network::TShopItemTable* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable >*
      mutable_items();
  private:
  const ::network::TShopItemTable& _internal_items(int index) const;
  ::network::TShopItemTable* _internal_add_items();
  public:
  const ::network::TShopItemTable& items(int index) const;
  ::network::TShopItemTable* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable >&
      items() const;

  // bytes sign = 1;
  void clear_sign();
  const std::string& sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign();
  PROTOBUF_NODISCARD std::string* release_sign();
  void set_allocated_sign(std::string* sign);
  private:
  const std::string& _internal_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign(const std::string& value);
  std::string* _internal_mutable_sign();
  public:

  // @@protoc_insertion_point(class_scope:network.CGMyShopPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGRefinePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGRefinePacket) */ {
 public:
  inline CGRefinePacket() : CGRefinePacket(nullptr) {}
  ~CGRefinePacket() override;
  explicit PROTOBUF_CONSTEXPR CGRefinePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGRefinePacket(const CGRefinePacket& from);
  CGRefinePacket(CGRefinePacket&& from) noexcept
    : CGRefinePacket() {
    *this = ::std::move(from);
  }

  inline CGRefinePacket& operator=(const CGRefinePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGRefinePacket& operator=(CGRefinePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGRefinePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGRefinePacket* internal_default_instance() {
    return reinterpret_cast<const CGRefinePacket*>(
               &_CGRefinePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CGRefinePacket& a, CGRefinePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGRefinePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGRefinePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGRefinePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGRefinePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGRefinePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGRefinePacket& from) {
    CGRefinePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGRefinePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGRefinePacket";
  }
  protected:
  explicit CGRefinePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kTypeFieldNumber = 2,
    kFastRefineFieldNumber = 3,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // uint32 type = 2;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // bool fast_refine = 3;
  void clear_fast_refine();
  bool fast_refine() const;
  void set_fast_refine(bool value);
  private:
  bool _internal_fast_refine() const;
  void _internal_set_fast_refine(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGRefinePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    uint32_t type_;
    bool fast_refine_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPlayerLanguageInformationPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPlayerLanguageInformationPacket) */ {
 public:
  inline CGPlayerLanguageInformationPacket() : CGPlayerLanguageInformationPacket(nullptr) {}
  ~CGPlayerLanguageInformationPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPlayerLanguageInformationPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPlayerLanguageInformationPacket(const CGPlayerLanguageInformationPacket& from);
  CGPlayerLanguageInformationPacket(CGPlayerLanguageInformationPacket&& from) noexcept
    : CGPlayerLanguageInformationPacket() {
    *this = ::std::move(from);
  }

  inline CGPlayerLanguageInformationPacket& operator=(const CGPlayerLanguageInformationPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPlayerLanguageInformationPacket& operator=(CGPlayerLanguageInformationPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPlayerLanguageInformationPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPlayerLanguageInformationPacket* internal_default_instance() {
    return reinterpret_cast<const CGPlayerLanguageInformationPacket*>(
               &_CGPlayerLanguageInformationPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CGPlayerLanguageInformationPacket& a, CGPlayerLanguageInformationPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPlayerLanguageInformationPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPlayerLanguageInformationPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPlayerLanguageInformationPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPlayerLanguageInformationPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPlayerLanguageInformationPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPlayerLanguageInformationPacket& from) {
    CGPlayerLanguageInformationPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPlayerLanguageInformationPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPlayerLanguageInformationPacket";
  }
  protected:
  explicit CGPlayerLanguageInformationPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 1,
  };
  // bytes player_name = 1;
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // @@protoc_insertion_point(class_scope:network.CGPlayerLanguageInformationPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGReportPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGReportPacket) */ {
 public:
  inline CGReportPacket() : CGReportPacket(nullptr) {}
  ~CGReportPacket() override;
  explicit PROTOBUF_CONSTEXPR CGReportPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGReportPacket(const CGReportPacket& from);
  CGReportPacket(CGReportPacket&& from) noexcept
    : CGReportPacket() {
    *this = ::std::move(from);
  }

  inline CGReportPacket& operator=(const CGReportPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGReportPacket& operator=(CGReportPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGReportPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGReportPacket* internal_default_instance() {
    return reinterpret_cast<const CGReportPacket*>(
               &_CGReportPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CGReportPacket& a, CGReportPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGReportPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGReportPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGReportPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGReportPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGReportPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGReportPacket& from) {
    CGReportPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGReportPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGReportPacket";
  }
  protected:
  explicit CGReportPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // uint32 key = 1;
  void clear_key();
  uint32_t key() const;
  void set_key(uint32_t value);
  private:
  uint32_t _internal_key() const;
  void _internal_set_key(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGReportPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGDragonSoulRefinePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGDragonSoulRefinePacket) */ {
 public:
  inline CGDragonSoulRefinePacket() : CGDragonSoulRefinePacket(nullptr) {}
  ~CGDragonSoulRefinePacket() override;
  explicit PROTOBUF_CONSTEXPR CGDragonSoulRefinePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGDragonSoulRefinePacket(const CGDragonSoulRefinePacket& from);
  CGDragonSoulRefinePacket(CGDragonSoulRefinePacket&& from) noexcept
    : CGDragonSoulRefinePacket() {
    *this = ::std::move(from);
  }

  inline CGDragonSoulRefinePacket& operator=(const CGDragonSoulRefinePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGDragonSoulRefinePacket& operator=(CGDragonSoulRefinePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGDragonSoulRefinePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGDragonSoulRefinePacket* internal_default_instance() {
    return reinterpret_cast<const CGDragonSoulRefinePacket*>(
               &_CGDragonSoulRefinePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CGDragonSoulRefinePacket& a, CGDragonSoulRefinePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGDragonSoulRefinePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGDragonSoulRefinePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGDragonSoulRefinePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGDragonSoulRefinePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGDragonSoulRefinePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGDragonSoulRefinePacket& from) {
    CGDragonSoulRefinePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGDragonSoulRefinePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGDragonSoulRefinePacket";
  }
  protected:
  explicit CGDragonSoulRefinePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemGridFieldNumber = 2,
    kSubTypeFieldNumber = 1,
  };
  // repeated .network.TItemPos item_grid = 2;
  int item_grid_size() const;
  private:
  int _internal_item_grid_size() const;
  public:
  void clear_item_grid();
  ::network::TItemPos* mutable_item_grid(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TItemPos >*
      mutable_item_grid();
  private:
  const ::network::TItemPos& _internal_item_grid(int index) const;
  ::network::TItemPos* _internal_add_item_grid();
  public:
  const ::network::TItemPos& item_grid(int index) const;
  ::network::TItemPos* add_item_grid();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TItemPos >&
      item_grid() const;

  // uint32 sub_type = 1;
  void clear_sub_type();
  uint32_t sub_type() const;
  void set_sub_type(uint32_t value);
  private:
  uint32_t _internal_sub_type() const;
  void _internal_set_sub_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGDragonSoulRefinePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TItemPos > item_grid_;
    uint32_t sub_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGOnQuestTriggerPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGOnQuestTriggerPacket) */ {
 public:
  inline CGOnQuestTriggerPacket() : CGOnQuestTriggerPacket(nullptr) {}
  ~CGOnQuestTriggerPacket() override;
  explicit PROTOBUF_CONSTEXPR CGOnQuestTriggerPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGOnQuestTriggerPacket(const CGOnQuestTriggerPacket& from);
  CGOnQuestTriggerPacket(CGOnQuestTriggerPacket&& from) noexcept
    : CGOnQuestTriggerPacket() {
    *this = ::std::move(from);
  }

  inline CGOnQuestTriggerPacket& operator=(const CGOnQuestTriggerPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGOnQuestTriggerPacket& operator=(CGOnQuestTriggerPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGOnQuestTriggerPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGOnQuestTriggerPacket* internal_default_instance() {
    return reinterpret_cast<const CGOnQuestTriggerPacket*>(
               &_CGOnQuestTriggerPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CGOnQuestTriggerPacket& a, CGOnQuestTriggerPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGOnQuestTriggerPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGOnQuestTriggerPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGOnQuestTriggerPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGOnQuestTriggerPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGOnQuestTriggerPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGOnQuestTriggerPacket& from) {
    CGOnQuestTriggerPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGOnQuestTriggerPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGOnQuestTriggerPacket";
  }
  protected:
  explicit CGOnQuestTriggerPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kArgFieldNumber = 2,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // int32 arg = 2;
  void clear_arg();
  int32_t arg() const;
  void set_arg(int32_t value);
  private:
  int32_t _internal_arg() const;
  void _internal_set_arg(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGOnQuestTriggerPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    int32_t arg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGItemMultiUsePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGItemMultiUsePacket) */ {
 public:
  inline CGItemMultiUsePacket() : CGItemMultiUsePacket(nullptr) {}
  ~CGItemMultiUsePacket() override;
  explicit PROTOBUF_CONSTEXPR CGItemMultiUsePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGItemMultiUsePacket(const CGItemMultiUsePacket& from);
  CGItemMultiUsePacket(CGItemMultiUsePacket&& from) noexcept
    : CGItemMultiUsePacket() {
    *this = ::std::move(from);
  }

  inline CGItemMultiUsePacket& operator=(const CGItemMultiUsePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGItemMultiUsePacket& operator=(CGItemMultiUsePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGItemMultiUsePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGItemMultiUsePacket* internal_default_instance() {
    return reinterpret_cast<const CGItemMultiUsePacket*>(
               &_CGItemMultiUsePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CGItemMultiUsePacket& a, CGItemMultiUsePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGItemMultiUsePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGItemMultiUsePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGItemMultiUsePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGItemMultiUsePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGItemMultiUsePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGItemMultiUsePacket& from) {
    CGItemMultiUsePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGItemMultiUsePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGItemMultiUsePacket";
  }
  protected:
  explicit CGItemMultiUsePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // uint32 count = 2;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGItemMultiUsePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGBotReportLogPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGBotReportLogPacket) */ {
 public:
  inline CGBotReportLogPacket() : CGBotReportLogPacket(nullptr) {}
  ~CGBotReportLogPacket() override;
  explicit PROTOBUF_CONSTEXPR CGBotReportLogPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGBotReportLogPacket(const CGBotReportLogPacket& from);
  CGBotReportLogPacket(CGBotReportLogPacket&& from) noexcept
    : CGBotReportLogPacket() {
    *this = ::std::move(from);
  }

  inline CGBotReportLogPacket& operator=(const CGBotReportLogPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGBotReportLogPacket& operator=(CGBotReportLogPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGBotReportLogPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGBotReportLogPacket* internal_default_instance() {
    return reinterpret_cast<const CGBotReportLogPacket*>(
               &_CGBotReportLogPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CGBotReportLogPacket& a, CGBotReportLogPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGBotReportLogPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGBotReportLogPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGBotReportLogPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGBotReportLogPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGBotReportLogPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGBotReportLogPacket& from) {
    CGBotReportLogPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGBotReportLogPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGBotReportLogPacket";
  }
  protected:
  explicit CGBotReportLogPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kDetailFieldNumber = 2,
  };
  // bytes type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes detail = 2;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // @@protoc_insertion_point(class_scope:network.CGBotReportLogPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGForcedRewarpPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGForcedRewarpPacket) */ {
 public:
  inline CGForcedRewarpPacket() : CGForcedRewarpPacket(nullptr) {}
  ~CGForcedRewarpPacket() override;
  explicit PROTOBUF_CONSTEXPR CGForcedRewarpPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGForcedRewarpPacket(const CGForcedRewarpPacket& from);
  CGForcedRewarpPacket(CGForcedRewarpPacket&& from) noexcept
    : CGForcedRewarpPacket() {
    *this = ::std::move(from);
  }

  inline CGForcedRewarpPacket& operator=(const CGForcedRewarpPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGForcedRewarpPacket& operator=(CGForcedRewarpPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGForcedRewarpPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGForcedRewarpPacket* internal_default_instance() {
    return reinterpret_cast<const CGForcedRewarpPacket*>(
               &_CGForcedRewarpPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CGForcedRewarpPacket& a, CGForcedRewarpPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGForcedRewarpPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGForcedRewarpPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGForcedRewarpPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGForcedRewarpPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGForcedRewarpPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGForcedRewarpPacket& from) {
    CGForcedRewarpPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGForcedRewarpPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGForcedRewarpPacket";
  }
  protected:
  explicit CGForcedRewarpPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailLogFieldNumber = 1,
    kCheckvalFieldNumber = 2,
  };
  // bytes detail_log = 1;
  void clear_detail_log();
  const std::string& detail_log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail_log();
  PROTOBUF_NODISCARD std::string* release_detail_log();
  void set_allocated_detail_log(std::string* detail_log);
  private:
  const std::string& _internal_detail_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail_log(const std::string& value);
  std::string* _internal_mutable_detail_log();
  public:

  // int32 checkval = 2;
  void clear_checkval();
  int32_t checkval() const;
  void set_checkval(int32_t value);
  private:
  int32_t _internal_checkval() const;
  void _internal_set_checkval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGForcedRewarpPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_log_;
    int32_t checkval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGUseDetachmentSinglePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGUseDetachmentSinglePacket) */ {
 public:
  inline CGUseDetachmentSinglePacket() : CGUseDetachmentSinglePacket(nullptr) {}
  ~CGUseDetachmentSinglePacket() override;
  explicit PROTOBUF_CONSTEXPR CGUseDetachmentSinglePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGUseDetachmentSinglePacket(const CGUseDetachmentSinglePacket& from);
  CGUseDetachmentSinglePacket(CGUseDetachmentSinglePacket&& from) noexcept
    : CGUseDetachmentSinglePacket() {
    *this = ::std::move(from);
  }

  inline CGUseDetachmentSinglePacket& operator=(const CGUseDetachmentSinglePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGUseDetachmentSinglePacket& operator=(CGUseDetachmentSinglePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGUseDetachmentSinglePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGUseDetachmentSinglePacket* internal_default_instance() {
    return reinterpret_cast<const CGUseDetachmentSinglePacket*>(
               &_CGUseDetachmentSinglePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CGUseDetachmentSinglePacket& a, CGUseDetachmentSinglePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGUseDetachmentSinglePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGUseDetachmentSinglePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGUseDetachmentSinglePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGUseDetachmentSinglePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGUseDetachmentSinglePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGUseDetachmentSinglePacket& from) {
    CGUseDetachmentSinglePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGUseDetachmentSinglePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGUseDetachmentSinglePacket";
  }
  protected:
  explicit CGUseDetachmentSinglePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellDetachmentFieldNumber = 1,
    kCellItemFieldNumber = 2,
    kSlotIndexFieldNumber = 3,
  };
  // uint32 cell_detachment = 1;
  void clear_cell_detachment();
  uint32_t cell_detachment() const;
  void set_cell_detachment(uint32_t value);
  private:
  uint32_t _internal_cell_detachment() const;
  void _internal_set_cell_detachment(uint32_t value);
  public:

  // uint32 cell_item = 2;
  void clear_cell_item();
  uint32_t cell_item() const;
  void set_cell_item(uint32_t value);
  private:
  uint32_t _internal_cell_item() const;
  void _internal_set_cell_item(uint32_t value);
  public:

  // uint32 slot_index = 3;
  void clear_slot_index();
  uint32_t slot_index() const;
  void set_slot_index(uint32_t value);
  private:
  uint32_t _internal_slot_index() const;
  void _internal_set_slot_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGUseDetachmentSinglePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t cell_detachment_;
    uint32_t cell_item_;
    uint32_t slot_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGEventRequestAnswerPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGEventRequestAnswerPacket) */ {
 public:
  inline CGEventRequestAnswerPacket() : CGEventRequestAnswerPacket(nullptr) {}
  ~CGEventRequestAnswerPacket() override;
  explicit PROTOBUF_CONSTEXPR CGEventRequestAnswerPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGEventRequestAnswerPacket(const CGEventRequestAnswerPacket& from);
  CGEventRequestAnswerPacket(CGEventRequestAnswerPacket&& from) noexcept
    : CGEventRequestAnswerPacket() {
    *this = ::std::move(from);
  }

  inline CGEventRequestAnswerPacket& operator=(const CGEventRequestAnswerPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGEventRequestAnswerPacket& operator=(CGEventRequestAnswerPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGEventRequestAnswerPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGEventRequestAnswerPacket* internal_default_instance() {
    return reinterpret_cast<const CGEventRequestAnswerPacket*>(
               &_CGEventRequestAnswerPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CGEventRequestAnswerPacket& a, CGEventRequestAnswerPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGEventRequestAnswerPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGEventRequestAnswerPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGEventRequestAnswerPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGEventRequestAnswerPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGEventRequestAnswerPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGEventRequestAnswerPacket& from) {
    CGEventRequestAnswerPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGEventRequestAnswerPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGEventRequestAnswerPacket";
  }
  protected:
  explicit CGEventRequestAnswerPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIndexFieldNumber = 1,
    kAcceptFieldNumber = 2,
  };
  // uint32 event_index = 1;
  void clear_event_index();
  uint32_t event_index() const;
  void set_event_index(uint32_t value);
  private:
  uint32_t _internal_event_index() const;
  void _internal_set_event_index(uint32_t value);
  public:

  // bool accept = 2;
  void clear_accept();
  bool accept() const;
  void set_accept(bool value);
  private:
  bool _internal_accept() const;
  void _internal_set_accept(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGEventRequestAnswerPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t event_index_;
    bool accept_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGCostumeBonusTransferPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGCostumeBonusTransferPacket) */ {
 public:
  inline CGCostumeBonusTransferPacket() : CGCostumeBonusTransferPacket(nullptr) {}
  ~CGCostumeBonusTransferPacket() override;
  explicit PROTOBUF_CONSTEXPR CGCostumeBonusTransferPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGCostumeBonusTransferPacket(const CGCostumeBonusTransferPacket& from);
  CGCostumeBonusTransferPacket(CGCostumeBonusTransferPacket&& from) noexcept
    : CGCostumeBonusTransferPacket() {
    *this = ::std::move(from);
  }

  inline CGCostumeBonusTransferPacket& operator=(const CGCostumeBonusTransferPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGCostumeBonusTransferPacket& operator=(CGCostumeBonusTransferPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGCostumeBonusTransferPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGCostumeBonusTransferPacket* internal_default_instance() {
    return reinterpret_cast<const CGCostumeBonusTransferPacket*>(
               &_CGCostumeBonusTransferPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CGCostumeBonusTransferPacket& a, CGCostumeBonusTransferPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGCostumeBonusTransferPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGCostumeBonusTransferPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGCostumeBonusTransferPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGCostumeBonusTransferPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGCostumeBonusTransferPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGCostumeBonusTransferPacket& from) {
    CGCostumeBonusTransferPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGCostumeBonusTransferPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGCostumeBonusTransferPacket";
  }
  protected:
  explicit CGCostumeBonusTransferPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemCellFieldNumber = 3,
    kSubHeaderFieldNumber = 1,
    kPosFieldNumber = 2,
  };
  // .network.TItemPos item_cell = 3;
  bool has_item_cell() const;
  private:
  bool _internal_has_item_cell() const;
  public:
  void clear_item_cell();
  const ::network::TItemPos& item_cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_item_cell();
  ::network::TItemPos* mutable_item_cell();
  void set_allocated_item_cell(::network::TItemPos* item_cell);
  private:
  const ::network::TItemPos& _internal_item_cell() const;
  ::network::TItemPos* _internal_mutable_item_cell();
  public:
  void unsafe_arena_set_allocated_item_cell(
      ::network::TItemPos* item_cell);
  ::network::TItemPos* unsafe_arena_release_item_cell();

  // uint32 sub_header = 1;
  void clear_sub_header();
  uint32_t sub_header() const;
  void set_sub_header(uint32_t value);
  private:
  uint32_t _internal_sub_header() const;
  void _internal_set_sub_header(uint32_t value);
  public:

  // uint32 pos = 2;
  void clear_pos();
  uint32_t pos() const;
  void set_pos(uint32_t value);
  private:
  uint32_t _internal_pos() const;
  void _internal_set_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGCostumeBonusTransferPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* item_cell_;
    uint32_t sub_header_;
    uint32_t pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGRunePagePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGRunePagePacket) */ {
 public:
  inline CGRunePagePacket() : CGRunePagePacket(nullptr) {}
  ~CGRunePagePacket() override;
  explicit PROTOBUF_CONSTEXPR CGRunePagePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGRunePagePacket(const CGRunePagePacket& from);
  CGRunePagePacket(CGRunePagePacket&& from) noexcept
    : CGRunePagePacket() {
    *this = ::std::move(from);
  }

  inline CGRunePagePacket& operator=(const CGRunePagePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGRunePagePacket& operator=(CGRunePagePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGRunePagePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGRunePagePacket* internal_default_instance() {
    return reinterpret_cast<const CGRunePagePacket*>(
               &_CGRunePagePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CGRunePagePacket& a, CGRunePagePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGRunePagePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGRunePagePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGRunePagePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGRunePagePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGRunePagePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGRunePagePacket& from) {
    CGRunePagePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGRunePagePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGRunePagePacket";
  }
  protected:
  explicit CGRunePagePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .TRunePageData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::TRunePageData& data() const;
  PROTOBUF_NODISCARD ::TRunePageData* release_data();
  ::TRunePageData* mutable_data();
  void set_allocated_data(::TRunePageData* data);
  private:
  const ::TRunePageData& _internal_data() const;
  ::TRunePageData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::TRunePageData* data);
  ::TRunePageData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:network.CGRunePagePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TRunePageData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGRecvWikiPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGRecvWikiPacket) */ {
 public:
  inline CGRecvWikiPacket() : CGRecvWikiPacket(nullptr) {}
  ~CGRecvWikiPacket() override;
  explicit PROTOBUF_CONSTEXPR CGRecvWikiPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGRecvWikiPacket(const CGRecvWikiPacket& from);
  CGRecvWikiPacket(CGRecvWikiPacket&& from) noexcept
    : CGRecvWikiPacket() {
    *this = ::std::move(from);
  }

  inline CGRecvWikiPacket& operator=(const CGRecvWikiPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGRecvWikiPacket& operator=(CGRecvWikiPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGRecvWikiPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGRecvWikiPacket* internal_default_instance() {
    return reinterpret_cast<const CGRecvWikiPacket*>(
               &_CGRecvWikiPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CGRecvWikiPacket& a, CGRecvWikiPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGRecvWikiPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGRecvWikiPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGRecvWikiPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGRecvWikiPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGRecvWikiPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGRecvWikiPacket& from) {
    CGRecvWikiPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGRecvWikiPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGRecvWikiPacket";
  }
  protected:
  explicit CGRecvWikiPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVnumFieldNumber = 1,
    kIsMobFieldNumber = 2,
    kRetIdFieldNumber = 3,
  };
  // uint32 vnum = 1;
  void clear_vnum();
  uint32_t vnum() const;
  void set_vnum(uint32_t value);
  private:
  uint32_t _internal_vnum() const;
  void _internal_set_vnum(uint32_t value);
  public:

  // bool is_mob = 2;
  void clear_is_mob();
  bool is_mob() const;
  void set_is_mob(bool value);
  private:
  bool _internal_is_mob() const;
  void _internal_set_is_mob(bool value);
  public:

  // uint64 ret_id = 3;
  void clear_ret_id();
  uint64_t ret_id() const;
  void set_ret_id(uint64_t value);
  private:
  uint64_t _internal_ret_id() const;
  void _internal_set_ret_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGRecvWikiPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vnum_;
    bool is_mob_;
    uint64_t ret_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGSetSkillColorPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGSetSkillColorPacket) */ {
 public:
  inline CGSetSkillColorPacket() : CGSetSkillColorPacket(nullptr) {}
  ~CGSetSkillColorPacket() override;
  explicit PROTOBUF_CONSTEXPR CGSetSkillColorPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGSetSkillColorPacket(const CGSetSkillColorPacket& from);
  CGSetSkillColorPacket(CGSetSkillColorPacket&& from) noexcept
    : CGSetSkillColorPacket() {
    *this = ::std::move(from);
  }

  inline CGSetSkillColorPacket& operator=(const CGSetSkillColorPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGSetSkillColorPacket& operator=(CGSetSkillColorPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGSetSkillColorPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGSetSkillColorPacket* internal_default_instance() {
    return reinterpret_cast<const CGSetSkillColorPacket*>(
               &_CGSetSkillColorPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CGSetSkillColorPacket& a, CGSetSkillColorPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGSetSkillColorPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGSetSkillColorPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGSetSkillColorPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGSetSkillColorPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGSetSkillColorPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGSetSkillColorPacket& from) {
    CGSetSkillColorPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGSetSkillColorPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGSetSkillColorPacket";
  }
  protected:
  explicit CGSetSkillColorPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillFieldNumber = 1,
    kCol1FieldNumber = 2,
    kCol2FieldNumber = 3,
    kCol3FieldNumber = 4,
    kCol4FieldNumber = 5,
    kCol5FieldNumber = 6,
  };
  // uint32 skill = 1;
  void clear_skill();
  uint32_t skill() const;
  void set_skill(uint32_t value);
  private:
  uint32_t _internal_skill() const;
  void _internal_set_skill(uint32_t value);
  public:

  // uint32 col1 = 2;
  void clear_col1();
  uint32_t col1() const;
  void set_col1(uint32_t value);
  private:
  uint32_t _internal_col1() const;
  void _internal_set_col1(uint32_t value);
  public:

  // uint32 col2 = 3;
  void clear_col2();
  uint32_t col2() const;
  void set_col2(uint32_t value);
  private:
  uint32_t _internal_col2() const;
  void _internal_set_col2(uint32_t value);
  public:

  // uint32 col3 = 4;
  void clear_col3();
  uint32_t col3() const;
  void set_col3(uint32_t value);
  private:
  uint32_t _internal_col3() const;
  void _internal_set_col3(uint32_t value);
  public:

  // uint32 col4 = 5;
  void clear_col4();
  uint32_t col4() const;
  void set_col4(uint32_t value);
  private:
  uint32_t _internal_col4() const;
  void _internal_set_col4(uint32_t value);
  public:

  // uint32 col5 = 6;
  void clear_col5();
  uint32_t col5() const;
  void set_col5(uint32_t value);
  private:
  uint32_t _internal_col5() const;
  void _internal_set_col5(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGSetSkillColorPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t skill_;
    uint32_t col1_;
    uint32_t col2_;
    uint32_t col3_;
    uint32_t col4_;
    uint32_t col5_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGEquipmentPageAddPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGEquipmentPageAddPacket) */ {
 public:
  inline CGEquipmentPageAddPacket() : CGEquipmentPageAddPacket(nullptr) {}
  ~CGEquipmentPageAddPacket() override;
  explicit PROTOBUF_CONSTEXPR CGEquipmentPageAddPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGEquipmentPageAddPacket(const CGEquipmentPageAddPacket& from);
  CGEquipmentPageAddPacket(CGEquipmentPageAddPacket&& from) noexcept
    : CGEquipmentPageAddPacket() {
    *this = ::std::move(from);
  }

  inline CGEquipmentPageAddPacket& operator=(const CGEquipmentPageAddPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGEquipmentPageAddPacket& operator=(CGEquipmentPageAddPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGEquipmentPageAddPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGEquipmentPageAddPacket* internal_default_instance() {
    return reinterpret_cast<const CGEquipmentPageAddPacket*>(
               &_CGEquipmentPageAddPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CGEquipmentPageAddPacket& a, CGEquipmentPageAddPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGEquipmentPageAddPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGEquipmentPageAddPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGEquipmentPageAddPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGEquipmentPageAddPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGEquipmentPageAddPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGEquipmentPageAddPacket& from) {
    CGEquipmentPageAddPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGEquipmentPageAddPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGEquipmentPageAddPacket";
  }
  protected:
  explicit CGEquipmentPageAddPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:network.CGEquipmentPageAddPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGEquipmentPageDeletePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGEquipmentPageDeletePacket) */ {
 public:
  inline CGEquipmentPageDeletePacket() : CGEquipmentPageDeletePacket(nullptr) {}
  ~CGEquipmentPageDeletePacket() override;
  explicit PROTOBUF_CONSTEXPR CGEquipmentPageDeletePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGEquipmentPageDeletePacket(const CGEquipmentPageDeletePacket& from);
  CGEquipmentPageDeletePacket(CGEquipmentPageDeletePacket&& from) noexcept
    : CGEquipmentPageDeletePacket() {
    *this = ::std::move(from);
  }

  inline CGEquipmentPageDeletePacket& operator=(const CGEquipmentPageDeletePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGEquipmentPageDeletePacket& operator=(CGEquipmentPageDeletePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGEquipmentPageDeletePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGEquipmentPageDeletePacket* internal_default_instance() {
    return reinterpret_cast<const CGEquipmentPageDeletePacket*>(
               &_CGEquipmentPageDeletePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CGEquipmentPageDeletePacket& a, CGEquipmentPageDeletePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGEquipmentPageDeletePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGEquipmentPageDeletePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGEquipmentPageDeletePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGEquipmentPageDeletePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGEquipmentPageDeletePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGEquipmentPageDeletePacket& from) {
    CGEquipmentPageDeletePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGEquipmentPageDeletePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGEquipmentPageDeletePacket";
  }
  protected:
  explicit CGEquipmentPageDeletePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGEquipmentPageDeletePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGEquipmentPageSelectPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGEquipmentPageSelectPacket) */ {
 public:
  inline CGEquipmentPageSelectPacket() : CGEquipmentPageSelectPacket(nullptr) {}
  ~CGEquipmentPageSelectPacket() override;
  explicit PROTOBUF_CONSTEXPR CGEquipmentPageSelectPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGEquipmentPageSelectPacket(const CGEquipmentPageSelectPacket& from);
  CGEquipmentPageSelectPacket(CGEquipmentPageSelectPacket&& from) noexcept
    : CGEquipmentPageSelectPacket() {
    *this = ::std::move(from);
  }

  inline CGEquipmentPageSelectPacket& operator=(const CGEquipmentPageSelectPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGEquipmentPageSelectPacket& operator=(CGEquipmentPageSelectPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGEquipmentPageSelectPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGEquipmentPageSelectPacket* internal_default_instance() {
    return reinterpret_cast<const CGEquipmentPageSelectPacket*>(
               &_CGEquipmentPageSelectPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CGEquipmentPageSelectPacket& a, CGEquipmentPageSelectPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGEquipmentPageSelectPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGEquipmentPageSelectPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGEquipmentPageSelectPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGEquipmentPageSelectPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGEquipmentPageSelectPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGEquipmentPageSelectPacket& from) {
    CGEquipmentPageSelectPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGEquipmentPageSelectPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGEquipmentPageSelectPacket";
  }
  protected:
  explicit CGEquipmentPageSelectPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGEquipmentPageSelectPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGCombatZoneRequestActionPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGCombatZoneRequestActionPacket) */ {
 public:
  inline CGCombatZoneRequestActionPacket() : CGCombatZoneRequestActionPacket(nullptr) {}
  ~CGCombatZoneRequestActionPacket() override;
  explicit PROTOBUF_CONSTEXPR CGCombatZoneRequestActionPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGCombatZoneRequestActionPacket(const CGCombatZoneRequestActionPacket& from);
  CGCombatZoneRequestActionPacket(CGCombatZoneRequestActionPacket&& from) noexcept
    : CGCombatZoneRequestActionPacket() {
    *this = ::std::move(from);
  }

  inline CGCombatZoneRequestActionPacket& operator=(const CGCombatZoneRequestActionPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGCombatZoneRequestActionPacket& operator=(CGCombatZoneRequestActionPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGCombatZoneRequestActionPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGCombatZoneRequestActionPacket* internal_default_instance() {
    return reinterpret_cast<const CGCombatZoneRequestActionPacket*>(
               &_CGCombatZoneRequestActionPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CGCombatZoneRequestActionPacket& a, CGCombatZoneRequestActionPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGCombatZoneRequestActionPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGCombatZoneRequestActionPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGCombatZoneRequestActionPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGCombatZoneRequestActionPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGCombatZoneRequestActionPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGCombatZoneRequestActionPacket& from) {
    CGCombatZoneRequestActionPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGCombatZoneRequestActionPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGCombatZoneRequestActionPacket";
  }
  protected:
  explicit CGCombatZoneRequestActionPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 action = 1;
  void clear_action();
  int32_t action() const;
  void set_action(int32_t value);
  private:
  int32_t _internal_action() const;
  void _internal_set_action(int32_t value);
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGCombatZoneRequestActionPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t action_;
    int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGCrystalRefinePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGCrystalRefinePacket) */ {
 public:
  inline CGCrystalRefinePacket() : CGCrystalRefinePacket(nullptr) {}
  ~CGCrystalRefinePacket() override;
  explicit PROTOBUF_CONSTEXPR CGCrystalRefinePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGCrystalRefinePacket(const CGCrystalRefinePacket& from);
  CGCrystalRefinePacket(CGCrystalRefinePacket&& from) noexcept
    : CGCrystalRefinePacket() {
    *this = ::std::move(from);
  }

  inline CGCrystalRefinePacket& operator=(const CGCrystalRefinePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGCrystalRefinePacket& operator=(CGCrystalRefinePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGCrystalRefinePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGCrystalRefinePacket* internal_default_instance() {
    return reinterpret_cast<const CGCrystalRefinePacket*>(
               &_CGCrystalRefinePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CGCrystalRefinePacket& a, CGCrystalRefinePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGCrystalRefinePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGCrystalRefinePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGCrystalRefinePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGCrystalRefinePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGCrystalRefinePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGCrystalRefinePacket& from) {
    CGCrystalRefinePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGCrystalRefinePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGCrystalRefinePacket";
  }
  protected:
  explicit CGCrystalRefinePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrystalCellFieldNumber = 1,
    kScrollCellFieldNumber = 2,
  };
  // .network.TItemPos crystal_cell = 1;
  bool has_crystal_cell() const;
  private:
  bool _internal_has_crystal_cell() const;
  public:
  void clear_crystal_cell();
  const ::network::TItemPos& crystal_cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_crystal_cell();
  ::network::TItemPos* mutable_crystal_cell();
  void set_allocated_crystal_cell(::network::TItemPos* crystal_cell);
  private:
  const ::network::TItemPos& _internal_crystal_cell() const;
  ::network::TItemPos* _internal_mutable_crystal_cell();
  public:
  void unsafe_arena_set_allocated_crystal_cell(
      ::network::TItemPos* crystal_cell);
  ::network::TItemPos* unsafe_arena_release_crystal_cell();

  // .network.TItemPos scroll_cell = 2;
  bool has_scroll_cell() const;
  private:
  bool _internal_has_scroll_cell() const;
  public:
  void clear_scroll_cell();
  const ::network::TItemPos& scroll_cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_scroll_cell();
  ::network::TItemPos* mutable_scroll_cell();
  void set_allocated_scroll_cell(::network::TItemPos* scroll_cell);
  private:
  const ::network::TItemPos& _internal_scroll_cell() const;
  ::network::TItemPos* _internal_mutable_scroll_cell();
  public:
  void unsafe_arena_set_allocated_scroll_cell(
      ::network::TItemPos* scroll_cell);
  ::network::TItemPos* unsafe_arena_release_scroll_cell();

  // @@protoc_insertion_point(class_scope:network.CGCrystalRefinePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* crystal_cell_;
    ::network::TItemPos* scroll_cell_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionInsertItemPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionInsertItemPacket) */ {
 public:
  inline CGAuctionInsertItemPacket() : CGAuctionInsertItemPacket(nullptr) {}
  ~CGAuctionInsertItemPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionInsertItemPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionInsertItemPacket(const CGAuctionInsertItemPacket& from);
  CGAuctionInsertItemPacket(CGAuctionInsertItemPacket&& from) noexcept
    : CGAuctionInsertItemPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionInsertItemPacket& operator=(const CGAuctionInsertItemPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionInsertItemPacket& operator=(CGAuctionInsertItemPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionInsertItemPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionInsertItemPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionInsertItemPacket*>(
               &_CGAuctionInsertItemPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CGAuctionInsertItemPacket& a, CGAuctionInsertItemPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionInsertItemPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionInsertItemPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionInsertItemPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionInsertItemPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionInsertItemPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionInsertItemPacket& from) {
    CGAuctionInsertItemPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionInsertItemPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionInsertItemPacket";
  }
  protected:
  explicit CGAuctionInsertItemPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kTargetCellFieldNumber = 2,
    kPriceFieldNumber = 3,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // .network.TItemPos target_cell = 2;
  bool has_target_cell() const;
  private:
  bool _internal_has_target_cell() const;
  public:
  void clear_target_cell();
  const ::network::TItemPos& target_cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_target_cell();
  ::network::TItemPos* mutable_target_cell();
  void set_allocated_target_cell(::network::TItemPos* target_cell);
  private:
  const ::network::TItemPos& _internal_target_cell() const;
  ::network::TItemPos* _internal_mutable_target_cell();
  public:
  void unsafe_arena_set_allocated_target_cell(
      ::network::TItemPos* target_cell);
  ::network::TItemPos* unsafe_arena_release_target_cell();

  // uint64 price = 3;
  void clear_price();
  uint64_t price() const;
  void set_price(uint64_t value);
  private:
  uint64_t _internal_price() const;
  void _internal_set_price(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionInsertItemPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    ::network::TItemPos* target_cell_;
    uint64_t price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionTakeItemPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionTakeItemPacket) */ {
 public:
  inline CGAuctionTakeItemPacket() : CGAuctionTakeItemPacket(nullptr) {}
  ~CGAuctionTakeItemPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionTakeItemPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionTakeItemPacket(const CGAuctionTakeItemPacket& from);
  CGAuctionTakeItemPacket(CGAuctionTakeItemPacket&& from) noexcept
    : CGAuctionTakeItemPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionTakeItemPacket& operator=(const CGAuctionTakeItemPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionTakeItemPacket& operator=(CGAuctionTakeItemPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionTakeItemPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionTakeItemPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionTakeItemPacket*>(
               &_CGAuctionTakeItemPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CGAuctionTakeItemPacket& a, CGAuctionTakeItemPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionTakeItemPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionTakeItemPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionTakeItemPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionTakeItemPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionTakeItemPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionTakeItemPacket& from) {
    CGAuctionTakeItemPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionTakeItemPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionTakeItemPacket";
  }
  protected:
  explicit CGAuctionTakeItemPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kInventoryPosFieldNumber = 2,
  };
  // uint32 item_id = 1;
  void clear_item_id();
  uint32_t item_id() const;
  void set_item_id(uint32_t value);
  private:
  uint32_t _internal_item_id() const;
  void _internal_set_item_id(uint32_t value);
  public:

  // uint32 inventory_pos = 2;
  void clear_inventory_pos();
  uint32_t inventory_pos() const;
  void set_inventory_pos(uint32_t value);
  private:
  uint32_t _internal_inventory_pos() const;
  void _internal_set_inventory_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionTakeItemPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t item_id_;
    uint32_t inventory_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionBuyItemPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionBuyItemPacket) */ {
 public:
  inline CGAuctionBuyItemPacket() : CGAuctionBuyItemPacket(nullptr) {}
  ~CGAuctionBuyItemPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionBuyItemPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionBuyItemPacket(const CGAuctionBuyItemPacket& from);
  CGAuctionBuyItemPacket(CGAuctionBuyItemPacket&& from) noexcept
    : CGAuctionBuyItemPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionBuyItemPacket& operator=(const CGAuctionBuyItemPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionBuyItemPacket& operator=(CGAuctionBuyItemPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionBuyItemPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionBuyItemPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionBuyItemPacket*>(
               &_CGAuctionBuyItemPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(CGAuctionBuyItemPacket& a, CGAuctionBuyItemPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionBuyItemPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionBuyItemPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionBuyItemPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionBuyItemPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionBuyItemPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionBuyItemPacket& from) {
    CGAuctionBuyItemPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionBuyItemPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionBuyItemPacket";
  }
  protected:
  explicit CGAuctionBuyItemPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 2,
    kItemIdFieldNumber = 1,
  };
  // uint64 price = 2;
  void clear_price();
  uint64_t price() const;
  void set_price(uint64_t value);
  private:
  uint64_t _internal_price() const;
  void _internal_set_price(uint64_t value);
  public:

  // uint32 item_id = 1;
  void clear_item_id();
  uint32_t item_id() const;
  void set_item_id(uint32_t value);
  private:
  uint32_t _internal_item_id() const;
  void _internal_set_item_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionBuyItemPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t price_;
    uint32_t item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionTakeGoldPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionTakeGoldPacket) */ {
 public:
  inline CGAuctionTakeGoldPacket() : CGAuctionTakeGoldPacket(nullptr) {}
  ~CGAuctionTakeGoldPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionTakeGoldPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionTakeGoldPacket(const CGAuctionTakeGoldPacket& from);
  CGAuctionTakeGoldPacket(CGAuctionTakeGoldPacket&& from) noexcept
    : CGAuctionTakeGoldPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionTakeGoldPacket& operator=(const CGAuctionTakeGoldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionTakeGoldPacket& operator=(CGAuctionTakeGoldPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionTakeGoldPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionTakeGoldPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionTakeGoldPacket*>(
               &_CGAuctionTakeGoldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(CGAuctionTakeGoldPacket& a, CGAuctionTakeGoldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionTakeGoldPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionTakeGoldPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionTakeGoldPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionTakeGoldPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionTakeGoldPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionTakeGoldPacket& from) {
    CGAuctionTakeGoldPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionTakeGoldPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionTakeGoldPacket";
  }
  protected:
  explicit CGAuctionTakeGoldPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoldFieldNumber = 1,
  };
  // uint64 gold = 1;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionTakeGoldPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionSearchItemsPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionSearchItemsPacket) */ {
 public:
  inline CGAuctionSearchItemsPacket() : CGAuctionSearchItemsPacket(nullptr) {}
  ~CGAuctionSearchItemsPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionSearchItemsPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionSearchItemsPacket(const CGAuctionSearchItemsPacket& from);
  CGAuctionSearchItemsPacket(CGAuctionSearchItemsPacket&& from) noexcept
    : CGAuctionSearchItemsPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionSearchItemsPacket& operator=(const CGAuctionSearchItemsPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionSearchItemsPacket& operator=(CGAuctionSearchItemsPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionSearchItemsPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionSearchItemsPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionSearchItemsPacket*>(
               &_CGAuctionSearchItemsPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(CGAuctionSearchItemsPacket& a, CGAuctionSearchItemsPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionSearchItemsPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionSearchItemsPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionSearchItemsPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionSearchItemsPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionSearchItemsPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionSearchItemsPacket& from) {
    CGAuctionSearchItemsPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionSearchItemsPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionSearchItemsPacket";
  }
  protected:
  explicit CGAuctionSearchItemsPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 2,
    kPageFieldNumber = 1,
  };
  // .network.TDataAuctionSearch options = 2;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::network::TDataAuctionSearch& options() const;
  PROTOBUF_NODISCARD ::network::TDataAuctionSearch* release_options();
  ::network::TDataAuctionSearch* mutable_options();
  void set_allocated_options(::network::TDataAuctionSearch* options);
  private:
  const ::network::TDataAuctionSearch& _internal_options() const;
  ::network::TDataAuctionSearch* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::network::TDataAuctionSearch* options);
  ::network::TDataAuctionSearch* unsafe_arena_release_options();

  // uint32 page = 1;
  void clear_page();
  uint32_t page() const;
  void set_page(uint32_t value);
  private:
  uint32_t _internal_page() const;
  void _internal_set_page(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionSearchItemsPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TDataAuctionSearch* options_;
    uint32_t page_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionExtendedSearchItemsPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionExtendedSearchItemsPacket) */ {
 public:
  inline CGAuctionExtendedSearchItemsPacket() : CGAuctionExtendedSearchItemsPacket(nullptr) {}
  ~CGAuctionExtendedSearchItemsPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionExtendedSearchItemsPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionExtendedSearchItemsPacket(const CGAuctionExtendedSearchItemsPacket& from);
  CGAuctionExtendedSearchItemsPacket(CGAuctionExtendedSearchItemsPacket&& from) noexcept
    : CGAuctionExtendedSearchItemsPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionExtendedSearchItemsPacket& operator=(const CGAuctionExtendedSearchItemsPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionExtendedSearchItemsPacket& operator=(CGAuctionExtendedSearchItemsPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionExtendedSearchItemsPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionExtendedSearchItemsPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionExtendedSearchItemsPacket*>(
               &_CGAuctionExtendedSearchItemsPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(CGAuctionExtendedSearchItemsPacket& a, CGAuctionExtendedSearchItemsPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionExtendedSearchItemsPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionExtendedSearchItemsPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionExtendedSearchItemsPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionExtendedSearchItemsPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionExtendedSearchItemsPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionExtendedSearchItemsPacket& from) {
    CGAuctionExtendedSearchItemsPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionExtendedSearchItemsPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionExtendedSearchItemsPacket";
  }
  protected:
  explicit CGAuctionExtendedSearchItemsPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 2,
    kPageFieldNumber = 1,
  };
  // .network.TExtendedDataAuctionSearch options = 2;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::network::TExtendedDataAuctionSearch& options() const;
  PROTOBUF_NODISCARD ::network::TExtendedDataAuctionSearch* release_options();
  ::network::TExtendedDataAuctionSearch* mutable_options();
  void set_allocated_options(::network::TExtendedDataAuctionSearch* options);
  private:
  const ::network::TExtendedDataAuctionSearch& _internal_options() const;
  ::network::TExtendedDataAuctionSearch* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::network::TExtendedDataAuctionSearch* options);
  ::network::TExtendedDataAuctionSearch* unsafe_arena_release_options();

  // uint32 page = 1;
  void clear_page();
  uint32_t page() const;
  void set_page(uint32_t value);
  private:
  uint32_t _internal_page() const;
  void _internal_set_page(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionExtendedSearchItemsPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TExtendedDataAuctionSearch* options_;
    uint32_t page_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionMarkShopPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionMarkShopPacket) */ {
 public:
  inline CGAuctionMarkShopPacket() : CGAuctionMarkShopPacket(nullptr) {}
  ~CGAuctionMarkShopPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionMarkShopPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionMarkShopPacket(const CGAuctionMarkShopPacket& from);
  CGAuctionMarkShopPacket(CGAuctionMarkShopPacket&& from) noexcept
    : CGAuctionMarkShopPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionMarkShopPacket& operator=(const CGAuctionMarkShopPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionMarkShopPacket& operator=(CGAuctionMarkShopPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionMarkShopPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionMarkShopPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionMarkShopPacket*>(
               &_CGAuctionMarkShopPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(CGAuctionMarkShopPacket& a, CGAuctionMarkShopPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionMarkShopPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionMarkShopPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionMarkShopPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionMarkShopPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionMarkShopPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionMarkShopPacket& from) {
    CGAuctionMarkShopPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionMarkShopPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionMarkShopPacket";
  }
  protected:
  explicit CGAuctionMarkShopPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // uint32 item_id = 1;
  void clear_item_id();
  uint32_t item_id() const;
  void set_item_id(uint32_t value);
  private:
  uint32_t _internal_item_id() const;
  void _internal_set_item_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionMarkShopPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionShopOpenPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionShopOpenPacket) */ {
 public:
  inline CGAuctionShopOpenPacket() : CGAuctionShopOpenPacket(nullptr) {}
  ~CGAuctionShopOpenPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionShopOpenPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionShopOpenPacket(const CGAuctionShopOpenPacket& from);
  CGAuctionShopOpenPacket(CGAuctionShopOpenPacket&& from) noexcept
    : CGAuctionShopOpenPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionShopOpenPacket& operator=(const CGAuctionShopOpenPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionShopOpenPacket& operator=(CGAuctionShopOpenPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionShopOpenPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionShopOpenPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionShopOpenPacket*>(
               &_CGAuctionShopOpenPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(CGAuctionShopOpenPacket& a, CGAuctionShopOpenPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionShopOpenPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionShopOpenPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionShopOpenPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionShopOpenPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionShopOpenPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionShopOpenPacket& from) {
    CGAuctionShopOpenPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionShopOpenPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionShopOpenPacket";
  }
  protected:
  explicit CGAuctionShopOpenPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 9,
    kNameFieldNumber = 1,
    kStyleFieldNumber = 2,
    kModelFieldNumber = 3,
    kColorRedFieldNumber = 4,
    kColorGreenFieldNumber = 5,
    kColorBlueFieldNumber = 6,
    kXFieldNumber = 7,
    kYFieldNumber = 8,
  };
  // repeated .network.TShopItemTable items = 9;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::network::TShopItemTable* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable >*
      mutable_items();
  private:
  const ::network::TShopItemTable& _internal_items(int index) const;
  ::network::TShopItemTable* _internal_add_items();
  public:
  const ::network::TShopItemTable& items(int index) const;
  ::network::TShopItemTable* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable >&
      items() const;

  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 style = 2;
  void clear_style();
  uint32_t style() const;
  void set_style(uint32_t value);
  private:
  uint32_t _internal_style() const;
  void _internal_set_style(uint32_t value);
  public:

  // uint32 model = 3;
  void clear_model();
  uint32_t model() const;
  void set_model(uint32_t value);
  private:
  uint32_t _internal_model() const;
  void _internal_set_model(uint32_t value);
  public:

  // float color_red = 4;
  void clear_color_red();
  float color_red() const;
  void set_color_red(float value);
  private:
  float _internal_color_red() const;
  void _internal_set_color_red(float value);
  public:

  // float color_green = 5;
  void clear_color_green();
  float color_green() const;
  void set_color_green(float value);
  private:
  float _internal_color_green() const;
  void _internal_set_color_green(float value);
  public:

  // float color_blue = 6;
  void clear_color_blue();
  float color_blue() const;
  void set_color_blue(float value);
  private:
  float _internal_color_blue() const;
  void _internal_set_color_blue(float value);
  public:

  // uint32 x = 7;
  void clear_x();
  uint32_t x() const;
  void set_x(uint32_t value);
  private:
  uint32_t _internal_x() const;
  void _internal_set_x(uint32_t value);
  public:

  // uint32 y = 8;
  void clear_y();
  uint32_t y() const;
  void set_y(uint32_t value);
  private:
  uint32_t _internal_y() const;
  void _internal_set_y(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionShopOpenPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable > items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t style_;
    uint32_t model_;
    float color_red_;
    float color_green_;
    float color_blue_;
    uint32_t x_;
    uint32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionShopClosePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionShopClosePacket) */ {
 public:
  inline CGAuctionShopClosePacket() : CGAuctionShopClosePacket(nullptr) {}
  ~CGAuctionShopClosePacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionShopClosePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionShopClosePacket(const CGAuctionShopClosePacket& from);
  CGAuctionShopClosePacket(CGAuctionShopClosePacket&& from) noexcept
    : CGAuctionShopClosePacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionShopClosePacket& operator=(const CGAuctionShopClosePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionShopClosePacket& operator=(CGAuctionShopClosePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionShopClosePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionShopClosePacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionShopClosePacket*>(
               &_CGAuctionShopClosePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(CGAuctionShopClosePacket& a, CGAuctionShopClosePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionShopClosePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionShopClosePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionShopClosePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionShopClosePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionShopClosePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionShopClosePacket& from) {
    CGAuctionShopClosePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionShopClosePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionShopClosePacket";
  }
  protected:
  explicit CGAuctionShopClosePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasItemsFieldNumber = 1,
  };
  // bool has_items = 1;
  void clear_has_items();
  bool has_items() const;
  void set_has_items(bool value);
  private:
  bool _internal_has_items() const;
  void _internal_set_has_items(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionShopClosePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool has_items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionShopTakeGoldPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionShopTakeGoldPacket) */ {
 public:
  inline CGAuctionShopTakeGoldPacket() : CGAuctionShopTakeGoldPacket(nullptr) {}
  ~CGAuctionShopTakeGoldPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionShopTakeGoldPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionShopTakeGoldPacket(const CGAuctionShopTakeGoldPacket& from);
  CGAuctionShopTakeGoldPacket(CGAuctionShopTakeGoldPacket&& from) noexcept
    : CGAuctionShopTakeGoldPacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionShopTakeGoldPacket& operator=(const CGAuctionShopTakeGoldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionShopTakeGoldPacket& operator=(CGAuctionShopTakeGoldPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionShopTakeGoldPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionShopTakeGoldPacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionShopTakeGoldPacket*>(
               &_CGAuctionShopTakeGoldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(CGAuctionShopTakeGoldPacket& a, CGAuctionShopTakeGoldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionShopTakeGoldPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionShopTakeGoldPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionShopTakeGoldPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionShopTakeGoldPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionShopTakeGoldPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionShopTakeGoldPacket& from) {
    CGAuctionShopTakeGoldPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionShopTakeGoldPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionShopTakeGoldPacket";
  }
  protected:
  explicit CGAuctionShopTakeGoldPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoldFieldNumber = 1,
  };
  // uint64 gold = 1;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionShopTakeGoldPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAuctionRequestAveragePricePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAuctionRequestAveragePricePacket) */ {
 public:
  inline CGAuctionRequestAveragePricePacket() : CGAuctionRequestAveragePricePacket(nullptr) {}
  ~CGAuctionRequestAveragePricePacket() override;
  explicit PROTOBUF_CONSTEXPR CGAuctionRequestAveragePricePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAuctionRequestAveragePricePacket(const CGAuctionRequestAveragePricePacket& from);
  CGAuctionRequestAveragePricePacket(CGAuctionRequestAveragePricePacket&& from) noexcept
    : CGAuctionRequestAveragePricePacket() {
    *this = ::std::move(from);
  }

  inline CGAuctionRequestAveragePricePacket& operator=(const CGAuctionRequestAveragePricePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAuctionRequestAveragePricePacket& operator=(CGAuctionRequestAveragePricePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAuctionRequestAveragePricePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAuctionRequestAveragePricePacket* internal_default_instance() {
    return reinterpret_cast<const CGAuctionRequestAveragePricePacket*>(
               &_CGAuctionRequestAveragePricePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(CGAuctionRequestAveragePricePacket& a, CGAuctionRequestAveragePricePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAuctionRequestAveragePricePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAuctionRequestAveragePricePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAuctionRequestAveragePricePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAuctionRequestAveragePricePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAuctionRequestAveragePricePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAuctionRequestAveragePricePacket& from) {
    CGAuctionRequestAveragePricePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAuctionRequestAveragePricePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAuctionRequestAveragePricePacket";
  }
  protected:
  explicit CGAuctionRequestAveragePricePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestorFieldNumber = 1,
    kVnumFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // uint32 requestor = 1;
  void clear_requestor();
  uint32_t requestor() const;
  void set_requestor(uint32_t value);
  private:
  uint32_t _internal_requestor() const;
  void _internal_set_requestor(uint32_t value);
  public:

  // uint32 vnum = 2;
  void clear_vnum();
  uint32_t vnum() const;
  void set_vnum(uint32_t value);
  private:
  uint32_t _internal_vnum() const;
  void _internal_set_vnum(uint32_t value);
  public:

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAuctionRequestAveragePricePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t requestor_;
    uint32_t vnum_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGScriptAnswerPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGScriptAnswerPacket) */ {
 public:
  inline CGScriptAnswerPacket() : CGScriptAnswerPacket(nullptr) {}
  ~CGScriptAnswerPacket() override;
  explicit PROTOBUF_CONSTEXPR CGScriptAnswerPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGScriptAnswerPacket(const CGScriptAnswerPacket& from);
  CGScriptAnswerPacket(CGScriptAnswerPacket&& from) noexcept
    : CGScriptAnswerPacket() {
    *this = ::std::move(from);
  }

  inline CGScriptAnswerPacket& operator=(const CGScriptAnswerPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGScriptAnswerPacket& operator=(CGScriptAnswerPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGScriptAnswerPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGScriptAnswerPacket* internal_default_instance() {
    return reinterpret_cast<const CGScriptAnswerPacket*>(
               &_CGScriptAnswerPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(CGScriptAnswerPacket& a, CGScriptAnswerPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGScriptAnswerPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGScriptAnswerPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGScriptAnswerPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGScriptAnswerPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGScriptAnswerPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGScriptAnswerPacket& from) {
    CGScriptAnswerPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGScriptAnswerPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGScriptAnswerPacket";
  }
  protected:
  explicit CGScriptAnswerPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnswerFieldNumber = 1,
  };
  // uint32 answer = 1;
  void clear_answer();
  uint32_t answer() const;
  void set_answer(uint32_t value);
  private:
  uint32_t _internal_answer() const;
  void _internal_set_answer(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGScriptAnswerPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t answer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGScriptButtonPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGScriptButtonPacket) */ {
 public:
  inline CGScriptButtonPacket() : CGScriptButtonPacket(nullptr) {}
  ~CGScriptButtonPacket() override;
  explicit PROTOBUF_CONSTEXPR CGScriptButtonPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGScriptButtonPacket(const CGScriptButtonPacket& from);
  CGScriptButtonPacket(CGScriptButtonPacket&& from) noexcept
    : CGScriptButtonPacket() {
    *this = ::std::move(from);
  }

  inline CGScriptButtonPacket& operator=(const CGScriptButtonPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGScriptButtonPacket& operator=(CGScriptButtonPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGScriptButtonPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGScriptButtonPacket* internal_default_instance() {
    return reinterpret_cast<const CGScriptButtonPacket*>(
               &_CGScriptButtonPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(CGScriptButtonPacket& a, CGScriptButtonPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGScriptButtonPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGScriptButtonPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGScriptButtonPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGScriptButtonPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGScriptButtonPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGScriptButtonPacket& from) {
    CGScriptButtonPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGScriptButtonPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGScriptButtonPacket";
  }
  protected:
  explicit CGScriptButtonPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGScriptButtonPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGScriptSelectItemPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGScriptSelectItemPacket) */ {
 public:
  inline CGScriptSelectItemPacket() : CGScriptSelectItemPacket(nullptr) {}
  ~CGScriptSelectItemPacket() override;
  explicit PROTOBUF_CONSTEXPR CGScriptSelectItemPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGScriptSelectItemPacket(const CGScriptSelectItemPacket& from);
  CGScriptSelectItemPacket(CGScriptSelectItemPacket&& from) noexcept
    : CGScriptSelectItemPacket() {
    *this = ::std::move(from);
  }

  inline CGScriptSelectItemPacket& operator=(const CGScriptSelectItemPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGScriptSelectItemPacket& operator=(CGScriptSelectItemPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGScriptSelectItemPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGScriptSelectItemPacket* internal_default_instance() {
    return reinterpret_cast<const CGScriptSelectItemPacket*>(
               &_CGScriptSelectItemPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(CGScriptSelectItemPacket& a, CGScriptSelectItemPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGScriptSelectItemPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGScriptSelectItemPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGScriptSelectItemPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGScriptSelectItemPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGScriptSelectItemPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGScriptSelectItemPacket& from) {
    CGScriptSelectItemPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGScriptSelectItemPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGScriptSelectItemPacket";
  }
  protected:
  explicit CGScriptSelectItemPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectionFieldNumber = 1,
  };
  // uint32 selection = 1;
  void clear_selection();
  uint32_t selection() const;
  void set_selection(uint32_t value);
  private:
  uint32_t _internal_selection() const;
  void _internal_set_selection(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGScriptSelectItemPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t selection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGQuestInputStringPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGQuestInputStringPacket) */ {
 public:
  inline CGQuestInputStringPacket() : CGQuestInputStringPacket(nullptr) {}
  ~CGQuestInputStringPacket() override;
  explicit PROTOBUF_CONSTEXPR CGQuestInputStringPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGQuestInputStringPacket(const CGQuestInputStringPacket& from);
  CGQuestInputStringPacket(CGQuestInputStringPacket&& from) noexcept
    : CGQuestInputStringPacket() {
    *this = ::std::move(from);
  }

  inline CGQuestInputStringPacket& operator=(const CGQuestInputStringPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGQuestInputStringPacket& operator=(CGQuestInputStringPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGQuestInputStringPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGQuestInputStringPacket* internal_default_instance() {
    return reinterpret_cast<const CGQuestInputStringPacket*>(
               &_CGQuestInputStringPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(CGQuestInputStringPacket& a, CGQuestInputStringPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGQuestInputStringPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGQuestInputStringPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGQuestInputStringPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGQuestInputStringPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGQuestInputStringPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGQuestInputStringPacket& from) {
    CGQuestInputStringPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGQuestInputStringPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGQuestInputStringPacket";
  }
  protected:
  explicit CGQuestInputStringPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // bytes message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:network.CGQuestInputStringPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGQuestConfirmPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGQuestConfirmPacket) */ {
 public:
  inline CGQuestConfirmPacket() : CGQuestConfirmPacket(nullptr) {}
  ~CGQuestConfirmPacket() override;
  explicit PROTOBUF_CONSTEXPR CGQuestConfirmPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGQuestConfirmPacket(const CGQuestConfirmPacket& from);
  CGQuestConfirmPacket(CGQuestConfirmPacket&& from) noexcept
    : CGQuestConfirmPacket() {
    *this = ::std::move(from);
  }

  inline CGQuestConfirmPacket& operator=(const CGQuestConfirmPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGQuestConfirmPacket& operator=(CGQuestConfirmPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGQuestConfirmPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGQuestConfirmPacket* internal_default_instance() {
    return reinterpret_cast<const CGQuestConfirmPacket*>(
               &_CGQuestConfirmPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(CGQuestConfirmPacket& a, CGQuestConfirmPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGQuestConfirmPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGQuestConfirmPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGQuestConfirmPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGQuestConfirmPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGQuestConfirmPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGQuestConfirmPacket& from) {
    CGQuestConfirmPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGQuestConfirmPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGQuestConfirmPacket";
  }
  protected:
  explicit CGQuestConfirmPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnswerFieldNumber = 1,
    kRequestPidFieldNumber = 2,
  };
  // uint32 answer = 1;
  void clear_answer();
  uint32_t answer() const;
  void set_answer(uint32_t value);
  private:
  uint32_t _internal_answer() const;
  void _internal_set_answer(uint32_t value);
  public:

  // uint32 request_pid = 2;
  void clear_request_pid();
  uint32_t request_pid() const;
  void set_request_pid(uint32_t value);
  private:
  uint32_t _internal_request_pid() const;
  void _internal_set_request_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGQuestConfirmPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t answer_;
    uint32_t request_pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGItemUsePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGItemUsePacket) */ {
 public:
  inline CGItemUsePacket() : CGItemUsePacket(nullptr) {}
  ~CGItemUsePacket() override;
  explicit PROTOBUF_CONSTEXPR CGItemUsePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGItemUsePacket(const CGItemUsePacket& from);
  CGItemUsePacket(CGItemUsePacket&& from) noexcept
    : CGItemUsePacket() {
    *this = ::std::move(from);
  }

  inline CGItemUsePacket& operator=(const CGItemUsePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGItemUsePacket& operator=(CGItemUsePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGItemUsePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGItemUsePacket* internal_default_instance() {
    return reinterpret_cast<const CGItemUsePacket*>(
               &_CGItemUsePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(CGItemUsePacket& a, CGItemUsePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGItemUsePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGItemUsePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGItemUsePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGItemUsePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGItemUsePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGItemUsePacket& from) {
    CGItemUsePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGItemUsePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGItemUsePacket";
  }
  protected:
  explicit CGItemUsePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // uint32 count = 2;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGItemUsePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGItemUseToItemPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGItemUseToItemPacket) */ {
 public:
  inline CGItemUseToItemPacket() : CGItemUseToItemPacket(nullptr) {}
  ~CGItemUseToItemPacket() override;
  explicit PROTOBUF_CONSTEXPR CGItemUseToItemPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGItemUseToItemPacket(const CGItemUseToItemPacket& from);
  CGItemUseToItemPacket(CGItemUseToItemPacket&& from) noexcept
    : CGItemUseToItemPacket() {
    *this = ::std::move(from);
  }

  inline CGItemUseToItemPacket& operator=(const CGItemUseToItemPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGItemUseToItemPacket& operator=(CGItemUseToItemPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGItemUseToItemPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGItemUseToItemPacket* internal_default_instance() {
    return reinterpret_cast<const CGItemUseToItemPacket*>(
               &_CGItemUseToItemPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(CGItemUseToItemPacket& a, CGItemUseToItemPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGItemUseToItemPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGItemUseToItemPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGItemUseToItemPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGItemUseToItemPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGItemUseToItemPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGItemUseToItemPacket& from) {
    CGItemUseToItemPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGItemUseToItemPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGItemUseToItemPacket";
  }
  protected:
  explicit CGItemUseToItemPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kTargetCellFieldNumber = 2,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // .network.TItemPos target_cell = 2;
  bool has_target_cell() const;
  private:
  bool _internal_has_target_cell() const;
  public:
  void clear_target_cell();
  const ::network::TItemPos& target_cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_target_cell();
  ::network::TItemPos* mutable_target_cell();
  void set_allocated_target_cell(::network::TItemPos* target_cell);
  private:
  const ::network::TItemPos& _internal_target_cell() const;
  ::network::TItemPos* _internal_mutable_target_cell();
  public:
  void unsafe_arena_set_allocated_target_cell(
      ::network::TItemPos* target_cell);
  ::network::TItemPos* unsafe_arena_release_target_cell();

  // @@protoc_insertion_point(class_scope:network.CGItemUseToItemPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    ::network::TItemPos* target_cell_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGItemDropPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGItemDropPacket) */ {
 public:
  inline CGItemDropPacket() : CGItemDropPacket(nullptr) {}
  ~CGItemDropPacket() override;
  explicit PROTOBUF_CONSTEXPR CGItemDropPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGItemDropPacket(const CGItemDropPacket& from);
  CGItemDropPacket(CGItemDropPacket&& from) noexcept
    : CGItemDropPacket() {
    *this = ::std::move(from);
  }

  inline CGItemDropPacket& operator=(const CGItemDropPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGItemDropPacket& operator=(CGItemDropPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGItemDropPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGItemDropPacket* internal_default_instance() {
    return reinterpret_cast<const CGItemDropPacket*>(
               &_CGItemDropPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(CGItemDropPacket& a, CGItemDropPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGItemDropPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGItemDropPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGItemDropPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGItemDropPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGItemDropPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGItemDropPacket& from) {
    CGItemDropPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGItemDropPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGItemDropPacket";
  }
  protected:
  explicit CGItemDropPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kGoldFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // uint32 gold = 2;
  void clear_gold();
  uint32_t gold() const;
  void set_gold(uint32_t value);
  private:
  uint32_t _internal_gold() const;
  void _internal_set_gold(uint32_t value);
  public:

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGItemDropPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    uint32_t gold_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGItemDestroyPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGItemDestroyPacket) */ {
 public:
  inline CGItemDestroyPacket() : CGItemDestroyPacket(nullptr) {}
  ~CGItemDestroyPacket() override;
  explicit PROTOBUF_CONSTEXPR CGItemDestroyPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGItemDestroyPacket(const CGItemDestroyPacket& from);
  CGItemDestroyPacket(CGItemDestroyPacket&& from) noexcept
    : CGItemDestroyPacket() {
    *this = ::std::move(from);
  }

  inline CGItemDestroyPacket& operator=(const CGItemDestroyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGItemDestroyPacket& operator=(CGItemDestroyPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGItemDestroyPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGItemDestroyPacket* internal_default_instance() {
    return reinterpret_cast<const CGItemDestroyPacket*>(
               &_CGItemDestroyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(CGItemDestroyPacket& a, CGItemDestroyPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGItemDestroyPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGItemDestroyPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGItemDestroyPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGItemDestroyPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGItemDestroyPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGItemDestroyPacket& from) {
    CGItemDestroyPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGItemDestroyPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGItemDestroyPacket";
  }
  protected:
  explicit CGItemDestroyPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // uint32 num = 2;
  void clear_num();
  uint32_t num() const;
  void set_num(uint32_t value);
  private:
  uint32_t _internal_num() const;
  void _internal_set_num(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGItemDestroyPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    uint32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGItemMovePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGItemMovePacket) */ {
 public:
  inline CGItemMovePacket() : CGItemMovePacket(nullptr) {}
  ~CGItemMovePacket() override;
  explicit PROTOBUF_CONSTEXPR CGItemMovePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGItemMovePacket(const CGItemMovePacket& from);
  CGItemMovePacket(CGItemMovePacket&& from) noexcept
    : CGItemMovePacket() {
    *this = ::std::move(from);
  }

  inline CGItemMovePacket& operator=(const CGItemMovePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGItemMovePacket& operator=(CGItemMovePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGItemMovePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGItemMovePacket* internal_default_instance() {
    return reinterpret_cast<const CGItemMovePacket*>(
               &_CGItemMovePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(CGItemMovePacket& a, CGItemMovePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGItemMovePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGItemMovePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGItemMovePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGItemMovePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGItemMovePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGItemMovePacket& from) {
    CGItemMovePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGItemMovePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGItemMovePacket";
  }
  protected:
  explicit CGItemMovePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kCellToFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // .network.TItemPos cell_to = 2;
  bool has_cell_to() const;
  private:
  bool _internal_has_cell_to() const;
  public:
  void clear_cell_to();
  const ::network::TItemPos& cell_to() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell_to();
  ::network::TItemPos* mutable_cell_to();
  void set_allocated_cell_to(::network::TItemPos* cell_to);
  private:
  const ::network::TItemPos& _internal_cell_to() const;
  ::network::TItemPos* _internal_mutable_cell_to();
  public:
  void unsafe_arena_set_allocated_cell_to(
      ::network::TItemPos* cell_to);
  ::network::TItemPos* unsafe_arena_release_cell_to();

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGItemMovePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    ::network::TItemPos* cell_to_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGItemPickupPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGItemPickupPacket) */ {
 public:
  inline CGItemPickupPacket() : CGItemPickupPacket(nullptr) {}
  ~CGItemPickupPacket() override;
  explicit PROTOBUF_CONSTEXPR CGItemPickupPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGItemPickupPacket(const CGItemPickupPacket& from);
  CGItemPickupPacket(CGItemPickupPacket&& from) noexcept
    : CGItemPickupPacket() {
    *this = ::std::move(from);
  }

  inline CGItemPickupPacket& operator=(const CGItemPickupPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGItemPickupPacket& operator=(CGItemPickupPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGItemPickupPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGItemPickupPacket* internal_default_instance() {
    return reinterpret_cast<const CGItemPickupPacket*>(
               &_CGItemPickupPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(CGItemPickupPacket& a, CGItemPickupPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGItemPickupPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGItemPickupPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGItemPickupPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGItemPickupPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGItemPickupPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGItemPickupPacket& from) {
    CGItemPickupPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGItemPickupPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGItemPickupPacket";
  }
  protected:
  explicit CGItemPickupPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVidFieldNumber = 1,
  };
  // uint32 vid = 1;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGItemPickupPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGSafeboxCheckinPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGSafeboxCheckinPacket) */ {
 public:
  inline CGSafeboxCheckinPacket() : CGSafeboxCheckinPacket(nullptr) {}
  ~CGSafeboxCheckinPacket() override;
  explicit PROTOBUF_CONSTEXPR CGSafeboxCheckinPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGSafeboxCheckinPacket(const CGSafeboxCheckinPacket& from);
  CGSafeboxCheckinPacket(CGSafeboxCheckinPacket&& from) noexcept
    : CGSafeboxCheckinPacket() {
    *this = ::std::move(from);
  }

  inline CGSafeboxCheckinPacket& operator=(const CGSafeboxCheckinPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGSafeboxCheckinPacket& operator=(CGSafeboxCheckinPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGSafeboxCheckinPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGSafeboxCheckinPacket* internal_default_instance() {
    return reinterpret_cast<const CGSafeboxCheckinPacket*>(
               &_CGSafeboxCheckinPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(CGSafeboxCheckinPacket& a, CGSafeboxCheckinPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGSafeboxCheckinPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGSafeboxCheckinPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGSafeboxCheckinPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGSafeboxCheckinPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGSafeboxCheckinPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGSafeboxCheckinPacket& from) {
    CGSafeboxCheckinPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGSafeboxCheckinPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGSafeboxCheckinPacket";
  }
  protected:
  explicit CGSafeboxCheckinPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryPosFieldNumber = 2,
    kSafeboxPosFieldNumber = 1,
  };
  // .network.TItemPos inventory_pos = 2;
  bool has_inventory_pos() const;
  private:
  bool _internal_has_inventory_pos() const;
  public:
  void clear_inventory_pos();
  const ::network::TItemPos& inventory_pos() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_inventory_pos();
  ::network::TItemPos* mutable_inventory_pos();
  void set_allocated_inventory_pos(::network::TItemPos* inventory_pos);
  private:
  const ::network::TItemPos& _internal_inventory_pos() const;
  ::network::TItemPos* _internal_mutable_inventory_pos();
  public:
  void unsafe_arena_set_allocated_inventory_pos(
      ::network::TItemPos* inventory_pos);
  ::network::TItemPos* unsafe_arena_release_inventory_pos();

  // uint32 safebox_pos = 1;
  void clear_safebox_pos();
  uint32_t safebox_pos() const;
  void set_safebox_pos(uint32_t value);
  private:
  uint32_t _internal_safebox_pos() const;
  void _internal_set_safebox_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGSafeboxCheckinPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* inventory_pos_;
    uint32_t safebox_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGSafeboxCheckoutPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGSafeboxCheckoutPacket) */ {
 public:
  inline CGSafeboxCheckoutPacket() : CGSafeboxCheckoutPacket(nullptr) {}
  ~CGSafeboxCheckoutPacket() override;
  explicit PROTOBUF_CONSTEXPR CGSafeboxCheckoutPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGSafeboxCheckoutPacket(const CGSafeboxCheckoutPacket& from);
  CGSafeboxCheckoutPacket(CGSafeboxCheckoutPacket&& from) noexcept
    : CGSafeboxCheckoutPacket() {
    *this = ::std::move(from);
  }

  inline CGSafeboxCheckoutPacket& operator=(const CGSafeboxCheckoutPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGSafeboxCheckoutPacket& operator=(CGSafeboxCheckoutPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGSafeboxCheckoutPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGSafeboxCheckoutPacket* internal_default_instance() {
    return reinterpret_cast<const CGSafeboxCheckoutPacket*>(
               &_CGSafeboxCheckoutPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(CGSafeboxCheckoutPacket& a, CGSafeboxCheckoutPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGSafeboxCheckoutPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGSafeboxCheckoutPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGSafeboxCheckoutPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGSafeboxCheckoutPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGSafeboxCheckoutPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGSafeboxCheckoutPacket& from) {
    CGSafeboxCheckoutPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGSafeboxCheckoutPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGSafeboxCheckoutPacket";
  }
  protected:
  explicit CGSafeboxCheckoutPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryPosFieldNumber = 2,
    kSafeboxPosFieldNumber = 1,
    kIsMallFieldNumber = 3,
  };
  // .network.TItemPos inventory_pos = 2;
  bool has_inventory_pos() const;
  private:
  bool _internal_has_inventory_pos() const;
  public:
  void clear_inventory_pos();
  const ::network::TItemPos& inventory_pos() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_inventory_pos();
  ::network::TItemPos* mutable_inventory_pos();
  void set_allocated_inventory_pos(::network::TItemPos* inventory_pos);
  private:
  const ::network::TItemPos& _internal_inventory_pos() const;
  ::network::TItemPos* _internal_mutable_inventory_pos();
  public:
  void unsafe_arena_set_allocated_inventory_pos(
      ::network::TItemPos* inventory_pos);
  ::network::TItemPos* unsafe_arena_release_inventory_pos();

  // uint32 safebox_pos = 1;
  void clear_safebox_pos();
  uint32_t safebox_pos() const;
  void set_safebox_pos(uint32_t value);
  private:
  uint32_t _internal_safebox_pos() const;
  void _internal_set_safebox_pos(uint32_t value);
  public:

  // bool is_mall = 3;
  void clear_is_mall();
  bool is_mall() const;
  void set_is_mall(bool value);
  private:
  bool _internal_is_mall() const;
  void _internal_set_is_mall(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGSafeboxCheckoutPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* inventory_pos_;
    uint32_t safebox_pos_;
    bool is_mall_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGSafeboxItemMovePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGSafeboxItemMovePacket) */ {
 public:
  inline CGSafeboxItemMovePacket() : CGSafeboxItemMovePacket(nullptr) {}
  ~CGSafeboxItemMovePacket() override;
  explicit PROTOBUF_CONSTEXPR CGSafeboxItemMovePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGSafeboxItemMovePacket(const CGSafeboxItemMovePacket& from);
  CGSafeboxItemMovePacket(CGSafeboxItemMovePacket&& from) noexcept
    : CGSafeboxItemMovePacket() {
    *this = ::std::move(from);
  }

  inline CGSafeboxItemMovePacket& operator=(const CGSafeboxItemMovePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGSafeboxItemMovePacket& operator=(CGSafeboxItemMovePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGSafeboxItemMovePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGSafeboxItemMovePacket* internal_default_instance() {
    return reinterpret_cast<const CGSafeboxItemMovePacket*>(
               &_CGSafeboxItemMovePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(CGSafeboxItemMovePacket& a, CGSafeboxItemMovePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGSafeboxItemMovePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGSafeboxItemMovePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGSafeboxItemMovePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGSafeboxItemMovePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGSafeboxItemMovePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGSafeboxItemMovePacket& from) {
    CGSafeboxItemMovePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGSafeboxItemMovePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGSafeboxItemMovePacket";
  }
  protected:
  explicit CGSafeboxItemMovePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcePosFieldNumber = 1,
    kTargetPosFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // uint32 source_pos = 1;
  void clear_source_pos();
  uint32_t source_pos() const;
  void set_source_pos(uint32_t value);
  private:
  uint32_t _internal_source_pos() const;
  void _internal_set_source_pos(uint32_t value);
  public:

  // uint32 target_pos = 2;
  void clear_target_pos();
  uint32_t target_pos() const;
  void set_target_pos(uint32_t value);
  private:
  uint32_t _internal_target_pos() const;
  void _internal_set_target_pos(uint32_t value);
  public:

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGSafeboxItemMovePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t source_pos_;
    uint32_t target_pos_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAcceRefineCheckinPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAcceRefineCheckinPacket) */ {
 public:
  inline CGAcceRefineCheckinPacket() : CGAcceRefineCheckinPacket(nullptr) {}
  ~CGAcceRefineCheckinPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAcceRefineCheckinPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAcceRefineCheckinPacket(const CGAcceRefineCheckinPacket& from);
  CGAcceRefineCheckinPacket(CGAcceRefineCheckinPacket&& from) noexcept
    : CGAcceRefineCheckinPacket() {
    *this = ::std::move(from);
  }

  inline CGAcceRefineCheckinPacket& operator=(const CGAcceRefineCheckinPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAcceRefineCheckinPacket& operator=(CGAcceRefineCheckinPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAcceRefineCheckinPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAcceRefineCheckinPacket* internal_default_instance() {
    return reinterpret_cast<const CGAcceRefineCheckinPacket*>(
               &_CGAcceRefineCheckinPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(CGAcceRefineCheckinPacket& a, CGAcceRefineCheckinPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAcceRefineCheckinPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAcceRefineCheckinPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAcceRefineCheckinPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAcceRefineCheckinPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAcceRefineCheckinPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAcceRefineCheckinPacket& from) {
    CGAcceRefineCheckinPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAcceRefineCheckinPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAcceRefineCheckinPacket";
  }
  protected:
  explicit CGAcceRefineCheckinPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemCellFieldNumber = 1,
    kAccePosFieldNumber = 2,
  };
  // .network.TItemPos item_cell = 1;
  bool has_item_cell() const;
  private:
  bool _internal_has_item_cell() const;
  public:
  void clear_item_cell();
  const ::network::TItemPos& item_cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_item_cell();
  ::network::TItemPos* mutable_item_cell();
  void set_allocated_item_cell(::network::TItemPos* item_cell);
  private:
  const ::network::TItemPos& _internal_item_cell() const;
  ::network::TItemPos* _internal_mutable_item_cell();
  public:
  void unsafe_arena_set_allocated_item_cell(
      ::network::TItemPos* item_cell);
  ::network::TItemPos* unsafe_arena_release_item_cell();

  // uint32 acce_pos = 2;
  void clear_acce_pos();
  uint32_t acce_pos() const;
  void set_acce_pos(uint32_t value);
  private:
  uint32_t _internal_acce_pos() const;
  void _internal_set_acce_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAcceRefineCheckinPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* item_cell_;
    uint32_t acce_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAcceRefineCheckoutPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAcceRefineCheckoutPacket) */ {
 public:
  inline CGAcceRefineCheckoutPacket() : CGAcceRefineCheckoutPacket(nullptr) {}
  ~CGAcceRefineCheckoutPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAcceRefineCheckoutPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAcceRefineCheckoutPacket(const CGAcceRefineCheckoutPacket& from);
  CGAcceRefineCheckoutPacket(CGAcceRefineCheckoutPacket&& from) noexcept
    : CGAcceRefineCheckoutPacket() {
    *this = ::std::move(from);
  }

  inline CGAcceRefineCheckoutPacket& operator=(const CGAcceRefineCheckoutPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAcceRefineCheckoutPacket& operator=(CGAcceRefineCheckoutPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAcceRefineCheckoutPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAcceRefineCheckoutPacket* internal_default_instance() {
    return reinterpret_cast<const CGAcceRefineCheckoutPacket*>(
               &_CGAcceRefineCheckoutPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(CGAcceRefineCheckoutPacket& a, CGAcceRefineCheckoutPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAcceRefineCheckoutPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAcceRefineCheckoutPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAcceRefineCheckoutPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAcceRefineCheckoutPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAcceRefineCheckoutPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAcceRefineCheckoutPacket& from) {
    CGAcceRefineCheckoutPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAcceRefineCheckoutPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAcceRefineCheckoutPacket";
  }
  protected:
  explicit CGAcceRefineCheckoutPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccePosFieldNumber = 1,
  };
  // uint32 acce_pos = 1;
  void clear_acce_pos();
  uint32_t acce_pos() const;
  void set_acce_pos(uint32_t value);
  private:
  uint32_t _internal_acce_pos() const;
  void _internal_set_acce_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAcceRefineCheckoutPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t acce_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGAcceRefineAcceptPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGAcceRefineAcceptPacket) */ {
 public:
  inline CGAcceRefineAcceptPacket() : CGAcceRefineAcceptPacket(nullptr) {}
  ~CGAcceRefineAcceptPacket() override;
  explicit PROTOBUF_CONSTEXPR CGAcceRefineAcceptPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGAcceRefineAcceptPacket(const CGAcceRefineAcceptPacket& from);
  CGAcceRefineAcceptPacket(CGAcceRefineAcceptPacket&& from) noexcept
    : CGAcceRefineAcceptPacket() {
    *this = ::std::move(from);
  }

  inline CGAcceRefineAcceptPacket& operator=(const CGAcceRefineAcceptPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGAcceRefineAcceptPacket& operator=(CGAcceRefineAcceptPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGAcceRefineAcceptPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGAcceRefineAcceptPacket* internal_default_instance() {
    return reinterpret_cast<const CGAcceRefineAcceptPacket*>(
               &_CGAcceRefineAcceptPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(CGAcceRefineAcceptPacket& a, CGAcceRefineAcceptPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGAcceRefineAcceptPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGAcceRefineAcceptPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGAcceRefineAcceptPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGAcceRefineAcceptPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGAcceRefineAcceptPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGAcceRefineAcceptPacket& from) {
    CGAcceRefineAcceptPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGAcceRefineAcceptPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGAcceRefineAcceptPacket";
  }
  protected:
  explicit CGAcceRefineAcceptPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowTypeFieldNumber = 1,
  };
  // uint32 window_type = 1;
  void clear_window_type();
  uint32_t window_type() const;
  void set_window_type(uint32_t value);
  private:
  uint32_t _internal_window_type() const;
  void _internal_set_window_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGAcceRefineAcceptPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t window_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGQuickslotAddPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGQuickslotAddPacket) */ {
 public:
  inline CGQuickslotAddPacket() : CGQuickslotAddPacket(nullptr) {}
  ~CGQuickslotAddPacket() override;
  explicit PROTOBUF_CONSTEXPR CGQuickslotAddPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGQuickslotAddPacket(const CGQuickslotAddPacket& from);
  CGQuickslotAddPacket(CGQuickslotAddPacket&& from) noexcept
    : CGQuickslotAddPacket() {
    *this = ::std::move(from);
  }

  inline CGQuickslotAddPacket& operator=(const CGQuickslotAddPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGQuickslotAddPacket& operator=(CGQuickslotAddPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGQuickslotAddPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGQuickslotAddPacket* internal_default_instance() {
    return reinterpret_cast<const CGQuickslotAddPacket*>(
               &_CGQuickslotAddPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(CGQuickslotAddPacket& a, CGQuickslotAddPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGQuickslotAddPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGQuickslotAddPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGQuickslotAddPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGQuickslotAddPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGQuickslotAddPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGQuickslotAddPacket& from) {
    CGQuickslotAddPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGQuickslotAddPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGQuickslotAddPacket";
  }
  protected:
  explicit CGQuickslotAddPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 2,
    kPosFieldNumber = 1,
  };
  // .TQuickslot slot = 2;
  bool has_slot() const;
  private:
  bool _internal_has_slot() const;
  public:
  void clear_slot();
  const ::TQuickslot& slot() const;
  PROTOBUF_NODISCARD ::TQuickslot* release_slot();
  ::TQuickslot* mutable_slot();
  void set_allocated_slot(::TQuickslot* slot);
  private:
  const ::TQuickslot& _internal_slot() const;
  ::TQuickslot* _internal_mutable_slot();
  public:
  void unsafe_arena_set_allocated_slot(
      ::TQuickslot* slot);
  ::TQuickslot* unsafe_arena_release_slot();

  // uint32 pos = 1;
  void clear_pos();
  uint32_t pos() const;
  void set_pos(uint32_t value);
  private:
  uint32_t _internal_pos() const;
  void _internal_set_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGQuickslotAddPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TQuickslot* slot_;
    uint32_t pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGQuickslotDeletePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGQuickslotDeletePacket) */ {
 public:
  inline CGQuickslotDeletePacket() : CGQuickslotDeletePacket(nullptr) {}
  ~CGQuickslotDeletePacket() override;
  explicit PROTOBUF_CONSTEXPR CGQuickslotDeletePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGQuickslotDeletePacket(const CGQuickslotDeletePacket& from);
  CGQuickslotDeletePacket(CGQuickslotDeletePacket&& from) noexcept
    : CGQuickslotDeletePacket() {
    *this = ::std::move(from);
  }

  inline CGQuickslotDeletePacket& operator=(const CGQuickslotDeletePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGQuickslotDeletePacket& operator=(CGQuickslotDeletePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGQuickslotDeletePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGQuickslotDeletePacket* internal_default_instance() {
    return reinterpret_cast<const CGQuickslotDeletePacket*>(
               &_CGQuickslotDeletePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(CGQuickslotDeletePacket& a, CGQuickslotDeletePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGQuickslotDeletePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGQuickslotDeletePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGQuickslotDeletePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGQuickslotDeletePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGQuickslotDeletePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGQuickslotDeletePacket& from) {
    CGQuickslotDeletePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGQuickslotDeletePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGQuickslotDeletePacket";
  }
  protected:
  explicit CGQuickslotDeletePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
  };
  // uint32 pos = 1;
  void clear_pos();
  uint32_t pos() const;
  void set_pos(uint32_t value);
  private:
  uint32_t _internal_pos() const;
  void _internal_set_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGQuickslotDeletePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGQuickslotSwapPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGQuickslotSwapPacket) */ {
 public:
  inline CGQuickslotSwapPacket() : CGQuickslotSwapPacket(nullptr) {}
  ~CGQuickslotSwapPacket() override;
  explicit PROTOBUF_CONSTEXPR CGQuickslotSwapPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGQuickslotSwapPacket(const CGQuickslotSwapPacket& from);
  CGQuickslotSwapPacket(CGQuickslotSwapPacket&& from) noexcept
    : CGQuickslotSwapPacket() {
    *this = ::std::move(from);
  }

  inline CGQuickslotSwapPacket& operator=(const CGQuickslotSwapPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGQuickslotSwapPacket& operator=(CGQuickslotSwapPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGQuickslotSwapPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGQuickslotSwapPacket* internal_default_instance() {
    return reinterpret_cast<const CGQuickslotSwapPacket*>(
               &_CGQuickslotSwapPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(CGQuickslotSwapPacket& a, CGQuickslotSwapPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGQuickslotSwapPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGQuickslotSwapPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGQuickslotSwapPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGQuickslotSwapPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGQuickslotSwapPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGQuickslotSwapPacket& from) {
    CGQuickslotSwapPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGQuickslotSwapPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGQuickslotSwapPacket";
  }
  protected:
  explicit CGQuickslotSwapPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kChangePosFieldNumber = 2,
  };
  // uint32 pos = 1;
  void clear_pos();
  uint32_t pos() const;
  void set_pos(uint32_t value);
  private:
  uint32_t _internal_pos() const;
  void _internal_set_pos(uint32_t value);
  public:

  // uint32 change_pos = 2;
  void clear_change_pos();
  uint32_t change_pos() const;
  void set_change_pos(uint32_t value);
  private:
  uint32_t _internal_change_pos() const;
  void _internal_set_change_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGQuickslotSwapPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pos_;
    uint32_t change_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGShopBuyPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGShopBuyPacket) */ {
 public:
  inline CGShopBuyPacket() : CGShopBuyPacket(nullptr) {}
  ~CGShopBuyPacket() override;
  explicit PROTOBUF_CONSTEXPR CGShopBuyPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGShopBuyPacket(const CGShopBuyPacket& from);
  CGShopBuyPacket(CGShopBuyPacket&& from) noexcept
    : CGShopBuyPacket() {
    *this = ::std::move(from);
  }

  inline CGShopBuyPacket& operator=(const CGShopBuyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGShopBuyPacket& operator=(CGShopBuyPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGShopBuyPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGShopBuyPacket* internal_default_instance() {
    return reinterpret_cast<const CGShopBuyPacket*>(
               &_CGShopBuyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(CGShopBuyPacket& a, CGShopBuyPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGShopBuyPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGShopBuyPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGShopBuyPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGShopBuyPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGShopBuyPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGShopBuyPacket& from) {
    CGShopBuyPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGShopBuyPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGShopBuyPacket";
  }
  protected:
  explicit CGShopBuyPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
  };
  // uint32 pos = 1;
  void clear_pos();
  uint32_t pos() const;
  void set_pos(uint32_t value);
  private:
  uint32_t _internal_pos() const;
  void _internal_set_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGShopBuyPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGShopSellPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGShopSellPacket) */ {
 public:
  inline CGShopSellPacket() : CGShopSellPacket(nullptr) {}
  ~CGShopSellPacket() override;
  explicit PROTOBUF_CONSTEXPR CGShopSellPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGShopSellPacket(const CGShopSellPacket& from);
  CGShopSellPacket(CGShopSellPacket&& from) noexcept
    : CGShopSellPacket() {
    *this = ::std::move(from);
  }

  inline CGShopSellPacket& operator=(const CGShopSellPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGShopSellPacket& operator=(CGShopSellPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGShopSellPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGShopSellPacket* internal_default_instance() {
    return reinterpret_cast<const CGShopSellPacket*>(
               &_CGShopSellPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(CGShopSellPacket& a, CGShopSellPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGShopSellPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGShopSellPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGShopSellPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGShopSellPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGShopSellPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGShopSellPacket& from) {
    CGShopSellPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGShopSellPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGShopSellPacket";
  }
  protected:
  explicit CGShopSellPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // uint32 count = 2;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGShopSellPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGExchangeStartPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGExchangeStartPacket) */ {
 public:
  inline CGExchangeStartPacket() : CGExchangeStartPacket(nullptr) {}
  ~CGExchangeStartPacket() override;
  explicit PROTOBUF_CONSTEXPR CGExchangeStartPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGExchangeStartPacket(const CGExchangeStartPacket& from);
  CGExchangeStartPacket(CGExchangeStartPacket&& from) noexcept
    : CGExchangeStartPacket() {
    *this = ::std::move(from);
  }

  inline CGExchangeStartPacket& operator=(const CGExchangeStartPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGExchangeStartPacket& operator=(CGExchangeStartPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGExchangeStartPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGExchangeStartPacket* internal_default_instance() {
    return reinterpret_cast<const CGExchangeStartPacket*>(
               &_CGExchangeStartPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(CGExchangeStartPacket& a, CGExchangeStartPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGExchangeStartPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGExchangeStartPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGExchangeStartPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGExchangeStartPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGExchangeStartPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGExchangeStartPacket& from) {
    CGExchangeStartPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGExchangeStartPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGExchangeStartPacket";
  }
  protected:
  explicit CGExchangeStartPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOtherVidFieldNumber = 1,
  };
  // uint32 other_vid = 1;
  void clear_other_vid();
  uint32_t other_vid() const;
  void set_other_vid(uint32_t value);
  private:
  uint32_t _internal_other_vid() const;
  void _internal_set_other_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGExchangeStartPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t other_vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGExchangeItemAddPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGExchangeItemAddPacket) */ {
 public:
  inline CGExchangeItemAddPacket() : CGExchangeItemAddPacket(nullptr) {}
  ~CGExchangeItemAddPacket() override;
  explicit PROTOBUF_CONSTEXPR CGExchangeItemAddPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGExchangeItemAddPacket(const CGExchangeItemAddPacket& from);
  CGExchangeItemAddPacket(CGExchangeItemAddPacket&& from) noexcept
    : CGExchangeItemAddPacket() {
    *this = ::std::move(from);
  }

  inline CGExchangeItemAddPacket& operator=(const CGExchangeItemAddPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGExchangeItemAddPacket& operator=(CGExchangeItemAddPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGExchangeItemAddPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGExchangeItemAddPacket* internal_default_instance() {
    return reinterpret_cast<const CGExchangeItemAddPacket*>(
               &_CGExchangeItemAddPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(CGExchangeItemAddPacket& a, CGExchangeItemAddPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGExchangeItemAddPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGExchangeItemAddPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGExchangeItemAddPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGExchangeItemAddPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGExchangeItemAddPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGExchangeItemAddPacket& from) {
    CGExchangeItemAddPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGExchangeItemAddPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGExchangeItemAddPacket";
  }
  protected:
  explicit CGExchangeItemAddPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kDisplayPosFieldNumber = 2,
  };
  // .network.TItemPos cell = 1;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::network::TItemPos& cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_cell();
  ::network::TItemPos* mutable_cell();
  void set_allocated_cell(::network::TItemPos* cell);
  private:
  const ::network::TItemPos& _internal_cell() const;
  ::network::TItemPos* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::network::TItemPos* cell);
  ::network::TItemPos* unsafe_arena_release_cell();

  // uint32 display_pos = 2;
  void clear_display_pos();
  uint32_t display_pos() const;
  void set_display_pos(uint32_t value);
  private:
  uint32_t _internal_display_pos() const;
  void _internal_set_display_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGExchangeItemAddPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* cell_;
    uint32_t display_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGExchangeItemDelPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGExchangeItemDelPacket) */ {
 public:
  inline CGExchangeItemDelPacket() : CGExchangeItemDelPacket(nullptr) {}
  ~CGExchangeItemDelPacket() override;
  explicit PROTOBUF_CONSTEXPR CGExchangeItemDelPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGExchangeItemDelPacket(const CGExchangeItemDelPacket& from);
  CGExchangeItemDelPacket(CGExchangeItemDelPacket&& from) noexcept
    : CGExchangeItemDelPacket() {
    *this = ::std::move(from);
  }

  inline CGExchangeItemDelPacket& operator=(const CGExchangeItemDelPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGExchangeItemDelPacket& operator=(CGExchangeItemDelPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGExchangeItemDelPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGExchangeItemDelPacket* internal_default_instance() {
    return reinterpret_cast<const CGExchangeItemDelPacket*>(
               &_CGExchangeItemDelPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(CGExchangeItemDelPacket& a, CGExchangeItemDelPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGExchangeItemDelPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGExchangeItemDelPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGExchangeItemDelPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGExchangeItemDelPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGExchangeItemDelPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGExchangeItemDelPacket& from) {
    CGExchangeItemDelPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGExchangeItemDelPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGExchangeItemDelPacket";
  }
  protected:
  explicit CGExchangeItemDelPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayPosFieldNumber = 1,
  };
  // uint32 display_pos = 1;
  void clear_display_pos();
  uint32_t display_pos() const;
  void set_display_pos(uint32_t value);
  private:
  uint32_t _internal_display_pos() const;
  void _internal_set_display_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGExchangeItemDelPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t display_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGExchangeGoldAddPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGExchangeGoldAddPacket) */ {
 public:
  inline CGExchangeGoldAddPacket() : CGExchangeGoldAddPacket(nullptr) {}
  ~CGExchangeGoldAddPacket() override;
  explicit PROTOBUF_CONSTEXPR CGExchangeGoldAddPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGExchangeGoldAddPacket(const CGExchangeGoldAddPacket& from);
  CGExchangeGoldAddPacket(CGExchangeGoldAddPacket&& from) noexcept
    : CGExchangeGoldAddPacket() {
    *this = ::std::move(from);
  }

  inline CGExchangeGoldAddPacket& operator=(const CGExchangeGoldAddPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGExchangeGoldAddPacket& operator=(CGExchangeGoldAddPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGExchangeGoldAddPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGExchangeGoldAddPacket* internal_default_instance() {
    return reinterpret_cast<const CGExchangeGoldAddPacket*>(
               &_CGExchangeGoldAddPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(CGExchangeGoldAddPacket& a, CGExchangeGoldAddPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGExchangeGoldAddPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGExchangeGoldAddPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGExchangeGoldAddPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGExchangeGoldAddPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGExchangeGoldAddPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGExchangeGoldAddPacket& from) {
    CGExchangeGoldAddPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGExchangeGoldAddPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGExchangeGoldAddPacket";
  }
  protected:
  explicit CGExchangeGoldAddPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoldFieldNumber = 1,
  };
  // uint64 gold = 1;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGExchangeGoldAddPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMessengerAddByVIDPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMessengerAddByVIDPacket) */ {
 public:
  inline CGMessengerAddByVIDPacket() : CGMessengerAddByVIDPacket(nullptr) {}
  ~CGMessengerAddByVIDPacket() override;
  explicit PROTOBUF_CONSTEXPR CGMessengerAddByVIDPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMessengerAddByVIDPacket(const CGMessengerAddByVIDPacket& from);
  CGMessengerAddByVIDPacket(CGMessengerAddByVIDPacket&& from) noexcept
    : CGMessengerAddByVIDPacket() {
    *this = ::std::move(from);
  }

  inline CGMessengerAddByVIDPacket& operator=(const CGMessengerAddByVIDPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMessengerAddByVIDPacket& operator=(CGMessengerAddByVIDPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMessengerAddByVIDPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMessengerAddByVIDPacket* internal_default_instance() {
    return reinterpret_cast<const CGMessengerAddByVIDPacket*>(
               &_CGMessengerAddByVIDPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(CGMessengerAddByVIDPacket& a, CGMessengerAddByVIDPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMessengerAddByVIDPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMessengerAddByVIDPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMessengerAddByVIDPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMessengerAddByVIDPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMessengerAddByVIDPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMessengerAddByVIDPacket& from) {
    CGMessengerAddByVIDPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMessengerAddByVIDPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMessengerAddByVIDPacket";
  }
  protected:
  explicit CGMessengerAddByVIDPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVidFieldNumber = 1,
  };
  // uint32 vid = 1;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGMessengerAddByVIDPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMessengerAddByNamePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMessengerAddByNamePacket) */ {
 public:
  inline CGMessengerAddByNamePacket() : CGMessengerAddByNamePacket(nullptr) {}
  ~CGMessengerAddByNamePacket() override;
  explicit PROTOBUF_CONSTEXPR CGMessengerAddByNamePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMessengerAddByNamePacket(const CGMessengerAddByNamePacket& from);
  CGMessengerAddByNamePacket(CGMessengerAddByNamePacket&& from) noexcept
    : CGMessengerAddByNamePacket() {
    *this = ::std::move(from);
  }

  inline CGMessengerAddByNamePacket& operator=(const CGMessengerAddByNamePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMessengerAddByNamePacket& operator=(CGMessengerAddByNamePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMessengerAddByNamePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMessengerAddByNamePacket* internal_default_instance() {
    return reinterpret_cast<const CGMessengerAddByNamePacket*>(
               &_CGMessengerAddByNamePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(CGMessengerAddByNamePacket& a, CGMessengerAddByNamePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMessengerAddByNamePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMessengerAddByNamePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMessengerAddByNamePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMessengerAddByNamePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMessengerAddByNamePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMessengerAddByNamePacket& from) {
    CGMessengerAddByNamePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMessengerAddByNamePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMessengerAddByNamePacket";
  }
  protected:
  explicit CGMessengerAddByNamePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:network.CGMessengerAddByNamePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMessengerRemovePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMessengerRemovePacket) */ {
 public:
  inline CGMessengerRemovePacket() : CGMessengerRemovePacket(nullptr) {}
  ~CGMessengerRemovePacket() override;
  explicit PROTOBUF_CONSTEXPR CGMessengerRemovePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMessengerRemovePacket(const CGMessengerRemovePacket& from);
  CGMessengerRemovePacket(CGMessengerRemovePacket&& from) noexcept
    : CGMessengerRemovePacket() {
    *this = ::std::move(from);
  }

  inline CGMessengerRemovePacket& operator=(const CGMessengerRemovePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMessengerRemovePacket& operator=(CGMessengerRemovePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMessengerRemovePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMessengerRemovePacket* internal_default_instance() {
    return reinterpret_cast<const CGMessengerRemovePacket*>(
               &_CGMessengerRemovePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(CGMessengerRemovePacket& a, CGMessengerRemovePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMessengerRemovePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMessengerRemovePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMessengerRemovePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMessengerRemovePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMessengerRemovePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMessengerRemovePacket& from) {
    CGMessengerRemovePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMessengerRemovePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMessengerRemovePacket";
  }
  protected:
  explicit CGMessengerRemovePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:network.CGMessengerRemovePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMessengerAddBlockByVIDPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMessengerAddBlockByVIDPacket) */ {
 public:
  inline CGMessengerAddBlockByVIDPacket() : CGMessengerAddBlockByVIDPacket(nullptr) {}
  ~CGMessengerAddBlockByVIDPacket() override;
  explicit PROTOBUF_CONSTEXPR CGMessengerAddBlockByVIDPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMessengerAddBlockByVIDPacket(const CGMessengerAddBlockByVIDPacket& from);
  CGMessengerAddBlockByVIDPacket(CGMessengerAddBlockByVIDPacket&& from) noexcept
    : CGMessengerAddBlockByVIDPacket() {
    *this = ::std::move(from);
  }

  inline CGMessengerAddBlockByVIDPacket& operator=(const CGMessengerAddBlockByVIDPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMessengerAddBlockByVIDPacket& operator=(CGMessengerAddBlockByVIDPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMessengerAddBlockByVIDPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMessengerAddBlockByVIDPacket* internal_default_instance() {
    return reinterpret_cast<const CGMessengerAddBlockByVIDPacket*>(
               &_CGMessengerAddBlockByVIDPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(CGMessengerAddBlockByVIDPacket& a, CGMessengerAddBlockByVIDPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMessengerAddBlockByVIDPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMessengerAddBlockByVIDPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMessengerAddBlockByVIDPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMessengerAddBlockByVIDPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMessengerAddBlockByVIDPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMessengerAddBlockByVIDPacket& from) {
    CGMessengerAddBlockByVIDPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMessengerAddBlockByVIDPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMessengerAddBlockByVIDPacket";
  }
  protected:
  explicit CGMessengerAddBlockByVIDPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVidFieldNumber = 1,
  };
  // uint32 vid = 1;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGMessengerAddBlockByVIDPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMessengerAddBlockByNamePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMessengerAddBlockByNamePacket) */ {
 public:
  inline CGMessengerAddBlockByNamePacket() : CGMessengerAddBlockByNamePacket(nullptr) {}
  ~CGMessengerAddBlockByNamePacket() override;
  explicit PROTOBUF_CONSTEXPR CGMessengerAddBlockByNamePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMessengerAddBlockByNamePacket(const CGMessengerAddBlockByNamePacket& from);
  CGMessengerAddBlockByNamePacket(CGMessengerAddBlockByNamePacket&& from) noexcept
    : CGMessengerAddBlockByNamePacket() {
    *this = ::std::move(from);
  }

  inline CGMessengerAddBlockByNamePacket& operator=(const CGMessengerAddBlockByNamePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMessengerAddBlockByNamePacket& operator=(CGMessengerAddBlockByNamePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMessengerAddBlockByNamePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMessengerAddBlockByNamePacket* internal_default_instance() {
    return reinterpret_cast<const CGMessengerAddBlockByNamePacket*>(
               &_CGMessengerAddBlockByNamePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(CGMessengerAddBlockByNamePacket& a, CGMessengerAddBlockByNamePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMessengerAddBlockByNamePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMessengerAddBlockByNamePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMessengerAddBlockByNamePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMessengerAddBlockByNamePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMessengerAddBlockByNamePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMessengerAddBlockByNamePacket& from) {
    CGMessengerAddBlockByNamePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMessengerAddBlockByNamePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMessengerAddBlockByNamePacket";
  }
  protected:
  explicit CGMessengerAddBlockByNamePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:network.CGMessengerAddBlockByNamePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGMessengerRemoveBlockPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGMessengerRemoveBlockPacket) */ {
 public:
  inline CGMessengerRemoveBlockPacket() : CGMessengerRemoveBlockPacket(nullptr) {}
  ~CGMessengerRemoveBlockPacket() override;
  explicit PROTOBUF_CONSTEXPR CGMessengerRemoveBlockPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGMessengerRemoveBlockPacket(const CGMessengerRemoveBlockPacket& from);
  CGMessengerRemoveBlockPacket(CGMessengerRemoveBlockPacket&& from) noexcept
    : CGMessengerRemoveBlockPacket() {
    *this = ::std::move(from);
  }

  inline CGMessengerRemoveBlockPacket& operator=(const CGMessengerRemoveBlockPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGMessengerRemoveBlockPacket& operator=(CGMessengerRemoveBlockPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGMessengerRemoveBlockPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGMessengerRemoveBlockPacket* internal_default_instance() {
    return reinterpret_cast<const CGMessengerRemoveBlockPacket*>(
               &_CGMessengerRemoveBlockPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(CGMessengerRemoveBlockPacket& a, CGMessengerRemoveBlockPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGMessengerRemoveBlockPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGMessengerRemoveBlockPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGMessengerRemoveBlockPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGMessengerRemoveBlockPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGMessengerRemoveBlockPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGMessengerRemoveBlockPacket& from) {
    CGMessengerRemoveBlockPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGMessengerRemoveBlockPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGMessengerRemoveBlockPacket";
  }
  protected:
  explicit CGMessengerRemoveBlockPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:network.CGMessengerRemoveBlockPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPartyInvitePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPartyInvitePacket) */ {
 public:
  inline CGPartyInvitePacket() : CGPartyInvitePacket(nullptr) {}
  ~CGPartyInvitePacket() override;
  explicit PROTOBUF_CONSTEXPR CGPartyInvitePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPartyInvitePacket(const CGPartyInvitePacket& from);
  CGPartyInvitePacket(CGPartyInvitePacket&& from) noexcept
    : CGPartyInvitePacket() {
    *this = ::std::move(from);
  }

  inline CGPartyInvitePacket& operator=(const CGPartyInvitePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPartyInvitePacket& operator=(CGPartyInvitePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPartyInvitePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPartyInvitePacket* internal_default_instance() {
    return reinterpret_cast<const CGPartyInvitePacket*>(
               &_CGPartyInvitePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(CGPartyInvitePacket& a, CGPartyInvitePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPartyInvitePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPartyInvitePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPartyInvitePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPartyInvitePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPartyInvitePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPartyInvitePacket& from) {
    CGPartyInvitePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPartyInvitePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPartyInvitePacket";
  }
  protected:
  explicit CGPartyInvitePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVidFieldNumber = 1,
  };
  // uint32 vid = 1;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPartyInvitePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPartyInviteAnswerPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPartyInviteAnswerPacket) */ {
 public:
  inline CGPartyInviteAnswerPacket() : CGPartyInviteAnswerPacket(nullptr) {}
  ~CGPartyInviteAnswerPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPartyInviteAnswerPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPartyInviteAnswerPacket(const CGPartyInviteAnswerPacket& from);
  CGPartyInviteAnswerPacket(CGPartyInviteAnswerPacket&& from) noexcept
    : CGPartyInviteAnswerPacket() {
    *this = ::std::move(from);
  }

  inline CGPartyInviteAnswerPacket& operator=(const CGPartyInviteAnswerPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPartyInviteAnswerPacket& operator=(CGPartyInviteAnswerPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPartyInviteAnswerPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPartyInviteAnswerPacket* internal_default_instance() {
    return reinterpret_cast<const CGPartyInviteAnswerPacket*>(
               &_CGPartyInviteAnswerPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(CGPartyInviteAnswerPacket& a, CGPartyInviteAnswerPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPartyInviteAnswerPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPartyInviteAnswerPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPartyInviteAnswerPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPartyInviteAnswerPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPartyInviteAnswerPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPartyInviteAnswerPacket& from) {
    CGPartyInviteAnswerPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPartyInviteAnswerPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPartyInviteAnswerPacket";
  }
  protected:
  explicit CGPartyInviteAnswerPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderVidFieldNumber = 1,
    kAcceptFieldNumber = 2,
  };
  // uint32 leader_vid = 1;
  void clear_leader_vid();
  uint32_t leader_vid() const;
  void set_leader_vid(uint32_t value);
  private:
  uint32_t _internal_leader_vid() const;
  void _internal_set_leader_vid(uint32_t value);
  public:

  // bool accept = 2;
  void clear_accept();
  bool accept() const;
  void set_accept(bool value);
  private:
  bool _internal_accept() const;
  void _internal_set_accept(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPartyInviteAnswerPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t leader_vid_;
    bool accept_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPartyRemovePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPartyRemovePacket) */ {
 public:
  inline CGPartyRemovePacket() : CGPartyRemovePacket(nullptr) {}
  ~CGPartyRemovePacket() override;
  explicit PROTOBUF_CONSTEXPR CGPartyRemovePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPartyRemovePacket(const CGPartyRemovePacket& from);
  CGPartyRemovePacket(CGPartyRemovePacket&& from) noexcept
    : CGPartyRemovePacket() {
    *this = ::std::move(from);
  }

  inline CGPartyRemovePacket& operator=(const CGPartyRemovePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPartyRemovePacket& operator=(CGPartyRemovePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPartyRemovePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPartyRemovePacket* internal_default_instance() {
    return reinterpret_cast<const CGPartyRemovePacket*>(
               &_CGPartyRemovePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(CGPartyRemovePacket& a, CGPartyRemovePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPartyRemovePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPartyRemovePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPartyRemovePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPartyRemovePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPartyRemovePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPartyRemovePacket& from) {
    CGPartyRemovePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPartyRemovePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPartyRemovePacket";
  }
  protected:
  explicit CGPartyRemovePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // uint32 pid = 1;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPartyRemovePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPartySetStatePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPartySetStatePacket) */ {
 public:
  inline CGPartySetStatePacket() : CGPartySetStatePacket(nullptr) {}
  ~CGPartySetStatePacket() override;
  explicit PROTOBUF_CONSTEXPR CGPartySetStatePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPartySetStatePacket(const CGPartySetStatePacket& from);
  CGPartySetStatePacket(CGPartySetStatePacket&& from) noexcept
    : CGPartySetStatePacket() {
    *this = ::std::move(from);
  }

  inline CGPartySetStatePacket& operator=(const CGPartySetStatePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPartySetStatePacket& operator=(CGPartySetStatePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPartySetStatePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPartySetStatePacket* internal_default_instance() {
    return reinterpret_cast<const CGPartySetStatePacket*>(
               &_CGPartySetStatePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(CGPartySetStatePacket& a, CGPartySetStatePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPartySetStatePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPartySetStatePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPartySetStatePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPartySetStatePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPartySetStatePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPartySetStatePacket& from) {
    CGPartySetStatePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPartySetStatePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPartySetStatePacket";
  }
  protected:
  explicit CGPartySetStatePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kRoleFieldNumber = 2,
    kFlagFieldNumber = 3,
  };
  // uint32 pid = 1;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // uint32 role = 2;
  void clear_role();
  uint32_t role() const;
  void set_role(uint32_t value);
  private:
  uint32_t _internal_role() const;
  void _internal_set_role(uint32_t value);
  public:

  // bool flag = 3;
  void clear_flag();
  bool flag() const;
  void set_flag(bool value);
  private:
  bool _internal_flag() const;
  void _internal_set_flag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPartySetStatePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pid_;
    uint32_t role_;
    bool flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPartyUseSkillPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPartyUseSkillPacket) */ {
 public:
  inline CGPartyUseSkillPacket() : CGPartyUseSkillPacket(nullptr) {}
  ~CGPartyUseSkillPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPartyUseSkillPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPartyUseSkillPacket(const CGPartyUseSkillPacket& from);
  CGPartyUseSkillPacket(CGPartyUseSkillPacket&& from) noexcept
    : CGPartyUseSkillPacket() {
    *this = ::std::move(from);
  }

  inline CGPartyUseSkillPacket& operator=(const CGPartyUseSkillPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPartyUseSkillPacket& operator=(CGPartyUseSkillPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPartyUseSkillPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPartyUseSkillPacket* internal_default_instance() {
    return reinterpret_cast<const CGPartyUseSkillPacket*>(
               &_CGPartyUseSkillPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(CGPartyUseSkillPacket& a, CGPartyUseSkillPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPartyUseSkillPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPartyUseSkillPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPartyUseSkillPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPartyUseSkillPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPartyUseSkillPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPartyUseSkillPacket& from) {
    CGPartyUseSkillPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPartyUseSkillPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPartyUseSkillPacket";
  }
  protected:
  explicit CGPartyUseSkillPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillIndexFieldNumber = 1,
    kVidFieldNumber = 2,
  };
  // uint32 skill_index = 1;
  void clear_skill_index();
  uint32_t skill_index() const;
  void set_skill_index(uint32_t value);
  private:
  uint32_t _internal_skill_index() const;
  void _internal_set_skill_index(uint32_t value);
  public:

  // uint32 vid = 2;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPartyUseSkillPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t skill_index_;
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPartyParameterPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPartyParameterPacket) */ {
 public:
  inline CGPartyParameterPacket() : CGPartyParameterPacket(nullptr) {}
  ~CGPartyParameterPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPartyParameterPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPartyParameterPacket(const CGPartyParameterPacket& from);
  CGPartyParameterPacket(CGPartyParameterPacket&& from) noexcept
    : CGPartyParameterPacket() {
    *this = ::std::move(from);
  }

  inline CGPartyParameterPacket& operator=(const CGPartyParameterPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPartyParameterPacket& operator=(CGPartyParameterPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPartyParameterPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPartyParameterPacket* internal_default_instance() {
    return reinterpret_cast<const CGPartyParameterPacket*>(
               &_CGPartyParameterPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(CGPartyParameterPacket& a, CGPartyParameterPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPartyParameterPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPartyParameterPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPartyParameterPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPartyParameterPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPartyParameterPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPartyParameterPacket& from) {
    CGPartyParameterPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPartyParameterPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPartyParameterPacket";
  }
  protected:
  explicit CGPartyParameterPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistributeModeFieldNumber = 1,
  };
  // uint32 distribute_mode = 1;
  void clear_distribute_mode();
  uint32_t distribute_mode() const;
  void set_distribute_mode(uint32_t value);
  private:
  uint32_t _internal_distribute_mode() const;
  void _internal_set_distribute_mode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPartyParameterPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t distribute_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildDepositMoneyPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildDepositMoneyPacket) */ {
 public:
  inline CGGuildDepositMoneyPacket() : CGGuildDepositMoneyPacket(nullptr) {}
  ~CGGuildDepositMoneyPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildDepositMoneyPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildDepositMoneyPacket(const CGGuildDepositMoneyPacket& from);
  CGGuildDepositMoneyPacket(CGGuildDepositMoneyPacket&& from) noexcept
    : CGGuildDepositMoneyPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildDepositMoneyPacket& operator=(const CGGuildDepositMoneyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildDepositMoneyPacket& operator=(CGGuildDepositMoneyPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildDepositMoneyPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildDepositMoneyPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildDepositMoneyPacket*>(
               &_CGGuildDepositMoneyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(CGGuildDepositMoneyPacket& a, CGGuildDepositMoneyPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildDepositMoneyPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildDepositMoneyPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildDepositMoneyPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildDepositMoneyPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildDepositMoneyPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildDepositMoneyPacket& from) {
    CGGuildDepositMoneyPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildDepositMoneyPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildDepositMoneyPacket";
  }
  protected:
  explicit CGGuildDepositMoneyPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoldFieldNumber = 1,
  };
  // uint32 gold = 1;
  void clear_gold();
  uint32_t gold() const;
  void set_gold(uint32_t value);
  private:
  uint32_t _internal_gold() const;
  void _internal_set_gold(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildDepositMoneyPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildWithdrawMoneyPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildWithdrawMoneyPacket) */ {
 public:
  inline CGGuildWithdrawMoneyPacket() : CGGuildWithdrawMoneyPacket(nullptr) {}
  ~CGGuildWithdrawMoneyPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildWithdrawMoneyPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildWithdrawMoneyPacket(const CGGuildWithdrawMoneyPacket& from);
  CGGuildWithdrawMoneyPacket(CGGuildWithdrawMoneyPacket&& from) noexcept
    : CGGuildWithdrawMoneyPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildWithdrawMoneyPacket& operator=(const CGGuildWithdrawMoneyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildWithdrawMoneyPacket& operator=(CGGuildWithdrawMoneyPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildWithdrawMoneyPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildWithdrawMoneyPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildWithdrawMoneyPacket*>(
               &_CGGuildWithdrawMoneyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(CGGuildWithdrawMoneyPacket& a, CGGuildWithdrawMoneyPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildWithdrawMoneyPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildWithdrawMoneyPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildWithdrawMoneyPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildWithdrawMoneyPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildWithdrawMoneyPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildWithdrawMoneyPacket& from) {
    CGGuildWithdrawMoneyPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildWithdrawMoneyPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildWithdrawMoneyPacket";
  }
  protected:
  explicit CGGuildWithdrawMoneyPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoldFieldNumber = 1,
  };
  // uint32 gold = 1;
  void clear_gold();
  uint32_t gold() const;
  void set_gold(uint32_t value);
  private:
  uint32_t _internal_gold() const;
  void _internal_set_gold(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildWithdrawMoneyPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildAddMemberPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildAddMemberPacket) */ {
 public:
  inline CGGuildAddMemberPacket() : CGGuildAddMemberPacket(nullptr) {}
  ~CGGuildAddMemberPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildAddMemberPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildAddMemberPacket(const CGGuildAddMemberPacket& from);
  CGGuildAddMemberPacket(CGGuildAddMemberPacket&& from) noexcept
    : CGGuildAddMemberPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildAddMemberPacket& operator=(const CGGuildAddMemberPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildAddMemberPacket& operator=(CGGuildAddMemberPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildAddMemberPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildAddMemberPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildAddMemberPacket*>(
               &_CGGuildAddMemberPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(CGGuildAddMemberPacket& a, CGGuildAddMemberPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildAddMemberPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildAddMemberPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildAddMemberPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildAddMemberPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildAddMemberPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildAddMemberPacket& from) {
    CGGuildAddMemberPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildAddMemberPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildAddMemberPacket";
  }
  protected:
  explicit CGGuildAddMemberPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVidFieldNumber = 1,
  };
  // uint32 vid = 1;
  void clear_vid();
  uint32_t vid() const;
  void set_vid(uint32_t value);
  private:
  uint32_t _internal_vid() const;
  void _internal_set_vid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildAddMemberPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildRemoveMemberPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildRemoveMemberPacket) */ {
 public:
  inline CGGuildRemoveMemberPacket() : CGGuildRemoveMemberPacket(nullptr) {}
  ~CGGuildRemoveMemberPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildRemoveMemberPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildRemoveMemberPacket(const CGGuildRemoveMemberPacket& from);
  CGGuildRemoveMemberPacket(CGGuildRemoveMemberPacket&& from) noexcept
    : CGGuildRemoveMemberPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildRemoveMemberPacket& operator=(const CGGuildRemoveMemberPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildRemoveMemberPacket& operator=(CGGuildRemoveMemberPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildRemoveMemberPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildRemoveMemberPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildRemoveMemberPacket*>(
               &_CGGuildRemoveMemberPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(CGGuildRemoveMemberPacket& a, CGGuildRemoveMemberPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildRemoveMemberPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildRemoveMemberPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildRemoveMemberPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildRemoveMemberPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildRemoveMemberPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildRemoveMemberPacket& from) {
    CGGuildRemoveMemberPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildRemoveMemberPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildRemoveMemberPacket";
  }
  protected:
  explicit CGGuildRemoveMemberPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // uint32 pid = 1;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildRemoveMemberPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildChangeGradeNamePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildChangeGradeNamePacket) */ {
 public:
  inline CGGuildChangeGradeNamePacket() : CGGuildChangeGradeNamePacket(nullptr) {}
  ~CGGuildChangeGradeNamePacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildChangeGradeNamePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildChangeGradeNamePacket(const CGGuildChangeGradeNamePacket& from);
  CGGuildChangeGradeNamePacket(CGGuildChangeGradeNamePacket&& from) noexcept
    : CGGuildChangeGradeNamePacket() {
    *this = ::std::move(from);
  }

  inline CGGuildChangeGradeNamePacket& operator=(const CGGuildChangeGradeNamePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildChangeGradeNamePacket& operator=(CGGuildChangeGradeNamePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildChangeGradeNamePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildChangeGradeNamePacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildChangeGradeNamePacket*>(
               &_CGGuildChangeGradeNamePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(CGGuildChangeGradeNamePacket& a, CGGuildChangeGradeNamePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildChangeGradeNamePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildChangeGradeNamePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildChangeGradeNamePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildChangeGradeNamePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildChangeGradeNamePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildChangeGradeNamePacket& from) {
    CGGuildChangeGradeNamePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildChangeGradeNamePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildChangeGradeNamePacket";
  }
  protected:
  explicit CGGuildChangeGradeNamePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradenameFieldNumber = 2,
    kGradeFieldNumber = 1,
  };
  // bytes gradename = 2;
  void clear_gradename();
  const std::string& gradename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gradename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gradename();
  PROTOBUF_NODISCARD std::string* release_gradename();
  void set_allocated_gradename(std::string* gradename);
  private:
  const std::string& _internal_gradename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gradename(const std::string& value);
  std::string* _internal_mutable_gradename();
  public:

  // uint32 grade = 1;
  void clear_grade();
  uint32_t grade() const;
  void set_grade(uint32_t value);
  private:
  uint32_t _internal_grade() const;
  void _internal_set_grade(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildChangeGradeNamePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gradename_;
    uint32_t grade_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildChangeGradeAuthorityPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildChangeGradeAuthorityPacket) */ {
 public:
  inline CGGuildChangeGradeAuthorityPacket() : CGGuildChangeGradeAuthorityPacket(nullptr) {}
  ~CGGuildChangeGradeAuthorityPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildChangeGradeAuthorityPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildChangeGradeAuthorityPacket(const CGGuildChangeGradeAuthorityPacket& from);
  CGGuildChangeGradeAuthorityPacket(CGGuildChangeGradeAuthorityPacket&& from) noexcept
    : CGGuildChangeGradeAuthorityPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildChangeGradeAuthorityPacket& operator=(const CGGuildChangeGradeAuthorityPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildChangeGradeAuthorityPacket& operator=(CGGuildChangeGradeAuthorityPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildChangeGradeAuthorityPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildChangeGradeAuthorityPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildChangeGradeAuthorityPacket*>(
               &_CGGuildChangeGradeAuthorityPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(CGGuildChangeGradeAuthorityPacket& a, CGGuildChangeGradeAuthorityPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildChangeGradeAuthorityPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildChangeGradeAuthorityPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildChangeGradeAuthorityPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildChangeGradeAuthorityPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildChangeGradeAuthorityPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildChangeGradeAuthorityPacket& from) {
    CGGuildChangeGradeAuthorityPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildChangeGradeAuthorityPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildChangeGradeAuthorityPacket";
  }
  protected:
  explicit CGGuildChangeGradeAuthorityPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradeFieldNumber = 1,
    kAuthorityFieldNumber = 2,
  };
  // uint32 grade = 1;
  void clear_grade();
  uint32_t grade() const;
  void set_grade(uint32_t value);
  private:
  uint32_t _internal_grade() const;
  void _internal_set_grade(uint32_t value);
  public:

  // uint32 authority = 2;
  void clear_authority();
  uint32_t authority() const;
  void set_authority(uint32_t value);
  private:
  uint32_t _internal_authority() const;
  void _internal_set_authority(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildChangeGradeAuthorityPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t grade_;
    uint32_t authority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildOfferExpPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildOfferExpPacket) */ {
 public:
  inline CGGuildOfferExpPacket() : CGGuildOfferExpPacket(nullptr) {}
  ~CGGuildOfferExpPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildOfferExpPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildOfferExpPacket(const CGGuildOfferExpPacket& from);
  CGGuildOfferExpPacket(CGGuildOfferExpPacket&& from) noexcept
    : CGGuildOfferExpPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildOfferExpPacket& operator=(const CGGuildOfferExpPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildOfferExpPacket& operator=(CGGuildOfferExpPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildOfferExpPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildOfferExpPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildOfferExpPacket*>(
               &_CGGuildOfferExpPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(CGGuildOfferExpPacket& a, CGGuildOfferExpPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildOfferExpPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildOfferExpPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildOfferExpPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildOfferExpPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildOfferExpPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildOfferExpPacket& from) {
    CGGuildOfferExpPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildOfferExpPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildOfferExpPacket";
  }
  protected:
  explicit CGGuildOfferExpPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpFieldNumber = 1,
  };
  // uint32 exp = 1;
  void clear_exp();
  uint32_t exp() const;
  void set_exp(uint32_t value);
  private:
  uint32_t _internal_exp() const;
  void _internal_set_exp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildOfferExpPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t exp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildChargeGSPPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildChargeGSPPacket) */ {
 public:
  inline CGGuildChargeGSPPacket() : CGGuildChargeGSPPacket(nullptr) {}
  ~CGGuildChargeGSPPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildChargeGSPPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildChargeGSPPacket(const CGGuildChargeGSPPacket& from);
  CGGuildChargeGSPPacket(CGGuildChargeGSPPacket&& from) noexcept
    : CGGuildChargeGSPPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildChargeGSPPacket& operator=(const CGGuildChargeGSPPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildChargeGSPPacket& operator=(CGGuildChargeGSPPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildChargeGSPPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildChargeGSPPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildChargeGSPPacket*>(
               &_CGGuildChargeGSPPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(CGGuildChargeGSPPacket& a, CGGuildChargeGSPPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildChargeGSPPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildChargeGSPPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildChargeGSPPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildChargeGSPPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildChargeGSPPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildChargeGSPPacket& from) {
    CGGuildChargeGSPPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildChargeGSPPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildChargeGSPPacket";
  }
  protected:
  explicit CGGuildChargeGSPPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 1,
  };
  // uint32 amount = 1;
  void clear_amount();
  uint32_t amount() const;
  void set_amount(uint32_t value);
  private:
  uint32_t _internal_amount() const;
  void _internal_set_amount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildChargeGSPPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildPostCommentPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildPostCommentPacket) */ {
 public:
  inline CGGuildPostCommentPacket() : CGGuildPostCommentPacket(nullptr) {}
  ~CGGuildPostCommentPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildPostCommentPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildPostCommentPacket(const CGGuildPostCommentPacket& from);
  CGGuildPostCommentPacket(CGGuildPostCommentPacket&& from) noexcept
    : CGGuildPostCommentPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildPostCommentPacket& operator=(const CGGuildPostCommentPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildPostCommentPacket& operator=(CGGuildPostCommentPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildPostCommentPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildPostCommentPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildPostCommentPacket*>(
               &_CGGuildPostCommentPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(CGGuildPostCommentPacket& a, CGGuildPostCommentPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildPostCommentPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildPostCommentPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildPostCommentPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildPostCommentPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildPostCommentPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildPostCommentPacket& from) {
    CGGuildPostCommentPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildPostCommentPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildPostCommentPacket";
  }
  protected:
  explicit CGGuildPostCommentPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // bytes message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildPostCommentPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildDeleteCommentPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildDeleteCommentPacket) */ {
 public:
  inline CGGuildDeleteCommentPacket() : CGGuildDeleteCommentPacket(nullptr) {}
  ~CGGuildDeleteCommentPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildDeleteCommentPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildDeleteCommentPacket(const CGGuildDeleteCommentPacket& from);
  CGGuildDeleteCommentPacket(CGGuildDeleteCommentPacket&& from) noexcept
    : CGGuildDeleteCommentPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildDeleteCommentPacket& operator=(const CGGuildDeleteCommentPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildDeleteCommentPacket& operator=(CGGuildDeleteCommentPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildDeleteCommentPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildDeleteCommentPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildDeleteCommentPacket*>(
               &_CGGuildDeleteCommentPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(CGGuildDeleteCommentPacket& a, CGGuildDeleteCommentPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildDeleteCommentPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildDeleteCommentPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildDeleteCommentPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildDeleteCommentPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildDeleteCommentPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildDeleteCommentPacket& from) {
    CGGuildDeleteCommentPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildDeleteCommentPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildDeleteCommentPacket";
  }
  protected:
  explicit CGGuildDeleteCommentPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommentIdFieldNumber = 1,
  };
  // uint32 comment_id = 1;
  void clear_comment_id();
  uint32_t comment_id() const;
  void set_comment_id(uint32_t value);
  private:
  uint32_t _internal_comment_id() const;
  void _internal_set_comment_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildDeleteCommentPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t comment_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildChangeMemberGradePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildChangeMemberGradePacket) */ {
 public:
  inline CGGuildChangeMemberGradePacket() : CGGuildChangeMemberGradePacket(nullptr) {}
  ~CGGuildChangeMemberGradePacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildChangeMemberGradePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildChangeMemberGradePacket(const CGGuildChangeMemberGradePacket& from);
  CGGuildChangeMemberGradePacket(CGGuildChangeMemberGradePacket&& from) noexcept
    : CGGuildChangeMemberGradePacket() {
    *this = ::std::move(from);
  }

  inline CGGuildChangeMemberGradePacket& operator=(const CGGuildChangeMemberGradePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildChangeMemberGradePacket& operator=(CGGuildChangeMemberGradePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildChangeMemberGradePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildChangeMemberGradePacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildChangeMemberGradePacket*>(
               &_CGGuildChangeMemberGradePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(CGGuildChangeMemberGradePacket& a, CGGuildChangeMemberGradePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildChangeMemberGradePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildChangeMemberGradePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildChangeMemberGradePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildChangeMemberGradePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildChangeMemberGradePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildChangeMemberGradePacket& from) {
    CGGuildChangeMemberGradePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildChangeMemberGradePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildChangeMemberGradePacket";
  }
  protected:
  explicit CGGuildChangeMemberGradePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kGradeFieldNumber = 2,
  };
  // uint32 pid = 1;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // uint32 grade = 2;
  void clear_grade();
  uint32_t grade() const;
  void set_grade(uint32_t value);
  private:
  uint32_t _internal_grade() const;
  void _internal_set_grade(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildChangeMemberGradePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pid_;
    uint32_t grade_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildUseSkillPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildUseSkillPacket) */ {
 public:
  inline CGGuildUseSkillPacket() : CGGuildUseSkillPacket(nullptr) {}
  ~CGGuildUseSkillPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildUseSkillPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildUseSkillPacket(const CGGuildUseSkillPacket& from);
  CGGuildUseSkillPacket(CGGuildUseSkillPacket&& from) noexcept
    : CGGuildUseSkillPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildUseSkillPacket& operator=(const CGGuildUseSkillPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildUseSkillPacket& operator=(CGGuildUseSkillPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildUseSkillPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildUseSkillPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildUseSkillPacket*>(
               &_CGGuildUseSkillPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(CGGuildUseSkillPacket& a, CGGuildUseSkillPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildUseSkillPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildUseSkillPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildUseSkillPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildUseSkillPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildUseSkillPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildUseSkillPacket& from) {
    CGGuildUseSkillPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildUseSkillPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildUseSkillPacket";
  }
  protected:
  explicit CGGuildUseSkillPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVnumFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // uint32 vnum = 1;
  void clear_vnum();
  uint32_t vnum() const;
  void set_vnum(uint32_t value);
  private:
  uint32_t _internal_vnum() const;
  void _internal_set_vnum(uint32_t value);
  public:

  // uint32 pid = 2;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildUseSkillPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t vnum_;
    uint32_t pid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildChangeMemberGeneralPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildChangeMemberGeneralPacket) */ {
 public:
  inline CGGuildChangeMemberGeneralPacket() : CGGuildChangeMemberGeneralPacket(nullptr) {}
  ~CGGuildChangeMemberGeneralPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildChangeMemberGeneralPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildChangeMemberGeneralPacket(const CGGuildChangeMemberGeneralPacket& from);
  CGGuildChangeMemberGeneralPacket(CGGuildChangeMemberGeneralPacket&& from) noexcept
    : CGGuildChangeMemberGeneralPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildChangeMemberGeneralPacket& operator=(const CGGuildChangeMemberGeneralPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildChangeMemberGeneralPacket& operator=(CGGuildChangeMemberGeneralPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildChangeMemberGeneralPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildChangeMemberGeneralPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildChangeMemberGeneralPacket*>(
               &_CGGuildChangeMemberGeneralPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(CGGuildChangeMemberGeneralPacket& a, CGGuildChangeMemberGeneralPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildChangeMemberGeneralPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildChangeMemberGeneralPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildChangeMemberGeneralPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildChangeMemberGeneralPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildChangeMemberGeneralPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildChangeMemberGeneralPacket& from) {
    CGGuildChangeMemberGeneralPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildChangeMemberGeneralPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildChangeMemberGeneralPacket";
  }
  protected:
  explicit CGGuildChangeMemberGeneralPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kIsGeneralFieldNumber = 2,
  };
  // uint32 pid = 1;
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // bool is_general = 2;
  void clear_is_general();
  bool is_general() const;
  void set_is_general(bool value);
  private:
  bool _internal_is_general() const;
  void _internal_set_is_general(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildChangeMemberGeneralPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pid_;
    bool is_general_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildInviteAnswerPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildInviteAnswerPacket) */ {
 public:
  inline CGGuildInviteAnswerPacket() : CGGuildInviteAnswerPacket(nullptr) {}
  ~CGGuildInviteAnswerPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildInviteAnswerPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildInviteAnswerPacket(const CGGuildInviteAnswerPacket& from);
  CGGuildInviteAnswerPacket(CGGuildInviteAnswerPacket&& from) noexcept
    : CGGuildInviteAnswerPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildInviteAnswerPacket& operator=(const CGGuildInviteAnswerPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildInviteAnswerPacket& operator=(CGGuildInviteAnswerPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildInviteAnswerPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildInviteAnswerPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildInviteAnswerPacket*>(
               &_CGGuildInviteAnswerPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(CGGuildInviteAnswerPacket& a, CGGuildInviteAnswerPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildInviteAnswerPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildInviteAnswerPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildInviteAnswerPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildInviteAnswerPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildInviteAnswerPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildInviteAnswerPacket& from) {
    CGGuildInviteAnswerPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildInviteAnswerPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildInviteAnswerPacket";
  }
  protected:
  explicit CGGuildInviteAnswerPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuildIdFieldNumber = 1,
    kAcceptFieldNumber = 2,
  };
  // uint32 guild_id = 1;
  void clear_guild_id();
  uint32_t guild_id() const;
  void set_guild_id(uint32_t value);
  private:
  uint32_t _internal_guild_id() const;
  void _internal_set_guild_id(uint32_t value);
  public:

  // bool accept = 2;
  void clear_accept();
  bool accept() const;
  void set_accept(bool value);
  private:
  bool _internal_accept() const;
  void _internal_set_accept(bool value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildInviteAnswerPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t guild_id_;
    bool accept_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildAnswerMakePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildAnswerMakePacket) */ {
 public:
  inline CGGuildAnswerMakePacket() : CGGuildAnswerMakePacket(nullptr) {}
  ~CGGuildAnswerMakePacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildAnswerMakePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildAnswerMakePacket(const CGGuildAnswerMakePacket& from);
  CGGuildAnswerMakePacket(CGGuildAnswerMakePacket&& from) noexcept
    : CGGuildAnswerMakePacket() {
    *this = ::std::move(from);
  }

  inline CGGuildAnswerMakePacket& operator=(const CGGuildAnswerMakePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildAnswerMakePacket& operator=(CGGuildAnswerMakePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildAnswerMakePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildAnswerMakePacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildAnswerMakePacket*>(
               &_CGGuildAnswerMakePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(CGGuildAnswerMakePacket& a, CGGuildAnswerMakePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildAnswerMakePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildAnswerMakePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildAnswerMakePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildAnswerMakePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildAnswerMakePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildAnswerMakePacket& from) {
    CGGuildAnswerMakePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildAnswerMakePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildAnswerMakePacket";
  }
  protected:
  explicit CGGuildAnswerMakePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuildNameFieldNumber = 1,
  };
  // bytes guild_name = 1;
  void clear_guild_name();
  const std::string& guild_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guild_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guild_name();
  PROTOBUF_NODISCARD std::string* release_guild_name();
  void set_allocated_guild_name(std::string* guild_name);
  private:
  const std::string& _internal_guild_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guild_name(const std::string& value);
  std::string* _internal_mutable_guild_name();
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildAnswerMakePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guild_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildRequestListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildRequestListPacket) */ {
 public:
  inline CGGuildRequestListPacket() : CGGuildRequestListPacket(nullptr) {}
  ~CGGuildRequestListPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildRequestListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildRequestListPacket(const CGGuildRequestListPacket& from);
  CGGuildRequestListPacket(CGGuildRequestListPacket&& from) noexcept
    : CGGuildRequestListPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildRequestListPacket& operator=(const CGGuildRequestListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildRequestListPacket& operator=(CGGuildRequestListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildRequestListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildRequestListPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildRequestListPacket*>(
               &_CGGuildRequestListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(CGGuildRequestListPacket& a, CGGuildRequestListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildRequestListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildRequestListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildRequestListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildRequestListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildRequestListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildRequestListPacket& from) {
    CGGuildRequestListPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildRequestListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildRequestListPacket";
  }
  protected:
  explicit CGGuildRequestListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageNumberFieldNumber = 1,
    kPageTypeFieldNumber = 2,
    kEmpireFieldNumber = 3,
  };
  // uint32 page_number = 1;
  void clear_page_number();
  uint32_t page_number() const;
  void set_page_number(uint32_t value);
  private:
  uint32_t _internal_page_number() const;
  void _internal_set_page_number(uint32_t value);
  public:

  // uint32 page_type = 2;
  void clear_page_type();
  uint32_t page_type() const;
  void set_page_type(uint32_t value);
  private:
  uint32_t _internal_page_type() const;
  void _internal_set_page_type(uint32_t value);
  public:

  // uint32 empire = 3;
  void clear_empire();
  uint32_t empire() const;
  void set_empire(uint32_t value);
  private:
  uint32_t _internal_empire() const;
  void _internal_set_empire(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildRequestListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t page_number_;
    uint32_t page_type_;
    uint32_t empire_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildSearchPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildSearchPacket) */ {
 public:
  inline CGGuildSearchPacket() : CGGuildSearchPacket(nullptr) {}
  ~CGGuildSearchPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildSearchPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildSearchPacket(const CGGuildSearchPacket& from);
  CGGuildSearchPacket(CGGuildSearchPacket&& from) noexcept
    : CGGuildSearchPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildSearchPacket& operator=(const CGGuildSearchPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildSearchPacket& operator=(CGGuildSearchPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildSearchPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildSearchPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildSearchPacket*>(
               &_CGGuildSearchPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(CGGuildSearchPacket& a, CGGuildSearchPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildSearchPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildSearchPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildSearchPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildSearchPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildSearchPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildSearchPacket& from) {
    CGGuildSearchPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildSearchPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildSearchPacket";
  }
  protected:
  explicit CGGuildSearchPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchNameFieldNumber = 1,
    kPageTypeFieldNumber = 2,
    kEmpireFieldNumber = 3,
  };
  // bytes search_name = 1;
  void clear_search_name();
  const std::string& search_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_name();
  PROTOBUF_NODISCARD std::string* release_search_name();
  void set_allocated_search_name(std::string* search_name);
  private:
  const std::string& _internal_search_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_name(const std::string& value);
  std::string* _internal_mutable_search_name();
  public:

  // uint32 page_type = 2;
  void clear_page_type();
  uint32_t page_type() const;
  void set_page_type(uint32_t value);
  private:
  uint32_t _internal_page_type() const;
  void _internal_set_page_type(uint32_t value);
  public:

  // uint32 empire = 3;
  void clear_empire();
  uint32_t empire() const;
  void set_empire(uint32_t value);
  private:
  uint32_t _internal_empire() const;
  void _internal_set_empire(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildSearchPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_name_;
    uint32_t page_type_;
    uint32_t empire_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildSafeboxCheckinPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildSafeboxCheckinPacket) */ {
 public:
  inline CGGuildSafeboxCheckinPacket() : CGGuildSafeboxCheckinPacket(nullptr) {}
  ~CGGuildSafeboxCheckinPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildSafeboxCheckinPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildSafeboxCheckinPacket(const CGGuildSafeboxCheckinPacket& from);
  CGGuildSafeboxCheckinPacket(CGGuildSafeboxCheckinPacket&& from) noexcept
    : CGGuildSafeboxCheckinPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildSafeboxCheckinPacket& operator=(const CGGuildSafeboxCheckinPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildSafeboxCheckinPacket& operator=(CGGuildSafeboxCheckinPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildSafeboxCheckinPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildSafeboxCheckinPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildSafeboxCheckinPacket*>(
               &_CGGuildSafeboxCheckinPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(CGGuildSafeboxCheckinPacket& a, CGGuildSafeboxCheckinPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildSafeboxCheckinPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildSafeboxCheckinPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildSafeboxCheckinPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildSafeboxCheckinPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildSafeboxCheckinPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildSafeboxCheckinPacket& from) {
    CGGuildSafeboxCheckinPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildSafeboxCheckinPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildSafeboxCheckinPacket";
  }
  protected:
  explicit CGGuildSafeboxCheckinPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemPosFieldNumber = 1,
    kSafeboxPosFieldNumber = 2,
  };
  // .network.TItemPos item_pos = 1;
  bool has_item_pos() const;
  private:
  bool _internal_has_item_pos() const;
  public:
  void clear_item_pos();
  const ::network::TItemPos& item_pos() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_item_pos();
  ::network::TItemPos* mutable_item_pos();
  void set_allocated_item_pos(::network::TItemPos* item_pos);
  private:
  const ::network::TItemPos& _internal_item_pos() const;
  ::network::TItemPos* _internal_mutable_item_pos();
  public:
  void unsafe_arena_set_allocated_item_pos(
      ::network::TItemPos* item_pos);
  ::network::TItemPos* unsafe_arena_release_item_pos();

  // uint32 safebox_pos = 2;
  void clear_safebox_pos();
  uint32_t safebox_pos() const;
  void set_safebox_pos(uint32_t value);
  private:
  uint32_t _internal_safebox_pos() const;
  void _internal_set_safebox_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildSafeboxCheckinPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* item_pos_;
    uint32_t safebox_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildSafeboxCheckoutPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildSafeboxCheckoutPacket) */ {
 public:
  inline CGGuildSafeboxCheckoutPacket() : CGGuildSafeboxCheckoutPacket(nullptr) {}
  ~CGGuildSafeboxCheckoutPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildSafeboxCheckoutPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildSafeboxCheckoutPacket(const CGGuildSafeboxCheckoutPacket& from);
  CGGuildSafeboxCheckoutPacket(CGGuildSafeboxCheckoutPacket&& from) noexcept
    : CGGuildSafeboxCheckoutPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildSafeboxCheckoutPacket& operator=(const CGGuildSafeboxCheckoutPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildSafeboxCheckoutPacket& operator=(CGGuildSafeboxCheckoutPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildSafeboxCheckoutPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildSafeboxCheckoutPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildSafeboxCheckoutPacket*>(
               &_CGGuildSafeboxCheckoutPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(CGGuildSafeboxCheckoutPacket& a, CGGuildSafeboxCheckoutPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildSafeboxCheckoutPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildSafeboxCheckoutPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildSafeboxCheckoutPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildSafeboxCheckoutPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildSafeboxCheckoutPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildSafeboxCheckoutPacket& from) {
    CGGuildSafeboxCheckoutPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildSafeboxCheckoutPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildSafeboxCheckoutPacket";
  }
  protected:
  explicit CGGuildSafeboxCheckoutPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemPosFieldNumber = 2,
    kSafeboxPosFieldNumber = 1,
  };
  // .network.TItemPos item_pos = 2;
  bool has_item_pos() const;
  private:
  bool _internal_has_item_pos() const;
  public:
  void clear_item_pos();
  const ::network::TItemPos& item_pos() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_item_pos();
  ::network::TItemPos* mutable_item_pos();
  void set_allocated_item_pos(::network::TItemPos* item_pos);
  private:
  const ::network::TItemPos& _internal_item_pos() const;
  ::network::TItemPos* _internal_mutable_item_pos();
  public:
  void unsafe_arena_set_allocated_item_pos(
      ::network::TItemPos* item_pos);
  ::network::TItemPos* unsafe_arena_release_item_pos();

  // uint32 safebox_pos = 1;
  void clear_safebox_pos();
  uint32_t safebox_pos() const;
  void set_safebox_pos(uint32_t value);
  private:
  uint32_t _internal_safebox_pos() const;
  void _internal_set_safebox_pos(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildSafeboxCheckoutPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* item_pos_;
    uint32_t safebox_pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildSafeboxItemMovePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildSafeboxItemMovePacket) */ {
 public:
  inline CGGuildSafeboxItemMovePacket() : CGGuildSafeboxItemMovePacket(nullptr) {}
  ~CGGuildSafeboxItemMovePacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildSafeboxItemMovePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildSafeboxItemMovePacket(const CGGuildSafeboxItemMovePacket& from);
  CGGuildSafeboxItemMovePacket(CGGuildSafeboxItemMovePacket&& from) noexcept
    : CGGuildSafeboxItemMovePacket() {
    *this = ::std::move(from);
  }

  inline CGGuildSafeboxItemMovePacket& operator=(const CGGuildSafeboxItemMovePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildSafeboxItemMovePacket& operator=(CGGuildSafeboxItemMovePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildSafeboxItemMovePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildSafeboxItemMovePacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildSafeboxItemMovePacket*>(
               &_CGGuildSafeboxItemMovePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(CGGuildSafeboxItemMovePacket& a, CGGuildSafeboxItemMovePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildSafeboxItemMovePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildSafeboxItemMovePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildSafeboxItemMovePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildSafeboxItemMovePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildSafeboxItemMovePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildSafeboxItemMovePacket& from) {
    CGGuildSafeboxItemMovePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildSafeboxItemMovePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildSafeboxItemMovePacket";
  }
  protected:
  explicit CGGuildSafeboxItemMovePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcePosFieldNumber = 1,
    kTargetPosFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // uint32 source_pos = 1;
  void clear_source_pos();
  uint32_t source_pos() const;
  void set_source_pos(uint32_t value);
  private:
  uint32_t _internal_source_pos() const;
  void _internal_set_source_pos(uint32_t value);
  public:

  // uint32 target_pos = 2;
  void clear_target_pos();
  uint32_t target_pos() const;
  void set_target_pos(uint32_t value);
  private:
  uint32_t _internal_target_pos() const;
  void _internal_set_target_pos(uint32_t value);
  public:

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildSafeboxItemMovePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t source_pos_;
    uint32_t target_pos_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildSafeboxGiveGoldPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildSafeboxGiveGoldPacket) */ {
 public:
  inline CGGuildSafeboxGiveGoldPacket() : CGGuildSafeboxGiveGoldPacket(nullptr) {}
  ~CGGuildSafeboxGiveGoldPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildSafeboxGiveGoldPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildSafeboxGiveGoldPacket(const CGGuildSafeboxGiveGoldPacket& from);
  CGGuildSafeboxGiveGoldPacket(CGGuildSafeboxGiveGoldPacket&& from) noexcept
    : CGGuildSafeboxGiveGoldPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildSafeboxGiveGoldPacket& operator=(const CGGuildSafeboxGiveGoldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildSafeboxGiveGoldPacket& operator=(CGGuildSafeboxGiveGoldPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildSafeboxGiveGoldPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildSafeboxGiveGoldPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildSafeboxGiveGoldPacket*>(
               &_CGGuildSafeboxGiveGoldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(CGGuildSafeboxGiveGoldPacket& a, CGGuildSafeboxGiveGoldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildSafeboxGiveGoldPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildSafeboxGiveGoldPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildSafeboxGiveGoldPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildSafeboxGiveGoldPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildSafeboxGiveGoldPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildSafeboxGiveGoldPacket& from) {
    CGGuildSafeboxGiveGoldPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildSafeboxGiveGoldPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildSafeboxGiveGoldPacket";
  }
  protected:
  explicit CGGuildSafeboxGiveGoldPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoldFieldNumber = 1,
  };
  // uint64 gold = 1;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildSafeboxGiveGoldPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGGuildSafeboxGetGoldPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGGuildSafeboxGetGoldPacket) */ {
 public:
  inline CGGuildSafeboxGetGoldPacket() : CGGuildSafeboxGetGoldPacket(nullptr) {}
  ~CGGuildSafeboxGetGoldPacket() override;
  explicit PROTOBUF_CONSTEXPR CGGuildSafeboxGetGoldPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGGuildSafeboxGetGoldPacket(const CGGuildSafeboxGetGoldPacket& from);
  CGGuildSafeboxGetGoldPacket(CGGuildSafeboxGetGoldPacket&& from) noexcept
    : CGGuildSafeboxGetGoldPacket() {
    *this = ::std::move(from);
  }

  inline CGGuildSafeboxGetGoldPacket& operator=(const CGGuildSafeboxGetGoldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGGuildSafeboxGetGoldPacket& operator=(CGGuildSafeboxGetGoldPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGGuildSafeboxGetGoldPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGGuildSafeboxGetGoldPacket* internal_default_instance() {
    return reinterpret_cast<const CGGuildSafeboxGetGoldPacket*>(
               &_CGGuildSafeboxGetGoldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(CGGuildSafeboxGetGoldPacket& a, CGGuildSafeboxGetGoldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGGuildSafeboxGetGoldPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGGuildSafeboxGetGoldPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGGuildSafeboxGetGoldPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGGuildSafeboxGetGoldPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGGuildSafeboxGetGoldPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGGuildSafeboxGetGoldPacket& from) {
    CGGuildSafeboxGetGoldPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGGuildSafeboxGetGoldPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGGuildSafeboxGetGoldPacket";
  }
  protected:
  explicit CGGuildSafeboxGetGoldPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoldFieldNumber = 1,
  };
  // uint64 gold = 1;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGGuildSafeboxGetGoldPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPetUseEggPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPetUseEggPacket) */ {
 public:
  inline CGPetUseEggPacket() : CGPetUseEggPacket(nullptr) {}
  ~CGPetUseEggPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPetUseEggPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPetUseEggPacket(const CGPetUseEggPacket& from);
  CGPetUseEggPacket(CGPetUseEggPacket&& from) noexcept
    : CGPetUseEggPacket() {
    *this = ::std::move(from);
  }

  inline CGPetUseEggPacket& operator=(const CGPetUseEggPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPetUseEggPacket& operator=(CGPetUseEggPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPetUseEggPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPetUseEggPacket* internal_default_instance() {
    return reinterpret_cast<const CGPetUseEggPacket*>(
               &_CGPetUseEggPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(CGPetUseEggPacket& a, CGPetUseEggPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPetUseEggPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPetUseEggPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPetUseEggPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPetUseEggPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPetUseEggPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPetUseEggPacket& from) {
    CGPetUseEggPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPetUseEggPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPetUseEggPacket";
  }
  protected:
  explicit CGPetUseEggPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPetNameFieldNumber = 2,
    kEggCellFieldNumber = 1,
  };
  // string pet_name = 2;
  void clear_pet_name();
  const std::string& pet_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pet_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pet_name();
  PROTOBUF_NODISCARD std::string* release_pet_name();
  void set_allocated_pet_name(std::string* pet_name);
  private:
  const std::string& _internal_pet_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pet_name(const std::string& value);
  std::string* _internal_mutable_pet_name();
  public:

  // .network.TItemPos egg_cell = 1;
  bool has_egg_cell() const;
  private:
  bool _internal_has_egg_cell() const;
  public:
  void clear_egg_cell();
  const ::network::TItemPos& egg_cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_egg_cell();
  ::network::TItemPos* mutable_egg_cell();
  void set_allocated_egg_cell(::network::TItemPos* egg_cell);
  private:
  const ::network::TItemPos& _internal_egg_cell() const;
  ::network::TItemPos* _internal_mutable_egg_cell();
  public:
  void unsafe_arena_set_allocated_egg_cell(
      ::network::TItemPos* egg_cell);
  ::network::TItemPos* unsafe_arena_release_egg_cell();

  // @@protoc_insertion_point(class_scope:network.CGPetUseEggPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pet_name_;
    ::network::TItemPos* egg_cell_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPetResetSkillPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPetResetSkillPacket) */ {
 public:
  inline CGPetResetSkillPacket() : CGPetResetSkillPacket(nullptr) {}
  ~CGPetResetSkillPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPetResetSkillPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPetResetSkillPacket(const CGPetResetSkillPacket& from);
  CGPetResetSkillPacket(CGPetResetSkillPacket&& from) noexcept
    : CGPetResetSkillPacket() {
    *this = ::std::move(from);
  }

  inline CGPetResetSkillPacket& operator=(const CGPetResetSkillPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPetResetSkillPacket& operator=(CGPetResetSkillPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPetResetSkillPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPetResetSkillPacket* internal_default_instance() {
    return reinterpret_cast<const CGPetResetSkillPacket*>(
               &_CGPetResetSkillPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(CGPetResetSkillPacket& a, CGPetResetSkillPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPetResetSkillPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPetResetSkillPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPetResetSkillPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPetResetSkillPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPetResetSkillPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPetResetSkillPacket& from) {
    CGPetResetSkillPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPetResetSkillPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPetResetSkillPacket";
  }
  protected:
  explicit CGPetResetSkillPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResetCellFieldNumber = 1,
    kSkillIndexFieldNumber = 2,
  };
  // .network.TItemPos reset_cell = 1;
  bool has_reset_cell() const;
  private:
  bool _internal_has_reset_cell() const;
  public:
  void clear_reset_cell();
  const ::network::TItemPos& reset_cell() const;
  PROTOBUF_NODISCARD ::network::TItemPos* release_reset_cell();
  ::network::TItemPos* mutable_reset_cell();
  void set_allocated_reset_cell(::network::TItemPos* reset_cell);
  private:
  const ::network::TItemPos& _internal_reset_cell() const;
  ::network::TItemPos* _internal_mutable_reset_cell();
  public:
  void unsafe_arena_set_allocated_reset_cell(
      ::network::TItemPos* reset_cell);
  ::network::TItemPos* unsafe_arena_release_reset_cell();

  // uint32 skill_index = 2;
  void clear_skill_index();
  uint32_t skill_index() const;
  void set_skill_index(uint32_t value);
  private:
  uint32_t _internal_skill_index() const;
  void _internal_set_skill_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPetResetSkillPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::network::TItemPos* reset_cell_;
    uint32_t skill_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPetAttrRefineInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPetAttrRefineInfoPacket) */ {
 public:
  inline CGPetAttrRefineInfoPacket() : CGPetAttrRefineInfoPacket(nullptr) {}
  ~CGPetAttrRefineInfoPacket() override;
  explicit PROTOBUF_CONSTEXPR CGPetAttrRefineInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPetAttrRefineInfoPacket(const CGPetAttrRefineInfoPacket& from);
  CGPetAttrRefineInfoPacket(CGPetAttrRefineInfoPacket&& from) noexcept
    : CGPetAttrRefineInfoPacket() {
    *this = ::std::move(from);
  }

  inline CGPetAttrRefineInfoPacket& operator=(const CGPetAttrRefineInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPetAttrRefineInfoPacket& operator=(CGPetAttrRefineInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPetAttrRefineInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPetAttrRefineInfoPacket* internal_default_instance() {
    return reinterpret_cast<const CGPetAttrRefineInfoPacket*>(
               &_CGPetAttrRefineInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(CGPetAttrRefineInfoPacket& a, CGPetAttrRefineInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPetAttrRefineInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPetAttrRefineInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPetAttrRefineInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPetAttrRefineInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPetAttrRefineInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPetAttrRefineInfoPacket& from) {
    CGPetAttrRefineInfoPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPetAttrRefineInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPetAttrRefineInfoPacket";
  }
  protected:
  explicit CGPetAttrRefineInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPetAttrRefineInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// -------------------------------------------------------------------

class CGPetAttrRefinePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:network.CGPetAttrRefinePacket) */ {
 public:
  inline CGPetAttrRefinePacket() : CGPetAttrRefinePacket(nullptr) {}
  ~CGPetAttrRefinePacket() override;
  explicit PROTOBUF_CONSTEXPR CGPetAttrRefinePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGPetAttrRefinePacket(const CGPetAttrRefinePacket& from);
  CGPetAttrRefinePacket(CGPetAttrRefinePacket&& from) noexcept
    : CGPetAttrRefinePacket() {
    *this = ::std::move(from);
  }

  inline CGPetAttrRefinePacket& operator=(const CGPetAttrRefinePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGPetAttrRefinePacket& operator=(CGPetAttrRefinePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGPetAttrRefinePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGPetAttrRefinePacket* internal_default_instance() {
    return reinterpret_cast<const CGPetAttrRefinePacket*>(
               &_CGPetAttrRefinePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(CGPetAttrRefinePacket& a, CGPetAttrRefinePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CGPetAttrRefinePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGPetAttrRefinePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGPetAttrRefinePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGPetAttrRefinePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGPetAttrRefinePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CGPetAttrRefinePacket& from) {
    CGPetAttrRefinePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGPetAttrRefinePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "network.CGPetAttrRefinePacket";
  }
  protected:
  explicit CGPetAttrRefinePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:network.CGPetAttrRefinePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cg_5fpackets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CGHandshakePacket

// uint32 handshake = 1;
inline void CGHandshakePacket::clear_handshake() {
  _impl_.handshake_ = 0u;
}
inline uint32_t CGHandshakePacket::_internal_handshake() const {
  return _impl_.handshake_;
}
inline uint32_t CGHandshakePacket::handshake() const {
  // @@protoc_insertion_point(field_get:network.CGHandshakePacket.handshake)
  return _internal_handshake();
}
inline void CGHandshakePacket::_internal_set_handshake(uint32_t value) {
  
  _impl_.handshake_ = value;
}
inline void CGHandshakePacket::set_handshake(uint32_t value) {
  _internal_set_handshake(value);
  // @@protoc_insertion_point(field_set:network.CGHandshakePacket.handshake)
}

// uint32 time = 2;
inline void CGHandshakePacket::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t CGHandshakePacket::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t CGHandshakePacket::time() const {
  // @@protoc_insertion_point(field_get:network.CGHandshakePacket.time)
  return _internal_time();
}
inline void CGHandshakePacket::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void CGHandshakePacket::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:network.CGHandshakePacket.time)
}

// sint32 delta = 3;
inline void CGHandshakePacket::clear_delta() {
  _impl_.delta_ = 0;
}
inline int32_t CGHandshakePacket::_internal_delta() const {
  return _impl_.delta_;
}
inline int32_t CGHandshakePacket::delta() const {
  // @@protoc_insertion_point(field_get:network.CGHandshakePacket.delta)
  return _internal_delta();
}
inline void CGHandshakePacket::_internal_set_delta(int32_t value) {
  
  _impl_.delta_ = value;
}
inline void CGHandshakePacket::set_delta(int32_t value) {
  _internal_set_delta(value);
  // @@protoc_insertion_point(field_set:network.CGHandshakePacket.delta)
}

// bytes crypt_data = 4;
inline void CGHandshakePacket::clear_crypt_data() {
  _impl_.crypt_data_.ClearToEmpty();
}
inline const std::string& CGHandshakePacket::crypt_data() const {
  // @@protoc_insertion_point(field_get:network.CGHandshakePacket.crypt_data)
  return _internal_crypt_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGHandshakePacket::set_crypt_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.crypt_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGHandshakePacket.crypt_data)
}
inline std::string* CGHandshakePacket::mutable_crypt_data() {
  std::string* _s = _internal_mutable_crypt_data();
  // @@protoc_insertion_point(field_mutable:network.CGHandshakePacket.crypt_data)
  return _s;
}
inline const std::string& CGHandshakePacket::_internal_crypt_data() const {
  return _impl_.crypt_data_.Get();
}
inline void CGHandshakePacket::_internal_set_crypt_data(const std::string& value) {
  
  _impl_.crypt_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CGHandshakePacket::_internal_mutable_crypt_data() {
  
  return _impl_.crypt_data_.Mutable(GetArenaForAllocation());
}
inline std::string* CGHandshakePacket::release_crypt_data() {
  // @@protoc_insertion_point(field_release:network.CGHandshakePacket.crypt_data)
  return _impl_.crypt_data_.Release();
}
inline void CGHandshakePacket::set_allocated_crypt_data(std::string* crypt_data) {
  if (crypt_data != nullptr) {
    
  } else {
    
  }
  _impl_.crypt_data_.SetAllocated(crypt_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.crypt_data_.IsDefault()) {
    _impl_.crypt_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGHandshakePacket.crypt_data)
}

// -------------------------------------------------------------------

// CGKeyAgreementPacket

// uint32 header = 1;
inline void CGKeyAgreementPacket::clear_header() {
  _impl_.header_ = 0u;
}
inline uint32_t CGKeyAgreementPacket::_internal_header() const {
  return _impl_.header_;
}
inline uint32_t CGKeyAgreementPacket::header() const {
  // @@protoc_insertion_point(field_get:network.CGKeyAgreementPacket.header)
  return _internal_header();
}
inline void CGKeyAgreementPacket::_internal_set_header(uint32_t value) {
  
  _impl_.header_ = value;
}
inline void CGKeyAgreementPacket::set_header(uint32_t value) {
  _internal_set_header(value);
  // @@protoc_insertion_point(field_set:network.CGKeyAgreementPacket.header)
}

// uint32 agreed_length = 2;
inline void CGKeyAgreementPacket::clear_agreed_length() {
  _impl_.agreed_length_ = 0u;
}
inline uint32_t CGKeyAgreementPacket::_internal_agreed_length() const {
  return _impl_.agreed_length_;
}
inline uint32_t CGKeyAgreementPacket::agreed_length() const {
  // @@protoc_insertion_point(field_get:network.CGKeyAgreementPacket.agreed_length)
  return _internal_agreed_length();
}
inline void CGKeyAgreementPacket::_internal_set_agreed_length(uint32_t value) {
  
  _impl_.agreed_length_ = value;
}
inline void CGKeyAgreementPacket::set_agreed_length(uint32_t value) {
  _internal_set_agreed_length(value);
  // @@protoc_insertion_point(field_set:network.CGKeyAgreementPacket.agreed_length)
}

// uint32 data_length = 3;
inline void CGKeyAgreementPacket::clear_data_length() {
  _impl_.data_length_ = 0u;
}
inline uint32_t CGKeyAgreementPacket::_internal_data_length() const {
  return _impl_.data_length_;
}
inline uint32_t CGKeyAgreementPacket::data_length() const {
  // @@protoc_insertion_point(field_get:network.CGKeyAgreementPacket.data_length)
  return _internal_data_length();
}
inline void CGKeyAgreementPacket::_internal_set_data_length(uint32_t value) {
  
  _impl_.data_length_ = value;
}
inline void CGKeyAgreementPacket::set_data_length(uint32_t value) {
  _internal_set_data_length(value);
  // @@protoc_insertion_point(field_set:network.CGKeyAgreementPacket.data_length)
}

// bytes data = 4;
inline void CGKeyAgreementPacket::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& CGKeyAgreementPacket::data() const {
  // @@protoc_insertion_point(field_get:network.CGKeyAgreementPacket.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGKeyAgreementPacket::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGKeyAgreementPacket.data)
}
inline std::string* CGKeyAgreementPacket::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:network.CGKeyAgreementPacket.data)
  return _s;
}
inline const std::string& CGKeyAgreementPacket::_internal_data() const {
  return _impl_.data_.Get();
}
inline void CGKeyAgreementPacket::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* CGKeyAgreementPacket::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* CGKeyAgreementPacket::release_data() {
  // @@protoc_insertion_point(field_release:network.CGKeyAgreementPacket.data)
  return _impl_.data_.Release();
}
inline void CGKeyAgreementPacket::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGKeyAgreementPacket.data)
}

// -------------------------------------------------------------------

// CGAuthLoginPacket

// bytes login = 1;
inline void CGAuthLoginPacket::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& CGAuthLoginPacket::login() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthLoginPacket::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.login)
}
inline std::string* CGAuthLoginPacket::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:network.CGAuthLoginPacket.login)
  return _s;
}
inline const std::string& CGAuthLoginPacket::_internal_login() const {
  return _impl_.login_.Get();
}
inline void CGAuthLoginPacket::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::release_login() {
  // @@protoc_insertion_point(field_release:network.CGAuthLoginPacket.login)
  return _impl_.login_.Release();
}
inline void CGAuthLoginPacket::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthLoginPacket.login)
}

// bytes passwd = 2;
inline void CGAuthLoginPacket::clear_passwd() {
  _impl_.passwd_.ClearToEmpty();
}
inline const std::string& CGAuthLoginPacket::passwd() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthLoginPacket::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwd_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.passwd)
}
inline std::string* CGAuthLoginPacket::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:network.CGAuthLoginPacket.passwd)
  return _s;
}
inline const std::string& CGAuthLoginPacket::_internal_passwd() const {
  return _impl_.passwd_.Get();
}
inline void CGAuthLoginPacket::_internal_set_passwd(const std::string& value) {
  
  _impl_.passwd_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::_internal_mutable_passwd() {
  
  return _impl_.passwd_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::release_passwd() {
  // @@protoc_insertion_point(field_release:network.CGAuthLoginPacket.passwd)
  return _impl_.passwd_.Release();
}
inline void CGAuthLoginPacket::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  _impl_.passwd_.SetAllocated(passwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwd_.IsDefault()) {
    _impl_.passwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthLoginPacket.passwd)
}

// bytes hwid = 3;
inline void CGAuthLoginPacket::clear_hwid() {
  _impl_.hwid_.ClearToEmpty();
}
inline const std::string& CGAuthLoginPacket::hwid() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.hwid)
  return _internal_hwid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthLoginPacket::set_hwid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hwid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.hwid)
}
inline std::string* CGAuthLoginPacket::mutable_hwid() {
  std::string* _s = _internal_mutable_hwid();
  // @@protoc_insertion_point(field_mutable:network.CGAuthLoginPacket.hwid)
  return _s;
}
inline const std::string& CGAuthLoginPacket::_internal_hwid() const {
  return _impl_.hwid_.Get();
}
inline void CGAuthLoginPacket::_internal_set_hwid(const std::string& value) {
  
  _impl_.hwid_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::_internal_mutable_hwid() {
  
  return _impl_.hwid_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::release_hwid() {
  // @@protoc_insertion_point(field_release:network.CGAuthLoginPacket.hwid)
  return _impl_.hwid_.Release();
}
inline void CGAuthLoginPacket::set_allocated_hwid(std::string* hwid) {
  if (hwid != nullptr) {
    
  } else {
    
  }
  _impl_.hwid_.SetAllocated(hwid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hwid_.IsDefault()) {
    _impl_.hwid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthLoginPacket.hwid)
}

// repeated uint32 client_keys = 4;
inline int CGAuthLoginPacket::_internal_client_keys_size() const {
  return _impl_.client_keys_.size();
}
inline int CGAuthLoginPacket::client_keys_size() const {
  return _internal_client_keys_size();
}
inline void CGAuthLoginPacket::clear_client_keys() {
  _impl_.client_keys_.Clear();
}
inline uint32_t CGAuthLoginPacket::_internal_client_keys(int index) const {
  return _impl_.client_keys_.Get(index);
}
inline uint32_t CGAuthLoginPacket::client_keys(int index) const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.client_keys)
  return _internal_client_keys(index);
}
inline void CGAuthLoginPacket::set_client_keys(int index, uint32_t value) {
  _impl_.client_keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.client_keys)
}
inline void CGAuthLoginPacket::_internal_add_client_keys(uint32_t value) {
  _impl_.client_keys_.Add(value);
}
inline void CGAuthLoginPacket::add_client_keys(uint32_t value) {
  _internal_add_client_keys(value);
  // @@protoc_insertion_point(field_add:network.CGAuthLoginPacket.client_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CGAuthLoginPacket::_internal_client_keys() const {
  return _impl_.client_keys_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CGAuthLoginPacket::client_keys() const {
  // @@protoc_insertion_point(field_list:network.CGAuthLoginPacket.client_keys)
  return _internal_client_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CGAuthLoginPacket::_internal_mutable_client_keys() {
  return &_impl_.client_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CGAuthLoginPacket::mutable_client_keys() {
  // @@protoc_insertion_point(field_mutable_list:network.CGAuthLoginPacket.client_keys)
  return _internal_mutable_client_keys();
}

// uint32 version = 5;
inline void CGAuthLoginPacket::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t CGAuthLoginPacket::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t CGAuthLoginPacket::version() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.version)
  return _internal_version();
}
inline void CGAuthLoginPacket::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void CGAuthLoginPacket::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.version)
}

// uint32 language = 6;
inline void CGAuthLoginPacket::clear_language() {
  _impl_.language_ = 0u;
}
inline uint32_t CGAuthLoginPacket::_internal_language() const {
  return _impl_.language_;
}
inline uint32_t CGAuthLoginPacket::language() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.language)
  return _internal_language();
}
inline void CGAuthLoginPacket::_internal_set_language(uint32_t value) {
  
  _impl_.language_ = value;
}
inline void CGAuthLoginPacket::set_language(uint32_t value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.language)
}

// bytes pc_name = 7;
inline void CGAuthLoginPacket::clear_pc_name() {
  _impl_.pc_name_.ClearToEmpty();
}
inline const std::string& CGAuthLoginPacket::pc_name() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.pc_name)
  return _internal_pc_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthLoginPacket::set_pc_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pc_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.pc_name)
}
inline std::string* CGAuthLoginPacket::mutable_pc_name() {
  std::string* _s = _internal_mutable_pc_name();
  // @@protoc_insertion_point(field_mutable:network.CGAuthLoginPacket.pc_name)
  return _s;
}
inline const std::string& CGAuthLoginPacket::_internal_pc_name() const {
  return _impl_.pc_name_.Get();
}
inline void CGAuthLoginPacket::_internal_set_pc_name(const std::string& value) {
  
  _impl_.pc_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::_internal_mutable_pc_name() {
  
  return _impl_.pc_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::release_pc_name() {
  // @@protoc_insertion_point(field_release:network.CGAuthLoginPacket.pc_name)
  return _impl_.pc_name_.Release();
}
inline void CGAuthLoginPacket::set_allocated_pc_name(std::string* pc_name) {
  if (pc_name != nullptr) {
    
  } else {
    
  }
  _impl_.pc_name_.SetAllocated(pc_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pc_name_.IsDefault()) {
    _impl_.pc_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthLoginPacket.pc_name)
}

// bytes user_name = 8;
inline void CGAuthLoginPacket::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& CGAuthLoginPacket::user_name() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthLoginPacket::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.user_name)
}
inline std::string* CGAuthLoginPacket::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:network.CGAuthLoginPacket.user_name)
  return _s;
}
inline const std::string& CGAuthLoginPacket::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void CGAuthLoginPacket::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::release_user_name() {
  // @@protoc_insertion_point(field_release:network.CGAuthLoginPacket.user_name)
  return _impl_.user_name_.Release();
}
inline void CGAuthLoginPacket::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthLoginPacket.user_name)
}

// bytes pc_name_real = 9;
inline void CGAuthLoginPacket::clear_pc_name_real() {
  _impl_.pc_name_real_.ClearToEmpty();
}
inline const std::string& CGAuthLoginPacket::pc_name_real() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.pc_name_real)
  return _internal_pc_name_real();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthLoginPacket::set_pc_name_real(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pc_name_real_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.pc_name_real)
}
inline std::string* CGAuthLoginPacket::mutable_pc_name_real() {
  std::string* _s = _internal_mutable_pc_name_real();
  // @@protoc_insertion_point(field_mutable:network.CGAuthLoginPacket.pc_name_real)
  return _s;
}
inline const std::string& CGAuthLoginPacket::_internal_pc_name_real() const {
  return _impl_.pc_name_real_.Get();
}
inline void CGAuthLoginPacket::_internal_set_pc_name_real(const std::string& value) {
  
  _impl_.pc_name_real_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::_internal_mutable_pc_name_real() {
  
  return _impl_.pc_name_real_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::release_pc_name_real() {
  // @@protoc_insertion_point(field_release:network.CGAuthLoginPacket.pc_name_real)
  return _impl_.pc_name_real_.Release();
}
inline void CGAuthLoginPacket::set_allocated_pc_name_real(std::string* pc_name_real) {
  if (pc_name_real != nullptr) {
    
  } else {
    
  }
  _impl_.pc_name_real_.SetAllocated(pc_name_real, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pc_name_real_.IsDefault()) {
    _impl_.pc_name_real_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthLoginPacket.pc_name_real)
}

// bytes user_name_real = 10;
inline void CGAuthLoginPacket::clear_user_name_real() {
  _impl_.user_name_real_.ClearToEmpty();
}
inline const std::string& CGAuthLoginPacket::user_name_real() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.user_name_real)
  return _internal_user_name_real();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthLoginPacket::set_user_name_real(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_real_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.user_name_real)
}
inline std::string* CGAuthLoginPacket::mutable_user_name_real() {
  std::string* _s = _internal_mutable_user_name_real();
  // @@protoc_insertion_point(field_mutable:network.CGAuthLoginPacket.user_name_real)
  return _s;
}
inline const std::string& CGAuthLoginPacket::_internal_user_name_real() const {
  return _impl_.user_name_real_.Get();
}
inline void CGAuthLoginPacket::_internal_set_user_name_real(const std::string& value) {
  
  _impl_.user_name_real_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::_internal_mutable_user_name_real() {
  
  return _impl_.user_name_real_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::release_user_name_real() {
  // @@protoc_insertion_point(field_release:network.CGAuthLoginPacket.user_name_real)
  return _impl_.user_name_real_.Release();
}
inline void CGAuthLoginPacket::set_allocated_user_name_real(std::string* user_name_real) {
  if (user_name_real != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_real_.SetAllocated(user_name_real, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_real_.IsDefault()) {
    _impl_.user_name_real_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthLoginPacket.user_name_real)
}

// bytes hash = 11;
inline void CGAuthLoginPacket::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& CGAuthLoginPacket::hash() const {
  // @@protoc_insertion_point(field_get:network.CGAuthLoginPacket.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthLoginPacket::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthLoginPacket.hash)
}
inline std::string* CGAuthLoginPacket::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:network.CGAuthLoginPacket.hash)
  return _s;
}
inline const std::string& CGAuthLoginPacket::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void CGAuthLoginPacket::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthLoginPacket::release_hash() {
  // @@protoc_insertion_point(field_release:network.CGAuthLoginPacket.hash)
  return _impl_.hash_.Release();
}
inline void CGAuthLoginPacket::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthLoginPacket.hash)
}

// -------------------------------------------------------------------

// CGAuthOpenIDLoginPacket

// bytes auth_key = 1;
inline void CGAuthOpenIDLoginPacket::clear_auth_key() {
  _impl_.auth_key_.ClearToEmpty();
}
inline const std::string& CGAuthOpenIDLoginPacket::auth_key() const {
  // @@protoc_insertion_point(field_get:network.CGAuthOpenIDLoginPacket.auth_key)
  return _internal_auth_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthOpenIDLoginPacket::set_auth_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthOpenIDLoginPacket.auth_key)
}
inline std::string* CGAuthOpenIDLoginPacket::mutable_auth_key() {
  std::string* _s = _internal_mutable_auth_key();
  // @@protoc_insertion_point(field_mutable:network.CGAuthOpenIDLoginPacket.auth_key)
  return _s;
}
inline const std::string& CGAuthOpenIDLoginPacket::_internal_auth_key() const {
  return _impl_.auth_key_.Get();
}
inline void CGAuthOpenIDLoginPacket::_internal_set_auth_key(const std::string& value) {
  
  _impl_.auth_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthOpenIDLoginPacket::_internal_mutable_auth_key() {
  
  return _impl_.auth_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthOpenIDLoginPacket::release_auth_key() {
  // @@protoc_insertion_point(field_release:network.CGAuthOpenIDLoginPacket.auth_key)
  return _impl_.auth_key_.Release();
}
inline void CGAuthOpenIDLoginPacket::set_allocated_auth_key(std::string* auth_key) {
  if (auth_key != nullptr) {
    
  } else {
    
  }
  _impl_.auth_key_.SetAllocated(auth_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_key_.IsDefault()) {
    _impl_.auth_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthOpenIDLoginPacket.auth_key)
}

// repeated uint32 client_keys = 2;
inline int CGAuthOpenIDLoginPacket::_internal_client_keys_size() const {
  return _impl_.client_keys_.size();
}
inline int CGAuthOpenIDLoginPacket::client_keys_size() const {
  return _internal_client_keys_size();
}
inline void CGAuthOpenIDLoginPacket::clear_client_keys() {
  _impl_.client_keys_.Clear();
}
inline uint32_t CGAuthOpenIDLoginPacket::_internal_client_keys(int index) const {
  return _impl_.client_keys_.Get(index);
}
inline uint32_t CGAuthOpenIDLoginPacket::client_keys(int index) const {
  // @@protoc_insertion_point(field_get:network.CGAuthOpenIDLoginPacket.client_keys)
  return _internal_client_keys(index);
}
inline void CGAuthOpenIDLoginPacket::set_client_keys(int index, uint32_t value) {
  _impl_.client_keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.CGAuthOpenIDLoginPacket.client_keys)
}
inline void CGAuthOpenIDLoginPacket::_internal_add_client_keys(uint32_t value) {
  _impl_.client_keys_.Add(value);
}
inline void CGAuthOpenIDLoginPacket::add_client_keys(uint32_t value) {
  _internal_add_client_keys(value);
  // @@protoc_insertion_point(field_add:network.CGAuthOpenIDLoginPacket.client_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CGAuthOpenIDLoginPacket::_internal_client_keys() const {
  return _impl_.client_keys_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CGAuthOpenIDLoginPacket::client_keys() const {
  // @@protoc_insertion_point(field_list:network.CGAuthOpenIDLoginPacket.client_keys)
  return _internal_client_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CGAuthOpenIDLoginPacket::_internal_mutable_client_keys() {
  return &_impl_.client_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CGAuthOpenIDLoginPacket::mutable_client_keys() {
  // @@protoc_insertion_point(field_mutable_list:network.CGAuthOpenIDLoginPacket.client_keys)
  return _internal_mutable_client_keys();
}

// -------------------------------------------------------------------

// CGAuthPasspodAnswerPacket

// bytes answer = 1;
inline void CGAuthPasspodAnswerPacket::clear_answer() {
  _impl_.answer_.ClearToEmpty();
}
inline const std::string& CGAuthPasspodAnswerPacket::answer() const {
  // @@protoc_insertion_point(field_get:network.CGAuthPasspodAnswerPacket.answer)
  return _internal_answer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuthPasspodAnswerPacket::set_answer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.answer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuthPasspodAnswerPacket.answer)
}
inline std::string* CGAuthPasspodAnswerPacket::mutable_answer() {
  std::string* _s = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:network.CGAuthPasspodAnswerPacket.answer)
  return _s;
}
inline const std::string& CGAuthPasspodAnswerPacket::_internal_answer() const {
  return _impl_.answer_.Get();
}
inline void CGAuthPasspodAnswerPacket::_internal_set_answer(const std::string& value) {
  
  _impl_.answer_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuthPasspodAnswerPacket::_internal_mutable_answer() {
  
  return _impl_.answer_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuthPasspodAnswerPacket::release_answer() {
  // @@protoc_insertion_point(field_release:network.CGAuthPasspodAnswerPacket.answer)
  return _impl_.answer_.Release();
}
inline void CGAuthPasspodAnswerPacket::set_allocated_answer(std::string* answer) {
  if (answer != nullptr) {
    
  } else {
    
  }
  _impl_.answer_.SetAllocated(answer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.answer_.IsDefault()) {
    _impl_.answer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuthPasspodAnswerPacket.answer)
}

// -------------------------------------------------------------------

// CGLoginByKeyPacket

// bytes login = 1;
inline void CGLoginByKeyPacket::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& CGLoginByKeyPacket::login() const {
  // @@protoc_insertion_point(field_get:network.CGLoginByKeyPacket.login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGLoginByKeyPacket::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGLoginByKeyPacket.login)
}
inline std::string* CGLoginByKeyPacket::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:network.CGLoginByKeyPacket.login)
  return _s;
}
inline const std::string& CGLoginByKeyPacket::_internal_login() const {
  return _impl_.login_.Get();
}
inline void CGLoginByKeyPacket::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* CGLoginByKeyPacket::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* CGLoginByKeyPacket::release_login() {
  // @@protoc_insertion_point(field_release:network.CGLoginByKeyPacket.login)
  return _impl_.login_.Release();
}
inline void CGLoginByKeyPacket::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGLoginByKeyPacket.login)
}

// uint32 login_key = 2;
inline void CGLoginByKeyPacket::clear_login_key() {
  _impl_.login_key_ = 0u;
}
inline uint32_t CGLoginByKeyPacket::_internal_login_key() const {
  return _impl_.login_key_;
}
inline uint32_t CGLoginByKeyPacket::login_key() const {
  // @@protoc_insertion_point(field_get:network.CGLoginByKeyPacket.login_key)
  return _internal_login_key();
}
inline void CGLoginByKeyPacket::_internal_set_login_key(uint32_t value) {
  
  _impl_.login_key_ = value;
}
inline void CGLoginByKeyPacket::set_login_key(uint32_t value) {
  _internal_set_login_key(value);
  // @@protoc_insertion_point(field_set:network.CGLoginByKeyPacket.login_key)
}

// repeated uint32 client_key = 3;
inline int CGLoginByKeyPacket::_internal_client_key_size() const {
  return _impl_.client_key_.size();
}
inline int CGLoginByKeyPacket::client_key_size() const {
  return _internal_client_key_size();
}
inline void CGLoginByKeyPacket::clear_client_key() {
  _impl_.client_key_.Clear();
}
inline uint32_t CGLoginByKeyPacket::_internal_client_key(int index) const {
  return _impl_.client_key_.Get(index);
}
inline uint32_t CGLoginByKeyPacket::client_key(int index) const {
  // @@protoc_insertion_point(field_get:network.CGLoginByKeyPacket.client_key)
  return _internal_client_key(index);
}
inline void CGLoginByKeyPacket::set_client_key(int index, uint32_t value) {
  _impl_.client_key_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.CGLoginByKeyPacket.client_key)
}
inline void CGLoginByKeyPacket::_internal_add_client_key(uint32_t value) {
  _impl_.client_key_.Add(value);
}
inline void CGLoginByKeyPacket::add_client_key(uint32_t value) {
  _internal_add_client_key(value);
  // @@protoc_insertion_point(field_add:network.CGLoginByKeyPacket.client_key)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CGLoginByKeyPacket::_internal_client_key() const {
  return _impl_.client_key_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CGLoginByKeyPacket::client_key() const {
  // @@protoc_insertion_point(field_list:network.CGLoginByKeyPacket.client_key)
  return _internal_client_key();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CGLoginByKeyPacket::_internal_mutable_client_key() {
  return &_impl_.client_key_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CGLoginByKeyPacket::mutable_client_key() {
  // @@protoc_insertion_point(field_mutable_list:network.CGLoginByKeyPacket.client_key)
  return _internal_mutable_client_key();
}

// uint32 locale = 4;
inline void CGLoginByKeyPacket::clear_locale() {
  _impl_.locale_ = 0u;
}
inline uint32_t CGLoginByKeyPacket::_internal_locale() const {
  return _impl_.locale_;
}
inline uint32_t CGLoginByKeyPacket::locale() const {
  // @@protoc_insertion_point(field_get:network.CGLoginByKeyPacket.locale)
  return _internal_locale();
}
inline void CGLoginByKeyPacket::_internal_set_locale(uint32_t value) {
  
  _impl_.locale_ = value;
}
inline void CGLoginByKeyPacket::set_locale(uint32_t value) {
  _internal_set_locale(value);
  // @@protoc_insertion_point(field_set:network.CGLoginByKeyPacket.locale)
}

// -------------------------------------------------------------------

// CGEmpirePacket

// uint32 empire = 1;
inline void CGEmpirePacket::clear_empire() {
  _impl_.empire_ = 0u;
}
inline uint32_t CGEmpirePacket::_internal_empire() const {
  return _impl_.empire_;
}
inline uint32_t CGEmpirePacket::empire() const {
  // @@protoc_insertion_point(field_get:network.CGEmpirePacket.empire)
  return _internal_empire();
}
inline void CGEmpirePacket::_internal_set_empire(uint32_t value) {
  
  _impl_.empire_ = value;
}
inline void CGEmpirePacket::set_empire(uint32_t value) {
  _internal_set_empire(value);
  // @@protoc_insertion_point(field_set:network.CGEmpirePacket.empire)
}

// -------------------------------------------------------------------

// CGPlayerSelectPacket

// uint32 index = 1;
inline void CGPlayerSelectPacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGPlayerSelectPacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGPlayerSelectPacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerSelectPacket.index)
  return _internal_index();
}
inline void CGPlayerSelectPacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGPlayerSelectPacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerSelectPacket.index)
}

// -------------------------------------------------------------------

// CGPlayerCreatePacket

// uint32 index = 1;
inline void CGPlayerCreatePacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGPlayerCreatePacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGPlayerCreatePacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerCreatePacket.index)
  return _internal_index();
}
inline void CGPlayerCreatePacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGPlayerCreatePacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerCreatePacket.index)
}

// bytes name = 2;
inline void CGPlayerCreatePacket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CGPlayerCreatePacket::name() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerCreatePacket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGPlayerCreatePacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGPlayerCreatePacket.name)
}
inline std::string* CGPlayerCreatePacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:network.CGPlayerCreatePacket.name)
  return _s;
}
inline const std::string& CGPlayerCreatePacket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CGPlayerCreatePacket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGPlayerCreatePacket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGPlayerCreatePacket::release_name() {
  // @@protoc_insertion_point(field_release:network.CGPlayerCreatePacket.name)
  return _impl_.name_.Release();
}
inline void CGPlayerCreatePacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGPlayerCreatePacket.name)
}

// uint32 job = 3;
inline void CGPlayerCreatePacket::clear_job() {
  _impl_.job_ = 0u;
}
inline uint32_t CGPlayerCreatePacket::_internal_job() const {
  return _impl_.job_;
}
inline uint32_t CGPlayerCreatePacket::job() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerCreatePacket.job)
  return _internal_job();
}
inline void CGPlayerCreatePacket::_internal_set_job(uint32_t value) {
  
  _impl_.job_ = value;
}
inline void CGPlayerCreatePacket::set_job(uint32_t value) {
  _internal_set_job(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerCreatePacket.job)
}

// uint32 shape = 4;
inline void CGPlayerCreatePacket::clear_shape() {
  _impl_.shape_ = 0u;
}
inline uint32_t CGPlayerCreatePacket::_internal_shape() const {
  return _impl_.shape_;
}
inline uint32_t CGPlayerCreatePacket::shape() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerCreatePacket.shape)
  return _internal_shape();
}
inline void CGPlayerCreatePacket::_internal_set_shape(uint32_t value) {
  
  _impl_.shape_ = value;
}
inline void CGPlayerCreatePacket::set_shape(uint32_t value) {
  _internal_set_shape(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerCreatePacket.shape)
}

// uint32 con = 5;
inline void CGPlayerCreatePacket::clear_con() {
  _impl_.con_ = 0u;
}
inline uint32_t CGPlayerCreatePacket::_internal_con() const {
  return _impl_.con_;
}
inline uint32_t CGPlayerCreatePacket::con() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerCreatePacket.con)
  return _internal_con();
}
inline void CGPlayerCreatePacket::_internal_set_con(uint32_t value) {
  
  _impl_.con_ = value;
}
inline void CGPlayerCreatePacket::set_con(uint32_t value) {
  _internal_set_con(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerCreatePacket.con)
}

// uint32 int = 6;
inline void CGPlayerCreatePacket::clear_int_() {
  _impl_.int__ = 0u;
}
inline uint32_t CGPlayerCreatePacket::_internal_int_() const {
  return _impl_.int__;
}
inline uint32_t CGPlayerCreatePacket::int_() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerCreatePacket.int)
  return _internal_int_();
}
inline void CGPlayerCreatePacket::_internal_set_int_(uint32_t value) {
  
  _impl_.int__ = value;
}
inline void CGPlayerCreatePacket::set_int_(uint32_t value) {
  _internal_set_int_(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerCreatePacket.int)
}

// uint32 str = 7;
inline void CGPlayerCreatePacket::clear_str() {
  _impl_.str_ = 0u;
}
inline uint32_t CGPlayerCreatePacket::_internal_str() const {
  return _impl_.str_;
}
inline uint32_t CGPlayerCreatePacket::str() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerCreatePacket.str)
  return _internal_str();
}
inline void CGPlayerCreatePacket::_internal_set_str(uint32_t value) {
  
  _impl_.str_ = value;
}
inline void CGPlayerCreatePacket::set_str(uint32_t value) {
  _internal_set_str(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerCreatePacket.str)
}

// uint32 dex = 8;
inline void CGPlayerCreatePacket::clear_dex() {
  _impl_.dex_ = 0u;
}
inline uint32_t CGPlayerCreatePacket::_internal_dex() const {
  return _impl_.dex_;
}
inline uint32_t CGPlayerCreatePacket::dex() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerCreatePacket.dex)
  return _internal_dex();
}
inline void CGPlayerCreatePacket::_internal_set_dex(uint32_t value) {
  
  _impl_.dex_ = value;
}
inline void CGPlayerCreatePacket::set_dex(uint32_t value) {
  _internal_set_dex(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerCreatePacket.dex)
}

// -------------------------------------------------------------------

// CGPlayerChangeNamePacket

// uint32 index = 1;
inline void CGPlayerChangeNamePacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGPlayerChangeNamePacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGPlayerChangeNamePacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerChangeNamePacket.index)
  return _internal_index();
}
inline void CGPlayerChangeNamePacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGPlayerChangeNamePacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerChangeNamePacket.index)
}

// bytes name = 2;
inline void CGPlayerChangeNamePacket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CGPlayerChangeNamePacket::name() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerChangeNamePacket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGPlayerChangeNamePacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGPlayerChangeNamePacket.name)
}
inline std::string* CGPlayerChangeNamePacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:network.CGPlayerChangeNamePacket.name)
  return _s;
}
inline const std::string& CGPlayerChangeNamePacket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CGPlayerChangeNamePacket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGPlayerChangeNamePacket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGPlayerChangeNamePacket::release_name() {
  // @@protoc_insertion_point(field_release:network.CGPlayerChangeNamePacket.name)
  return _impl_.name_.Release();
}
inline void CGPlayerChangeNamePacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGPlayerChangeNamePacket.name)
}

// -------------------------------------------------------------------

// CGPlayerHairSelectPacket

// uint32 index = 1;
inline void CGPlayerHairSelectPacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGPlayerHairSelectPacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGPlayerHairSelectPacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerHairSelectPacket.index)
  return _internal_index();
}
inline void CGPlayerHairSelectPacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGPlayerHairSelectPacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerHairSelectPacket.index)
}

// uint32 hair_vnum = 2;
inline void CGPlayerHairSelectPacket::clear_hair_vnum() {
  _impl_.hair_vnum_ = 0u;
}
inline uint32_t CGPlayerHairSelectPacket::_internal_hair_vnum() const {
  return _impl_.hair_vnum_;
}
inline uint32_t CGPlayerHairSelectPacket::hair_vnum() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerHairSelectPacket.hair_vnum)
  return _internal_hair_vnum();
}
inline void CGPlayerHairSelectPacket::_internal_set_hair_vnum(uint32_t value) {
  
  _impl_.hair_vnum_ = value;
}
inline void CGPlayerHairSelectPacket::set_hair_vnum(uint32_t value) {
  _internal_set_hair_vnum(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerHairSelectPacket.hair_vnum)
}

// -------------------------------------------------------------------

// CGPlayerDeletePacket

// uint32 index = 1;
inline void CGPlayerDeletePacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGPlayerDeletePacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGPlayerDeletePacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerDeletePacket.index)
  return _internal_index();
}
inline void CGPlayerDeletePacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGPlayerDeletePacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGPlayerDeletePacket.index)
}

// bytes private_code = 2;
inline void CGPlayerDeletePacket::clear_private_code() {
  _impl_.private_code_.ClearToEmpty();
}
inline const std::string& CGPlayerDeletePacket::private_code() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerDeletePacket.private_code)
  return _internal_private_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGPlayerDeletePacket::set_private_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.private_code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGPlayerDeletePacket.private_code)
}
inline std::string* CGPlayerDeletePacket::mutable_private_code() {
  std::string* _s = _internal_mutable_private_code();
  // @@protoc_insertion_point(field_mutable:network.CGPlayerDeletePacket.private_code)
  return _s;
}
inline const std::string& CGPlayerDeletePacket::_internal_private_code() const {
  return _impl_.private_code_.Get();
}
inline void CGPlayerDeletePacket::_internal_set_private_code(const std::string& value) {
  
  _impl_.private_code_.Set(value, GetArenaForAllocation());
}
inline std::string* CGPlayerDeletePacket::_internal_mutable_private_code() {
  
  return _impl_.private_code_.Mutable(GetArenaForAllocation());
}
inline std::string* CGPlayerDeletePacket::release_private_code() {
  // @@protoc_insertion_point(field_release:network.CGPlayerDeletePacket.private_code)
  return _impl_.private_code_.Release();
}
inline void CGPlayerDeletePacket::set_allocated_private_code(std::string* private_code) {
  if (private_code != nullptr) {
    
  } else {
    
  }
  _impl_.private_code_.SetAllocated(private_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.private_code_.IsDefault()) {
    _impl_.private_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGPlayerDeletePacket.private_code)
}

// -------------------------------------------------------------------

// CGMarkCRCListPacket

// uint32 image_index = 1;
inline void CGMarkCRCListPacket::clear_image_index() {
  _impl_.image_index_ = 0u;
}
inline uint32_t CGMarkCRCListPacket::_internal_image_index() const {
  return _impl_.image_index_;
}
inline uint32_t CGMarkCRCListPacket::image_index() const {
  // @@protoc_insertion_point(field_get:network.CGMarkCRCListPacket.image_index)
  return _internal_image_index();
}
inline void CGMarkCRCListPacket::_internal_set_image_index(uint32_t value) {
  
  _impl_.image_index_ = value;
}
inline void CGMarkCRCListPacket::set_image_index(uint32_t value) {
  _internal_set_image_index(value);
  // @@protoc_insertion_point(field_set:network.CGMarkCRCListPacket.image_index)
}

// repeated uint32 crclist = 2;
inline int CGMarkCRCListPacket::_internal_crclist_size() const {
  return _impl_.crclist_.size();
}
inline int CGMarkCRCListPacket::crclist_size() const {
  return _internal_crclist_size();
}
inline void CGMarkCRCListPacket::clear_crclist() {
  _impl_.crclist_.Clear();
}
inline uint32_t CGMarkCRCListPacket::_internal_crclist(int index) const {
  return _impl_.crclist_.Get(index);
}
inline uint32_t CGMarkCRCListPacket::crclist(int index) const {
  // @@protoc_insertion_point(field_get:network.CGMarkCRCListPacket.crclist)
  return _internal_crclist(index);
}
inline void CGMarkCRCListPacket::set_crclist(int index, uint32_t value) {
  _impl_.crclist_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.CGMarkCRCListPacket.crclist)
}
inline void CGMarkCRCListPacket::_internal_add_crclist(uint32_t value) {
  _impl_.crclist_.Add(value);
}
inline void CGMarkCRCListPacket::add_crclist(uint32_t value) {
  _internal_add_crclist(value);
  // @@protoc_insertion_point(field_add:network.CGMarkCRCListPacket.crclist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CGMarkCRCListPacket::_internal_crclist() const {
  return _impl_.crclist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CGMarkCRCListPacket::crclist() const {
  // @@protoc_insertion_point(field_list:network.CGMarkCRCListPacket.crclist)
  return _internal_crclist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CGMarkCRCListPacket::_internal_mutable_crclist() {
  return &_impl_.crclist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CGMarkCRCListPacket::mutable_crclist() {
  // @@protoc_insertion_point(field_mutable_list:network.CGMarkCRCListPacket.crclist)
  return _internal_mutable_crclist();
}

// -------------------------------------------------------------------

// CGMarkUploadPacket

// uint32 guild_id = 1;
inline void CGMarkUploadPacket::clear_guild_id() {
  _impl_.guild_id_ = 0u;
}
inline uint32_t CGMarkUploadPacket::_internal_guild_id() const {
  return _impl_.guild_id_;
}
inline uint32_t CGMarkUploadPacket::guild_id() const {
  // @@protoc_insertion_point(field_get:network.CGMarkUploadPacket.guild_id)
  return _internal_guild_id();
}
inline void CGMarkUploadPacket::_internal_set_guild_id(uint32_t value) {
  
  _impl_.guild_id_ = value;
}
inline void CGMarkUploadPacket::set_guild_id(uint32_t value) {
  _internal_set_guild_id(value);
  // @@protoc_insertion_point(field_set:network.CGMarkUploadPacket.guild_id)
}

// bytes image = 2;
inline void CGMarkUploadPacket::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& CGMarkUploadPacket::image() const {
  // @@protoc_insertion_point(field_get:network.CGMarkUploadPacket.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGMarkUploadPacket::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGMarkUploadPacket.image)
}
inline std::string* CGMarkUploadPacket::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:network.CGMarkUploadPacket.image)
  return _s;
}
inline const std::string& CGMarkUploadPacket::_internal_image() const {
  return _impl_.image_.Get();
}
inline void CGMarkUploadPacket::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* CGMarkUploadPacket::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* CGMarkUploadPacket::release_image() {
  // @@protoc_insertion_point(field_release:network.CGMarkUploadPacket.image)
  return _impl_.image_.Release();
}
inline void CGMarkUploadPacket::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGMarkUploadPacket.image)
}

// -------------------------------------------------------------------

// CGGuildSymbolUploadPacket

// uint32 guild_id = 1;
inline void CGGuildSymbolUploadPacket::clear_guild_id() {
  _impl_.guild_id_ = 0u;
}
inline uint32_t CGGuildSymbolUploadPacket::_internal_guild_id() const {
  return _impl_.guild_id_;
}
inline uint32_t CGGuildSymbolUploadPacket::guild_id() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSymbolUploadPacket.guild_id)
  return _internal_guild_id();
}
inline void CGGuildSymbolUploadPacket::_internal_set_guild_id(uint32_t value) {
  
  _impl_.guild_id_ = value;
}
inline void CGGuildSymbolUploadPacket::set_guild_id(uint32_t value) {
  _internal_set_guild_id(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSymbolUploadPacket.guild_id)
}

// bytes image = 2;
inline void CGGuildSymbolUploadPacket::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& CGGuildSymbolUploadPacket::image() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSymbolUploadPacket.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGGuildSymbolUploadPacket::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGGuildSymbolUploadPacket.image)
}
inline std::string* CGGuildSymbolUploadPacket::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:network.CGGuildSymbolUploadPacket.image)
  return _s;
}
inline const std::string& CGGuildSymbolUploadPacket::_internal_image() const {
  return _impl_.image_.Get();
}
inline void CGGuildSymbolUploadPacket::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* CGGuildSymbolUploadPacket::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* CGGuildSymbolUploadPacket::release_image() {
  // @@protoc_insertion_point(field_release:network.CGGuildSymbolUploadPacket.image)
  return _impl_.image_.Release();
}
inline void CGGuildSymbolUploadPacket::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGGuildSymbolUploadPacket.image)
}

// -------------------------------------------------------------------

// CGGuildSymbolCRCPacket

// uint32 guild_id = 1;
inline void CGGuildSymbolCRCPacket::clear_guild_id() {
  _impl_.guild_id_ = 0u;
}
inline uint32_t CGGuildSymbolCRCPacket::_internal_guild_id() const {
  return _impl_.guild_id_;
}
inline uint32_t CGGuildSymbolCRCPacket::guild_id() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSymbolCRCPacket.guild_id)
  return _internal_guild_id();
}
inline void CGGuildSymbolCRCPacket::_internal_set_guild_id(uint32_t value) {
  
  _impl_.guild_id_ = value;
}
inline void CGGuildSymbolCRCPacket::set_guild_id(uint32_t value) {
  _internal_set_guild_id(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSymbolCRCPacket.guild_id)
}

// uint32 crc = 2;
inline void CGGuildSymbolCRCPacket::clear_crc() {
  _impl_.crc_ = 0u;
}
inline uint32_t CGGuildSymbolCRCPacket::_internal_crc() const {
  return _impl_.crc_;
}
inline uint32_t CGGuildSymbolCRCPacket::crc() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSymbolCRCPacket.crc)
  return _internal_crc();
}
inline void CGGuildSymbolCRCPacket::_internal_set_crc(uint32_t value) {
  
  _impl_.crc_ = value;
}
inline void CGGuildSymbolCRCPacket::set_crc(uint32_t value) {
  _internal_set_crc(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSymbolCRCPacket.crc)
}

// uint32 symbol_size = 3;
inline void CGGuildSymbolCRCPacket::clear_symbol_size() {
  _impl_.symbol_size_ = 0u;
}
inline uint32_t CGGuildSymbolCRCPacket::_internal_symbol_size() const {
  return _impl_.symbol_size_;
}
inline uint32_t CGGuildSymbolCRCPacket::symbol_size() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSymbolCRCPacket.symbol_size)
  return _internal_symbol_size();
}
inline void CGGuildSymbolCRCPacket::_internal_set_symbol_size(uint32_t value) {
  
  _impl_.symbol_size_ = value;
}
inline void CGGuildSymbolCRCPacket::set_symbol_size(uint32_t value) {
  _internal_set_symbol_size(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSymbolCRCPacket.symbol_size)
}

// -------------------------------------------------------------------

// CGClientVersionPacket

// bytes filename = 1;
inline void CGClientVersionPacket::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& CGClientVersionPacket::filename() const {
  // @@protoc_insertion_point(field_get:network.CGClientVersionPacket.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGClientVersionPacket::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGClientVersionPacket.filename)
}
inline std::string* CGClientVersionPacket::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:network.CGClientVersionPacket.filename)
  return _s;
}
inline const std::string& CGClientVersionPacket::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void CGClientVersionPacket::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* CGClientVersionPacket::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* CGClientVersionPacket::release_filename() {
  // @@protoc_insertion_point(field_release:network.CGClientVersionPacket.filename)
  return _impl_.filename_.Release();
}
inline void CGClientVersionPacket::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGClientVersionPacket.filename)
}

// bytes timestamp = 2;
inline void CGClientVersionPacket::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& CGClientVersionPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:network.CGClientVersionPacket.timestamp)
  return _internal_timestamp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGClientVersionPacket::set_timestamp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timestamp_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGClientVersionPacket.timestamp)
}
inline std::string* CGClientVersionPacket::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:network.CGClientVersionPacket.timestamp)
  return _s;
}
inline const std::string& CGClientVersionPacket::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void CGClientVersionPacket::_internal_set_timestamp(const std::string& value) {
  
  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* CGClientVersionPacket::_internal_mutable_timestamp() {
  
  return _impl_.timestamp_.Mutable(GetArenaForAllocation());
}
inline std::string* CGClientVersionPacket::release_timestamp() {
  // @@protoc_insertion_point(field_release:network.CGClientVersionPacket.timestamp)
  return _impl_.timestamp_.Release();
}
inline void CGClientVersionPacket::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  _impl_.timestamp_.SetAllocated(timestamp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGClientVersionPacket.timestamp)
}

// -------------------------------------------------------------------

// CGLoginVersionCheckPacket

// bytes version = 1;
inline void CGLoginVersionCheckPacket::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& CGLoginVersionCheckPacket::version() const {
  // @@protoc_insertion_point(field_get:network.CGLoginVersionCheckPacket.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGLoginVersionCheckPacket::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGLoginVersionCheckPacket.version)
}
inline std::string* CGLoginVersionCheckPacket::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:network.CGLoginVersionCheckPacket.version)
  return _s;
}
inline const std::string& CGLoginVersionCheckPacket::_internal_version() const {
  return _impl_.version_.Get();
}
inline void CGLoginVersionCheckPacket::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* CGLoginVersionCheckPacket::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* CGLoginVersionCheckPacket::release_version() {
  // @@protoc_insertion_point(field_release:network.CGLoginVersionCheckPacket.version)
  return _impl_.version_.Release();
}
inline void CGLoginVersionCheckPacket::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGLoginVersionCheckPacket.version)
}

// -------------------------------------------------------------------

// CGXTRAPAckPacket

// bytes packet_data = 1;
inline void CGXTRAPAckPacket::clear_packet_data() {
  _impl_.packet_data_.ClearToEmpty();
}
inline const std::string& CGXTRAPAckPacket::packet_data() const {
  // @@protoc_insertion_point(field_get:network.CGXTRAPAckPacket.packet_data)
  return _internal_packet_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGXTRAPAckPacket::set_packet_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.packet_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGXTRAPAckPacket.packet_data)
}
inline std::string* CGXTRAPAckPacket::mutable_packet_data() {
  std::string* _s = _internal_mutable_packet_data();
  // @@protoc_insertion_point(field_mutable:network.CGXTRAPAckPacket.packet_data)
  return _s;
}
inline const std::string& CGXTRAPAckPacket::_internal_packet_data() const {
  return _impl_.packet_data_.Get();
}
inline void CGXTRAPAckPacket::_internal_set_packet_data(const std::string& value) {
  
  _impl_.packet_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CGXTRAPAckPacket::_internal_mutable_packet_data() {
  
  return _impl_.packet_data_.Mutable(GetArenaForAllocation());
}
inline std::string* CGXTRAPAckPacket::release_packet_data() {
  // @@protoc_insertion_point(field_release:network.CGXTRAPAckPacket.packet_data)
  return _impl_.packet_data_.Release();
}
inline void CGXTRAPAckPacket::set_allocated_packet_data(std::string* packet_data) {
  if (packet_data != nullptr) {
    
  } else {
    
  }
  _impl_.packet_data_.SetAllocated(packet_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.packet_data_.IsDefault()) {
    _impl_.packet_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGXTRAPAckPacket.packet_data)
}

// -------------------------------------------------------------------

// CGHackPacket

// bytes buf = 1;
inline void CGHackPacket::clear_buf() {
  _impl_.buf_.ClearToEmpty();
}
inline const std::string& CGHackPacket::buf() const {
  // @@protoc_insertion_point(field_get:network.CGHackPacket.buf)
  return _internal_buf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGHackPacket::set_buf(ArgT0&& arg0, ArgT... args) {
 
 _impl_.buf_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGHackPacket.buf)
}
inline std::string* CGHackPacket::mutable_buf() {
  std::string* _s = _internal_mutable_buf();
  // @@protoc_insertion_point(field_mutable:network.CGHackPacket.buf)
  return _s;
}
inline const std::string& CGHackPacket::_internal_buf() const {
  return _impl_.buf_.Get();
}
inline void CGHackPacket::_internal_set_buf(const std::string& value) {
  
  _impl_.buf_.Set(value, GetArenaForAllocation());
}
inline std::string* CGHackPacket::_internal_mutable_buf() {
  
  return _impl_.buf_.Mutable(GetArenaForAllocation());
}
inline std::string* CGHackPacket::release_buf() {
  // @@protoc_insertion_point(field_release:network.CGHackPacket.buf)
  return _impl_.buf_.Release();
}
inline void CGHackPacket::set_allocated_buf(std::string* buf) {
  if (buf != nullptr) {
    
  } else {
    
  }
  _impl_.buf_.SetAllocated(buf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buf_.IsDefault()) {
    _impl_.buf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGHackPacket.buf)
}

// -------------------------------------------------------------------

// CGCostumeVisibilityPacket

// uint32 type = 1;
inline void CGCostumeVisibilityPacket::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CGCostumeVisibilityPacket::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CGCostumeVisibilityPacket::type() const {
  // @@protoc_insertion_point(field_get:network.CGCostumeVisibilityPacket.type)
  return _internal_type();
}
inline void CGCostumeVisibilityPacket::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CGCostumeVisibilityPacket::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:network.CGCostumeVisibilityPacket.type)
}

// bool visible = 2;
inline void CGCostumeVisibilityPacket::clear_visible() {
  _impl_.visible_ = false;
}
inline bool CGCostumeVisibilityPacket::_internal_visible() const {
  return _impl_.visible_;
}
inline bool CGCostumeVisibilityPacket::visible() const {
  // @@protoc_insertion_point(field_get:network.CGCostumeVisibilityPacket.visible)
  return _internal_visible();
}
inline void CGCostumeVisibilityPacket::_internal_set_visible(bool value) {
  
  _impl_.visible_ = value;
}
inline void CGCostumeVisibilityPacket::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:network.CGCostumeVisibilityPacket.visible)
}

// -------------------------------------------------------------------

// CGChatPacket

// uint32 type = 1;
inline void CGChatPacket::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CGChatPacket::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CGChatPacket::type() const {
  // @@protoc_insertion_point(field_get:network.CGChatPacket.type)
  return _internal_type();
}
inline void CGChatPacket::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CGChatPacket::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:network.CGChatPacket.type)
}

// bytes message = 2;
inline void CGChatPacket::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CGChatPacket::message() const {
  // @@protoc_insertion_point(field_get:network.CGChatPacket.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGChatPacket::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGChatPacket.message)
}
inline std::string* CGChatPacket::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:network.CGChatPacket.message)
  return _s;
}
inline const std::string& CGChatPacket::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CGChatPacket::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CGChatPacket::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CGChatPacket::release_message() {
  // @@protoc_insertion_point(field_release:network.CGChatPacket.message)
  return _impl_.message_.Release();
}
inline void CGChatPacket::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGChatPacket.message)
}

// -------------------------------------------------------------------

// CGAttackPacket

// uint32 type = 1;
inline void CGAttackPacket::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CGAttackPacket::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CGAttackPacket::type() const {
  // @@protoc_insertion_point(field_get:network.CGAttackPacket.type)
  return _internal_type();
}
inline void CGAttackPacket::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CGAttackPacket::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:network.CGAttackPacket.type)
}

// uint32 vid = 2;
inline void CGAttackPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGAttackPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGAttackPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGAttackPacket.vid)
  return _internal_vid();
}
inline void CGAttackPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGAttackPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGAttackPacket.vid)
}

// uint32 crc_magic_cube_proc_piece = 3;
inline void CGAttackPacket::clear_crc_magic_cube_proc_piece() {
  _impl_.crc_magic_cube_proc_piece_ = 0u;
}
inline uint32_t CGAttackPacket::_internal_crc_magic_cube_proc_piece() const {
  return _impl_.crc_magic_cube_proc_piece_;
}
inline uint32_t CGAttackPacket::crc_magic_cube_proc_piece() const {
  // @@protoc_insertion_point(field_get:network.CGAttackPacket.crc_magic_cube_proc_piece)
  return _internal_crc_magic_cube_proc_piece();
}
inline void CGAttackPacket::_internal_set_crc_magic_cube_proc_piece(uint32_t value) {
  
  _impl_.crc_magic_cube_proc_piece_ = value;
}
inline void CGAttackPacket::set_crc_magic_cube_proc_piece(uint32_t value) {
  _internal_set_crc_magic_cube_proc_piece(value);
  // @@protoc_insertion_point(field_set:network.CGAttackPacket.crc_magic_cube_proc_piece)
}

// uint32 crc_magic_cube_file_piece = 4;
inline void CGAttackPacket::clear_crc_magic_cube_file_piece() {
  _impl_.crc_magic_cube_file_piece_ = 0u;
}
inline uint32_t CGAttackPacket::_internal_crc_magic_cube_file_piece() const {
  return _impl_.crc_magic_cube_file_piece_;
}
inline uint32_t CGAttackPacket::crc_magic_cube_file_piece() const {
  // @@protoc_insertion_point(field_get:network.CGAttackPacket.crc_magic_cube_file_piece)
  return _internal_crc_magic_cube_file_piece();
}
inline void CGAttackPacket::_internal_set_crc_magic_cube_file_piece(uint32_t value) {
  
  _impl_.crc_magic_cube_file_piece_ = value;
}
inline void CGAttackPacket::set_crc_magic_cube_file_piece(uint32_t value) {
  _internal_set_crc_magic_cube_file_piece(value);
  // @@protoc_insertion_point(field_set:network.CGAttackPacket.crc_magic_cube_file_piece)
}

// uint32 random = 5;
inline void CGAttackPacket::clear_random() {
  _impl_.random_ = 0u;
}
inline uint32_t CGAttackPacket::_internal_random() const {
  return _impl_.random_;
}
inline uint32_t CGAttackPacket::random() const {
  // @@protoc_insertion_point(field_get:network.CGAttackPacket.random)
  return _internal_random();
}
inline void CGAttackPacket::_internal_set_random(uint32_t value) {
  
  _impl_.random_ = value;
}
inline void CGAttackPacket::set_random(uint32_t value) {
  _internal_set_random(value);
  // @@protoc_insertion_point(field_set:network.CGAttackPacket.random)
}

// -------------------------------------------------------------------

// CGShootPacket

// uint32 type = 1;
inline void CGShootPacket::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CGShootPacket::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CGShootPacket::type() const {
  // @@protoc_insertion_point(field_get:network.CGShootPacket.type)
  return _internal_type();
}
inline void CGShootPacket::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CGShootPacket::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:network.CGShootPacket.type)
}

// -------------------------------------------------------------------

// CGWhisperPacket

// bytes name_to = 1;
inline void CGWhisperPacket::clear_name_to() {
  _impl_.name_to_.ClearToEmpty();
}
inline const std::string& CGWhisperPacket::name_to() const {
  // @@protoc_insertion_point(field_get:network.CGWhisperPacket.name_to)
  return _internal_name_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGWhisperPacket::set_name_to(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_to_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGWhisperPacket.name_to)
}
inline std::string* CGWhisperPacket::mutable_name_to() {
  std::string* _s = _internal_mutable_name_to();
  // @@protoc_insertion_point(field_mutable:network.CGWhisperPacket.name_to)
  return _s;
}
inline const std::string& CGWhisperPacket::_internal_name_to() const {
  return _impl_.name_to_.Get();
}
inline void CGWhisperPacket::_internal_set_name_to(const std::string& value) {
  
  _impl_.name_to_.Set(value, GetArenaForAllocation());
}
inline std::string* CGWhisperPacket::_internal_mutable_name_to() {
  
  return _impl_.name_to_.Mutable(GetArenaForAllocation());
}
inline std::string* CGWhisperPacket::release_name_to() {
  // @@protoc_insertion_point(field_release:network.CGWhisperPacket.name_to)
  return _impl_.name_to_.Release();
}
inline void CGWhisperPacket::set_allocated_name_to(std::string* name_to) {
  if (name_to != nullptr) {
    
  } else {
    
  }
  _impl_.name_to_.SetAllocated(name_to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_to_.IsDefault()) {
    _impl_.name_to_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGWhisperPacket.name_to)
}

// bytes message = 2;
inline void CGWhisperPacket::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CGWhisperPacket::message() const {
  // @@protoc_insertion_point(field_get:network.CGWhisperPacket.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGWhisperPacket::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGWhisperPacket.message)
}
inline std::string* CGWhisperPacket::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:network.CGWhisperPacket.message)
  return _s;
}
inline const std::string& CGWhisperPacket::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CGWhisperPacket::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CGWhisperPacket::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CGWhisperPacket::release_message() {
  // @@protoc_insertion_point(field_release:network.CGWhisperPacket.message)
  return _impl_.message_.Release();
}
inline void CGWhisperPacket::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGWhisperPacket.message)
}

// bool send_offline = 3;
inline void CGWhisperPacket::clear_send_offline() {
  _impl_.send_offline_ = false;
}
inline bool CGWhisperPacket::_internal_send_offline() const {
  return _impl_.send_offline_;
}
inline bool CGWhisperPacket::send_offline() const {
  // @@protoc_insertion_point(field_get:network.CGWhisperPacket.send_offline)
  return _internal_send_offline();
}
inline void CGWhisperPacket::_internal_set_send_offline(bool value) {
  
  _impl_.send_offline_ = value;
}
inline void CGWhisperPacket::set_send_offline(bool value) {
  _internal_set_send_offline(value);
  // @@protoc_insertion_point(field_set:network.CGWhisperPacket.send_offline)
}

// -------------------------------------------------------------------

// CGOnClickPacket

// uint32 vid = 1;
inline void CGOnClickPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGOnClickPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGOnClickPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGOnClickPacket.vid)
  return _internal_vid();
}
inline void CGOnClickPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGOnClickPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGOnClickPacket.vid)
}

// -------------------------------------------------------------------

// CGPositionPacket

// uint32 position = 1;
inline void CGPositionPacket::clear_position() {
  _impl_.position_ = 0u;
}
inline uint32_t CGPositionPacket::_internal_position() const {
  return _impl_.position_;
}
inline uint32_t CGPositionPacket::position() const {
  // @@protoc_insertion_point(field_get:network.CGPositionPacket.position)
  return _internal_position();
}
inline void CGPositionPacket::_internal_set_position(uint32_t value) {
  
  _impl_.position_ = value;
}
inline void CGPositionPacket::set_position(uint32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:network.CGPositionPacket.position)
}

// -------------------------------------------------------------------

// CGNextSkillUsePacket

// uint32 skill_vnum = 1;
inline void CGNextSkillUsePacket::clear_skill_vnum() {
  _impl_.skill_vnum_ = 0u;
}
inline uint32_t CGNextSkillUsePacket::_internal_skill_vnum() const {
  return _impl_.skill_vnum_;
}
inline uint32_t CGNextSkillUsePacket::skill_vnum() const {
  // @@protoc_insertion_point(field_get:network.CGNextSkillUsePacket.skill_vnum)
  return _internal_skill_vnum();
}
inline void CGNextSkillUsePacket::_internal_set_skill_vnum(uint32_t value) {
  
  _impl_.skill_vnum_ = value;
}
inline void CGNextSkillUsePacket::set_skill_vnum(uint32_t value) {
  _internal_set_skill_vnum(value);
  // @@protoc_insertion_point(field_set:network.CGNextSkillUsePacket.skill_vnum)
}

// -------------------------------------------------------------------

// CGMovePacket

// uint32 func = 1;
inline void CGMovePacket::clear_func() {
  _impl_.func_ = 0u;
}
inline uint32_t CGMovePacket::_internal_func() const {
  return _impl_.func_;
}
inline uint32_t CGMovePacket::func() const {
  // @@protoc_insertion_point(field_get:network.CGMovePacket.func)
  return _internal_func();
}
inline void CGMovePacket::_internal_set_func(uint32_t value) {
  
  _impl_.func_ = value;
}
inline void CGMovePacket::set_func(uint32_t value) {
  _internal_set_func(value);
  // @@protoc_insertion_point(field_set:network.CGMovePacket.func)
}

// uint32 arg = 2;
inline void CGMovePacket::clear_arg() {
  _impl_.arg_ = 0u;
}
inline uint32_t CGMovePacket::_internal_arg() const {
  return _impl_.arg_;
}
inline uint32_t CGMovePacket::arg() const {
  // @@protoc_insertion_point(field_get:network.CGMovePacket.arg)
  return _internal_arg();
}
inline void CGMovePacket::_internal_set_arg(uint32_t value) {
  
  _impl_.arg_ = value;
}
inline void CGMovePacket::set_arg(uint32_t value) {
  _internal_set_arg(value);
  // @@protoc_insertion_point(field_set:network.CGMovePacket.arg)
}

// uint32 rot = 3;
inline void CGMovePacket::clear_rot() {
  _impl_.rot_ = 0u;
}
inline uint32_t CGMovePacket::_internal_rot() const {
  return _impl_.rot_;
}
inline uint32_t CGMovePacket::rot() const {
  // @@protoc_insertion_point(field_get:network.CGMovePacket.rot)
  return _internal_rot();
}
inline void CGMovePacket::_internal_set_rot(uint32_t value) {
  
  _impl_.rot_ = value;
}
inline void CGMovePacket::set_rot(uint32_t value) {
  _internal_set_rot(value);
  // @@protoc_insertion_point(field_set:network.CGMovePacket.rot)
}

// uint32 x = 4;
inline void CGMovePacket::clear_x() {
  _impl_.x_ = 0u;
}
inline uint32_t CGMovePacket::_internal_x() const {
  return _impl_.x_;
}
inline uint32_t CGMovePacket::x() const {
  // @@protoc_insertion_point(field_get:network.CGMovePacket.x)
  return _internal_x();
}
inline void CGMovePacket::_internal_set_x(uint32_t value) {
  
  _impl_.x_ = value;
}
inline void CGMovePacket::set_x(uint32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:network.CGMovePacket.x)
}

// uint32 y = 5;
inline void CGMovePacket::clear_y() {
  _impl_.y_ = 0u;
}
inline uint32_t CGMovePacket::_internal_y() const {
  return _impl_.y_;
}
inline uint32_t CGMovePacket::y() const {
  // @@protoc_insertion_point(field_get:network.CGMovePacket.y)
  return _internal_y();
}
inline void CGMovePacket::_internal_set_y(uint32_t value) {
  
  _impl_.y_ = value;
}
inline void CGMovePacket::set_y(uint32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:network.CGMovePacket.y)
}

// uint32 time = 6;
inline void CGMovePacket::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t CGMovePacket::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t CGMovePacket::time() const {
  // @@protoc_insertion_point(field_get:network.CGMovePacket.time)
  return _internal_time();
}
inline void CGMovePacket::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void CGMovePacket::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:network.CGMovePacket.time)
}

// -------------------------------------------------------------------

// CGSyncPositionPacket

// repeated .network.SyncPositionElement elements = 1;
inline int CGSyncPositionPacket::_internal_elements_size() const {
  return _impl_.elements_.size();
}
inline int CGSyncPositionPacket::elements_size() const {
  return _internal_elements_size();
}
inline ::network::SyncPositionElement* CGSyncPositionPacket::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:network.CGSyncPositionPacket.elements)
  return _impl_.elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::SyncPositionElement >*
CGSyncPositionPacket::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:network.CGSyncPositionPacket.elements)
  return &_impl_.elements_;
}
inline const ::network::SyncPositionElement& CGSyncPositionPacket::_internal_elements(int index) const {
  return _impl_.elements_.Get(index);
}
inline const ::network::SyncPositionElement& CGSyncPositionPacket::elements(int index) const {
  // @@protoc_insertion_point(field_get:network.CGSyncPositionPacket.elements)
  return _internal_elements(index);
}
inline ::network::SyncPositionElement* CGSyncPositionPacket::_internal_add_elements() {
  return _impl_.elements_.Add();
}
inline ::network::SyncPositionElement* CGSyncPositionPacket::add_elements() {
  ::network::SyncPositionElement* _add = _internal_add_elements();
  // @@protoc_insertion_point(field_add:network.CGSyncPositionPacket.elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::SyncPositionElement >&
CGSyncPositionPacket::elements() const {
  // @@protoc_insertion_point(field_list:network.CGSyncPositionPacket.elements)
  return _impl_.elements_;
}

// -------------------------------------------------------------------

// CGFlyTargetPacket

// uint32 target_vid = 1;
inline void CGFlyTargetPacket::clear_target_vid() {
  _impl_.target_vid_ = 0u;
}
inline uint32_t CGFlyTargetPacket::_internal_target_vid() const {
  return _impl_.target_vid_;
}
inline uint32_t CGFlyTargetPacket::target_vid() const {
  // @@protoc_insertion_point(field_get:network.CGFlyTargetPacket.target_vid)
  return _internal_target_vid();
}
inline void CGFlyTargetPacket::_internal_set_target_vid(uint32_t value) {
  
  _impl_.target_vid_ = value;
}
inline void CGFlyTargetPacket::set_target_vid(uint32_t value) {
  _internal_set_target_vid(value);
  // @@protoc_insertion_point(field_set:network.CGFlyTargetPacket.target_vid)
}

// uint32 x = 2;
inline void CGFlyTargetPacket::clear_x() {
  _impl_.x_ = 0u;
}
inline uint32_t CGFlyTargetPacket::_internal_x() const {
  return _impl_.x_;
}
inline uint32_t CGFlyTargetPacket::x() const {
  // @@protoc_insertion_point(field_get:network.CGFlyTargetPacket.x)
  return _internal_x();
}
inline void CGFlyTargetPacket::_internal_set_x(uint32_t value) {
  
  _impl_.x_ = value;
}
inline void CGFlyTargetPacket::set_x(uint32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:network.CGFlyTargetPacket.x)
}

// uint32 y = 3;
inline void CGFlyTargetPacket::clear_y() {
  _impl_.y_ = 0u;
}
inline uint32_t CGFlyTargetPacket::_internal_y() const {
  return _impl_.y_;
}
inline uint32_t CGFlyTargetPacket::y() const {
  // @@protoc_insertion_point(field_get:network.CGFlyTargetPacket.y)
  return _internal_y();
}
inline void CGFlyTargetPacket::_internal_set_y(uint32_t value) {
  
  _impl_.y_ = value;
}
inline void CGFlyTargetPacket::set_y(uint32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:network.CGFlyTargetPacket.y)
}

// -------------------------------------------------------------------

// CGAddFlyTargetPacket

// uint32 target_vid = 1;
inline void CGAddFlyTargetPacket::clear_target_vid() {
  _impl_.target_vid_ = 0u;
}
inline uint32_t CGAddFlyTargetPacket::_internal_target_vid() const {
  return _impl_.target_vid_;
}
inline uint32_t CGAddFlyTargetPacket::target_vid() const {
  // @@protoc_insertion_point(field_get:network.CGAddFlyTargetPacket.target_vid)
  return _internal_target_vid();
}
inline void CGAddFlyTargetPacket::_internal_set_target_vid(uint32_t value) {
  
  _impl_.target_vid_ = value;
}
inline void CGAddFlyTargetPacket::set_target_vid(uint32_t value) {
  _internal_set_target_vid(value);
  // @@protoc_insertion_point(field_set:network.CGAddFlyTargetPacket.target_vid)
}

// uint32 x = 2;
inline void CGAddFlyTargetPacket::clear_x() {
  _impl_.x_ = 0u;
}
inline uint32_t CGAddFlyTargetPacket::_internal_x() const {
  return _impl_.x_;
}
inline uint32_t CGAddFlyTargetPacket::x() const {
  // @@protoc_insertion_point(field_get:network.CGAddFlyTargetPacket.x)
  return _internal_x();
}
inline void CGAddFlyTargetPacket::_internal_set_x(uint32_t value) {
  
  _impl_.x_ = value;
}
inline void CGAddFlyTargetPacket::set_x(uint32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:network.CGAddFlyTargetPacket.x)
}

// uint32 y = 3;
inline void CGAddFlyTargetPacket::clear_y() {
  _impl_.y_ = 0u;
}
inline uint32_t CGAddFlyTargetPacket::_internal_y() const {
  return _impl_.y_;
}
inline uint32_t CGAddFlyTargetPacket::y() const {
  // @@protoc_insertion_point(field_get:network.CGAddFlyTargetPacket.y)
  return _internal_y();
}
inline void CGAddFlyTargetPacket::_internal_set_y(uint32_t value) {
  
  _impl_.y_ = value;
}
inline void CGAddFlyTargetPacket::set_y(uint32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:network.CGAddFlyTargetPacket.y)
}

// -------------------------------------------------------------------

// CGUseSkillPacket

// uint32 vnum = 1;
inline void CGUseSkillPacket::clear_vnum() {
  _impl_.vnum_ = 0u;
}
inline uint32_t CGUseSkillPacket::_internal_vnum() const {
  return _impl_.vnum_;
}
inline uint32_t CGUseSkillPacket::vnum() const {
  // @@protoc_insertion_point(field_get:network.CGUseSkillPacket.vnum)
  return _internal_vnum();
}
inline void CGUseSkillPacket::_internal_set_vnum(uint32_t value) {
  
  _impl_.vnum_ = value;
}
inline void CGUseSkillPacket::set_vnum(uint32_t value) {
  _internal_set_vnum(value);
  // @@protoc_insertion_point(field_set:network.CGUseSkillPacket.vnum)
}

// uint32 vid = 2;
inline void CGUseSkillPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGUseSkillPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGUseSkillPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGUseSkillPacket.vid)
  return _internal_vid();
}
inline void CGUseSkillPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGUseSkillPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGUseSkillPacket.vid)
}

// -------------------------------------------------------------------

// CGTargetPacket

// uint32 vid = 1;
inline void CGTargetPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGTargetPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGTargetPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGTargetPacket.vid)
  return _internal_vid();
}
inline void CGTargetPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGTargetPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGTargetPacket.vid)
}

// -------------------------------------------------------------------

// CGTargetMonsterDropInfoPacket

// uint32 race_num = 1;
inline void CGTargetMonsterDropInfoPacket::clear_race_num() {
  _impl_.race_num_ = 0u;
}
inline uint32_t CGTargetMonsterDropInfoPacket::_internal_race_num() const {
  return _impl_.race_num_;
}
inline uint32_t CGTargetMonsterDropInfoPacket::race_num() const {
  // @@protoc_insertion_point(field_get:network.CGTargetMonsterDropInfoPacket.race_num)
  return _internal_race_num();
}
inline void CGTargetMonsterDropInfoPacket::_internal_set_race_num(uint32_t value) {
  
  _impl_.race_num_ = value;
}
inline void CGTargetMonsterDropInfoPacket::set_race_num(uint32_t value) {
  _internal_set_race_num(value);
  // @@protoc_insertion_point(field_set:network.CGTargetMonsterDropInfoPacket.race_num)
}

// -------------------------------------------------------------------

// CGFishingPacket

// uint32 dir = 1;
inline void CGFishingPacket::clear_dir() {
  _impl_.dir_ = 0u;
}
inline uint32_t CGFishingPacket::_internal_dir() const {
  return _impl_.dir_;
}
inline uint32_t CGFishingPacket::dir() const {
  // @@protoc_insertion_point(field_get:network.CGFishingPacket.dir)
  return _internal_dir();
}
inline void CGFishingPacket::_internal_set_dir(uint32_t value) {
  
  _impl_.dir_ = value;
}
inline void CGFishingPacket::set_dir(uint32_t value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:network.CGFishingPacket.dir)
}

// -------------------------------------------------------------------

// CGGiveItemPacket

// uint32 target_vid = 1;
inline void CGGiveItemPacket::clear_target_vid() {
  _impl_.target_vid_ = 0u;
}
inline uint32_t CGGiveItemPacket::_internal_target_vid() const {
  return _impl_.target_vid_;
}
inline uint32_t CGGiveItemPacket::target_vid() const {
  // @@protoc_insertion_point(field_get:network.CGGiveItemPacket.target_vid)
  return _internal_target_vid();
}
inline void CGGiveItemPacket::_internal_set_target_vid(uint32_t value) {
  
  _impl_.target_vid_ = value;
}
inline void CGGiveItemPacket::set_target_vid(uint32_t value) {
  _internal_set_target_vid(value);
  // @@protoc_insertion_point(field_set:network.CGGiveItemPacket.target_vid)
}

// .network.TItemPos cell = 2;
inline bool CGGiveItemPacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGGiveItemPacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGGiveItemPacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGGiveItemPacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGGiveItemPacket.cell)
  return _internal_cell();
}
inline void CGGiveItemPacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGGiveItemPacket.cell)
}
inline ::network::TItemPos* CGGiveItemPacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGGiveItemPacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGGiveItemPacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGGiveItemPacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGGiveItemPacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGGiveItemPacket.cell)
  return _msg;
}
inline void CGGiveItemPacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGGiveItemPacket.cell)
}

// uint32 item_count = 3;
inline void CGGiveItemPacket::clear_item_count() {
  _impl_.item_count_ = 0u;
}
inline uint32_t CGGiveItemPacket::_internal_item_count() const {
  return _impl_.item_count_;
}
inline uint32_t CGGiveItemPacket::item_count() const {
  // @@protoc_insertion_point(field_get:network.CGGiveItemPacket.item_count)
  return _internal_item_count();
}
inline void CGGiveItemPacket::_internal_set_item_count(uint32_t value) {
  
  _impl_.item_count_ = value;
}
inline void CGGiveItemPacket::set_item_count(uint32_t value) {
  _internal_set_item_count(value);
  // @@protoc_insertion_point(field_set:network.CGGiveItemPacket.item_count)
}

// -------------------------------------------------------------------

// CGMyShopPacket

// bytes sign = 1;
inline void CGMyShopPacket::clear_sign() {
  _impl_.sign_.ClearToEmpty();
}
inline const std::string& CGMyShopPacket::sign() const {
  // @@protoc_insertion_point(field_get:network.CGMyShopPacket.sign)
  return _internal_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGMyShopPacket::set_sign(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sign_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGMyShopPacket.sign)
}
inline std::string* CGMyShopPacket::mutable_sign() {
  std::string* _s = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:network.CGMyShopPacket.sign)
  return _s;
}
inline const std::string& CGMyShopPacket::_internal_sign() const {
  return _impl_.sign_.Get();
}
inline void CGMyShopPacket::_internal_set_sign(const std::string& value) {
  
  _impl_.sign_.Set(value, GetArenaForAllocation());
}
inline std::string* CGMyShopPacket::_internal_mutable_sign() {
  
  return _impl_.sign_.Mutable(GetArenaForAllocation());
}
inline std::string* CGMyShopPacket::release_sign() {
  // @@protoc_insertion_point(field_release:network.CGMyShopPacket.sign)
  return _impl_.sign_.Release();
}
inline void CGMyShopPacket::set_allocated_sign(std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  _impl_.sign_.SetAllocated(sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_.IsDefault()) {
    _impl_.sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGMyShopPacket.sign)
}

// repeated .network.TShopItemTable items = 2;
inline int CGMyShopPacket::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int CGMyShopPacket::items_size() const {
  return _internal_items_size();
}
inline ::network::TShopItemTable* CGMyShopPacket::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:network.CGMyShopPacket.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable >*
CGMyShopPacket::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:network.CGMyShopPacket.items)
  return &_impl_.items_;
}
inline const ::network::TShopItemTable& CGMyShopPacket::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::network::TShopItemTable& CGMyShopPacket::items(int index) const {
  // @@protoc_insertion_point(field_get:network.CGMyShopPacket.items)
  return _internal_items(index);
}
inline ::network::TShopItemTable* CGMyShopPacket::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::network::TShopItemTable* CGMyShopPacket::add_items() {
  ::network::TShopItemTable* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:network.CGMyShopPacket.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable >&
CGMyShopPacket::items() const {
  // @@protoc_insertion_point(field_list:network.CGMyShopPacket.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// CGRefinePacket

// .network.TItemPos cell = 1;
inline bool CGRefinePacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGRefinePacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGRefinePacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGRefinePacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGRefinePacket.cell)
  return _internal_cell();
}
inline void CGRefinePacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGRefinePacket.cell)
}
inline ::network::TItemPos* CGRefinePacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGRefinePacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGRefinePacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGRefinePacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGRefinePacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGRefinePacket.cell)
  return _msg;
}
inline void CGRefinePacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGRefinePacket.cell)
}

// uint32 type = 2;
inline void CGRefinePacket::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CGRefinePacket::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CGRefinePacket::type() const {
  // @@protoc_insertion_point(field_get:network.CGRefinePacket.type)
  return _internal_type();
}
inline void CGRefinePacket::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CGRefinePacket::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:network.CGRefinePacket.type)
}

// bool fast_refine = 3;
inline void CGRefinePacket::clear_fast_refine() {
  _impl_.fast_refine_ = false;
}
inline bool CGRefinePacket::_internal_fast_refine() const {
  return _impl_.fast_refine_;
}
inline bool CGRefinePacket::fast_refine() const {
  // @@protoc_insertion_point(field_get:network.CGRefinePacket.fast_refine)
  return _internal_fast_refine();
}
inline void CGRefinePacket::_internal_set_fast_refine(bool value) {
  
  _impl_.fast_refine_ = value;
}
inline void CGRefinePacket::set_fast_refine(bool value) {
  _internal_set_fast_refine(value);
  // @@protoc_insertion_point(field_set:network.CGRefinePacket.fast_refine)
}

// -------------------------------------------------------------------

// CGPlayerLanguageInformationPacket

// bytes player_name = 1;
inline void CGPlayerLanguageInformationPacket::clear_player_name() {
  _impl_.player_name_.ClearToEmpty();
}
inline const std::string& CGPlayerLanguageInformationPacket::player_name() const {
  // @@protoc_insertion_point(field_get:network.CGPlayerLanguageInformationPacket.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGPlayerLanguageInformationPacket::set_player_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGPlayerLanguageInformationPacket.player_name)
}
inline std::string* CGPlayerLanguageInformationPacket::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:network.CGPlayerLanguageInformationPacket.player_name)
  return _s;
}
inline const std::string& CGPlayerLanguageInformationPacket::_internal_player_name() const {
  return _impl_.player_name_.Get();
}
inline void CGPlayerLanguageInformationPacket::_internal_set_player_name(const std::string& value) {
  
  _impl_.player_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGPlayerLanguageInformationPacket::_internal_mutable_player_name() {
  
  return _impl_.player_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGPlayerLanguageInformationPacket::release_player_name() {
  // @@protoc_insertion_point(field_release:network.CGPlayerLanguageInformationPacket.player_name)
  return _impl_.player_name_.Release();
}
inline void CGPlayerLanguageInformationPacket::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    
  } else {
    
  }
  _impl_.player_name_.SetAllocated(player_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_name_.IsDefault()) {
    _impl_.player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGPlayerLanguageInformationPacket.player_name)
}

// -------------------------------------------------------------------

// CGReportPacket

// uint32 key = 1;
inline void CGReportPacket::clear_key() {
  _impl_.key_ = 0u;
}
inline uint32_t CGReportPacket::_internal_key() const {
  return _impl_.key_;
}
inline uint32_t CGReportPacket::key() const {
  // @@protoc_insertion_point(field_get:network.CGReportPacket.key)
  return _internal_key();
}
inline void CGReportPacket::_internal_set_key(uint32_t value) {
  
  _impl_.key_ = value;
}
inline void CGReportPacket::set_key(uint32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:network.CGReportPacket.key)
}

// -------------------------------------------------------------------

// CGDragonSoulRefinePacket

// uint32 sub_type = 1;
inline void CGDragonSoulRefinePacket::clear_sub_type() {
  _impl_.sub_type_ = 0u;
}
inline uint32_t CGDragonSoulRefinePacket::_internal_sub_type() const {
  return _impl_.sub_type_;
}
inline uint32_t CGDragonSoulRefinePacket::sub_type() const {
  // @@protoc_insertion_point(field_get:network.CGDragonSoulRefinePacket.sub_type)
  return _internal_sub_type();
}
inline void CGDragonSoulRefinePacket::_internal_set_sub_type(uint32_t value) {
  
  _impl_.sub_type_ = value;
}
inline void CGDragonSoulRefinePacket::set_sub_type(uint32_t value) {
  _internal_set_sub_type(value);
  // @@protoc_insertion_point(field_set:network.CGDragonSoulRefinePacket.sub_type)
}

// repeated .network.TItemPos item_grid = 2;
inline int CGDragonSoulRefinePacket::_internal_item_grid_size() const {
  return _impl_.item_grid_.size();
}
inline int CGDragonSoulRefinePacket::item_grid_size() const {
  return _internal_item_grid_size();
}
inline ::network::TItemPos* CGDragonSoulRefinePacket::mutable_item_grid(int index) {
  // @@protoc_insertion_point(field_mutable:network.CGDragonSoulRefinePacket.item_grid)
  return _impl_.item_grid_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TItemPos >*
CGDragonSoulRefinePacket::mutable_item_grid() {
  // @@protoc_insertion_point(field_mutable_list:network.CGDragonSoulRefinePacket.item_grid)
  return &_impl_.item_grid_;
}
inline const ::network::TItemPos& CGDragonSoulRefinePacket::_internal_item_grid(int index) const {
  return _impl_.item_grid_.Get(index);
}
inline const ::network::TItemPos& CGDragonSoulRefinePacket::item_grid(int index) const {
  // @@protoc_insertion_point(field_get:network.CGDragonSoulRefinePacket.item_grid)
  return _internal_item_grid(index);
}
inline ::network::TItemPos* CGDragonSoulRefinePacket::_internal_add_item_grid() {
  return _impl_.item_grid_.Add();
}
inline ::network::TItemPos* CGDragonSoulRefinePacket::add_item_grid() {
  ::network::TItemPos* _add = _internal_add_item_grid();
  // @@protoc_insertion_point(field_add:network.CGDragonSoulRefinePacket.item_grid)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TItemPos >&
CGDragonSoulRefinePacket::item_grid() const {
  // @@protoc_insertion_point(field_list:network.CGDragonSoulRefinePacket.item_grid)
  return _impl_.item_grid_;
}

// -------------------------------------------------------------------

// CGOnQuestTriggerPacket

// uint32 index = 1;
inline void CGOnQuestTriggerPacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGOnQuestTriggerPacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGOnQuestTriggerPacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGOnQuestTriggerPacket.index)
  return _internal_index();
}
inline void CGOnQuestTriggerPacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGOnQuestTriggerPacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGOnQuestTriggerPacket.index)
}

// int32 arg = 2;
inline void CGOnQuestTriggerPacket::clear_arg() {
  _impl_.arg_ = 0;
}
inline int32_t CGOnQuestTriggerPacket::_internal_arg() const {
  return _impl_.arg_;
}
inline int32_t CGOnQuestTriggerPacket::arg() const {
  // @@protoc_insertion_point(field_get:network.CGOnQuestTriggerPacket.arg)
  return _internal_arg();
}
inline void CGOnQuestTriggerPacket::_internal_set_arg(int32_t value) {
  
  _impl_.arg_ = value;
}
inline void CGOnQuestTriggerPacket::set_arg(int32_t value) {
  _internal_set_arg(value);
  // @@protoc_insertion_point(field_set:network.CGOnQuestTriggerPacket.arg)
}

// -------------------------------------------------------------------

// CGItemMultiUsePacket

// .network.TItemPos cell = 1;
inline bool CGItemMultiUsePacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGItemMultiUsePacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGItemMultiUsePacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGItemMultiUsePacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGItemMultiUsePacket.cell)
  return _internal_cell();
}
inline void CGItemMultiUsePacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGItemMultiUsePacket.cell)
}
inline ::network::TItemPos* CGItemMultiUsePacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGItemMultiUsePacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGItemMultiUsePacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGItemMultiUsePacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGItemMultiUsePacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGItemMultiUsePacket.cell)
  return _msg;
}
inline void CGItemMultiUsePacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGItemMultiUsePacket.cell)
}

// uint32 count = 2;
inline void CGItemMultiUsePacket::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CGItemMultiUsePacket::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CGItemMultiUsePacket::count() const {
  // @@protoc_insertion_point(field_get:network.CGItemMultiUsePacket.count)
  return _internal_count();
}
inline void CGItemMultiUsePacket::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CGItemMultiUsePacket::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:network.CGItemMultiUsePacket.count)
}

// -------------------------------------------------------------------

// CGBotReportLogPacket

// bytes type = 1;
inline void CGBotReportLogPacket::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& CGBotReportLogPacket::type() const {
  // @@protoc_insertion_point(field_get:network.CGBotReportLogPacket.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGBotReportLogPacket::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGBotReportLogPacket.type)
}
inline std::string* CGBotReportLogPacket::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:network.CGBotReportLogPacket.type)
  return _s;
}
inline const std::string& CGBotReportLogPacket::_internal_type() const {
  return _impl_.type_.Get();
}
inline void CGBotReportLogPacket::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* CGBotReportLogPacket::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* CGBotReportLogPacket::release_type() {
  // @@protoc_insertion_point(field_release:network.CGBotReportLogPacket.type)
  return _impl_.type_.Release();
}
inline void CGBotReportLogPacket::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGBotReportLogPacket.type)
}

// bytes detail = 2;
inline void CGBotReportLogPacket::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& CGBotReportLogPacket::detail() const {
  // @@protoc_insertion_point(field_get:network.CGBotReportLogPacket.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGBotReportLogPacket::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGBotReportLogPacket.detail)
}
inline std::string* CGBotReportLogPacket::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:network.CGBotReportLogPacket.detail)
  return _s;
}
inline const std::string& CGBotReportLogPacket::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void CGBotReportLogPacket::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* CGBotReportLogPacket::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* CGBotReportLogPacket::release_detail() {
  // @@protoc_insertion_point(field_release:network.CGBotReportLogPacket.detail)
  return _impl_.detail_.Release();
}
inline void CGBotReportLogPacket::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGBotReportLogPacket.detail)
}

// -------------------------------------------------------------------

// CGForcedRewarpPacket

// bytes detail_log = 1;
inline void CGForcedRewarpPacket::clear_detail_log() {
  _impl_.detail_log_.ClearToEmpty();
}
inline const std::string& CGForcedRewarpPacket::detail_log() const {
  // @@protoc_insertion_point(field_get:network.CGForcedRewarpPacket.detail_log)
  return _internal_detail_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGForcedRewarpPacket::set_detail_log(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_log_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGForcedRewarpPacket.detail_log)
}
inline std::string* CGForcedRewarpPacket::mutable_detail_log() {
  std::string* _s = _internal_mutable_detail_log();
  // @@protoc_insertion_point(field_mutable:network.CGForcedRewarpPacket.detail_log)
  return _s;
}
inline const std::string& CGForcedRewarpPacket::_internal_detail_log() const {
  return _impl_.detail_log_.Get();
}
inline void CGForcedRewarpPacket::_internal_set_detail_log(const std::string& value) {
  
  _impl_.detail_log_.Set(value, GetArenaForAllocation());
}
inline std::string* CGForcedRewarpPacket::_internal_mutable_detail_log() {
  
  return _impl_.detail_log_.Mutable(GetArenaForAllocation());
}
inline std::string* CGForcedRewarpPacket::release_detail_log() {
  // @@protoc_insertion_point(field_release:network.CGForcedRewarpPacket.detail_log)
  return _impl_.detail_log_.Release();
}
inline void CGForcedRewarpPacket::set_allocated_detail_log(std::string* detail_log) {
  if (detail_log != nullptr) {
    
  } else {
    
  }
  _impl_.detail_log_.SetAllocated(detail_log, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_log_.IsDefault()) {
    _impl_.detail_log_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGForcedRewarpPacket.detail_log)
}

// int32 checkval = 2;
inline void CGForcedRewarpPacket::clear_checkval() {
  _impl_.checkval_ = 0;
}
inline int32_t CGForcedRewarpPacket::_internal_checkval() const {
  return _impl_.checkval_;
}
inline int32_t CGForcedRewarpPacket::checkval() const {
  // @@protoc_insertion_point(field_get:network.CGForcedRewarpPacket.checkval)
  return _internal_checkval();
}
inline void CGForcedRewarpPacket::_internal_set_checkval(int32_t value) {
  
  _impl_.checkval_ = value;
}
inline void CGForcedRewarpPacket::set_checkval(int32_t value) {
  _internal_set_checkval(value);
  // @@protoc_insertion_point(field_set:network.CGForcedRewarpPacket.checkval)
}

// -------------------------------------------------------------------

// CGUseDetachmentSinglePacket

// uint32 cell_detachment = 1;
inline void CGUseDetachmentSinglePacket::clear_cell_detachment() {
  _impl_.cell_detachment_ = 0u;
}
inline uint32_t CGUseDetachmentSinglePacket::_internal_cell_detachment() const {
  return _impl_.cell_detachment_;
}
inline uint32_t CGUseDetachmentSinglePacket::cell_detachment() const {
  // @@protoc_insertion_point(field_get:network.CGUseDetachmentSinglePacket.cell_detachment)
  return _internal_cell_detachment();
}
inline void CGUseDetachmentSinglePacket::_internal_set_cell_detachment(uint32_t value) {
  
  _impl_.cell_detachment_ = value;
}
inline void CGUseDetachmentSinglePacket::set_cell_detachment(uint32_t value) {
  _internal_set_cell_detachment(value);
  // @@protoc_insertion_point(field_set:network.CGUseDetachmentSinglePacket.cell_detachment)
}

// uint32 cell_item = 2;
inline void CGUseDetachmentSinglePacket::clear_cell_item() {
  _impl_.cell_item_ = 0u;
}
inline uint32_t CGUseDetachmentSinglePacket::_internal_cell_item() const {
  return _impl_.cell_item_;
}
inline uint32_t CGUseDetachmentSinglePacket::cell_item() const {
  // @@protoc_insertion_point(field_get:network.CGUseDetachmentSinglePacket.cell_item)
  return _internal_cell_item();
}
inline void CGUseDetachmentSinglePacket::_internal_set_cell_item(uint32_t value) {
  
  _impl_.cell_item_ = value;
}
inline void CGUseDetachmentSinglePacket::set_cell_item(uint32_t value) {
  _internal_set_cell_item(value);
  // @@protoc_insertion_point(field_set:network.CGUseDetachmentSinglePacket.cell_item)
}

// uint32 slot_index = 3;
inline void CGUseDetachmentSinglePacket::clear_slot_index() {
  _impl_.slot_index_ = 0u;
}
inline uint32_t CGUseDetachmentSinglePacket::_internal_slot_index() const {
  return _impl_.slot_index_;
}
inline uint32_t CGUseDetachmentSinglePacket::slot_index() const {
  // @@protoc_insertion_point(field_get:network.CGUseDetachmentSinglePacket.slot_index)
  return _internal_slot_index();
}
inline void CGUseDetachmentSinglePacket::_internal_set_slot_index(uint32_t value) {
  
  _impl_.slot_index_ = value;
}
inline void CGUseDetachmentSinglePacket::set_slot_index(uint32_t value) {
  _internal_set_slot_index(value);
  // @@protoc_insertion_point(field_set:network.CGUseDetachmentSinglePacket.slot_index)
}

// -------------------------------------------------------------------

// CGEventRequestAnswerPacket

// uint32 event_index = 1;
inline void CGEventRequestAnswerPacket::clear_event_index() {
  _impl_.event_index_ = 0u;
}
inline uint32_t CGEventRequestAnswerPacket::_internal_event_index() const {
  return _impl_.event_index_;
}
inline uint32_t CGEventRequestAnswerPacket::event_index() const {
  // @@protoc_insertion_point(field_get:network.CGEventRequestAnswerPacket.event_index)
  return _internal_event_index();
}
inline void CGEventRequestAnswerPacket::_internal_set_event_index(uint32_t value) {
  
  _impl_.event_index_ = value;
}
inline void CGEventRequestAnswerPacket::set_event_index(uint32_t value) {
  _internal_set_event_index(value);
  // @@protoc_insertion_point(field_set:network.CGEventRequestAnswerPacket.event_index)
}

// bool accept = 2;
inline void CGEventRequestAnswerPacket::clear_accept() {
  _impl_.accept_ = false;
}
inline bool CGEventRequestAnswerPacket::_internal_accept() const {
  return _impl_.accept_;
}
inline bool CGEventRequestAnswerPacket::accept() const {
  // @@protoc_insertion_point(field_get:network.CGEventRequestAnswerPacket.accept)
  return _internal_accept();
}
inline void CGEventRequestAnswerPacket::_internal_set_accept(bool value) {
  
  _impl_.accept_ = value;
}
inline void CGEventRequestAnswerPacket::set_accept(bool value) {
  _internal_set_accept(value);
  // @@protoc_insertion_point(field_set:network.CGEventRequestAnswerPacket.accept)
}

// -------------------------------------------------------------------

// CGCostumeBonusTransferPacket

// uint32 sub_header = 1;
inline void CGCostumeBonusTransferPacket::clear_sub_header() {
  _impl_.sub_header_ = 0u;
}
inline uint32_t CGCostumeBonusTransferPacket::_internal_sub_header() const {
  return _impl_.sub_header_;
}
inline uint32_t CGCostumeBonusTransferPacket::sub_header() const {
  // @@protoc_insertion_point(field_get:network.CGCostumeBonusTransferPacket.sub_header)
  return _internal_sub_header();
}
inline void CGCostumeBonusTransferPacket::_internal_set_sub_header(uint32_t value) {
  
  _impl_.sub_header_ = value;
}
inline void CGCostumeBonusTransferPacket::set_sub_header(uint32_t value) {
  _internal_set_sub_header(value);
  // @@protoc_insertion_point(field_set:network.CGCostumeBonusTransferPacket.sub_header)
}

// uint32 pos = 2;
inline void CGCostumeBonusTransferPacket::clear_pos() {
  _impl_.pos_ = 0u;
}
inline uint32_t CGCostumeBonusTransferPacket::_internal_pos() const {
  return _impl_.pos_;
}
inline uint32_t CGCostumeBonusTransferPacket::pos() const {
  // @@protoc_insertion_point(field_get:network.CGCostumeBonusTransferPacket.pos)
  return _internal_pos();
}
inline void CGCostumeBonusTransferPacket::_internal_set_pos(uint32_t value) {
  
  _impl_.pos_ = value;
}
inline void CGCostumeBonusTransferPacket::set_pos(uint32_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:network.CGCostumeBonusTransferPacket.pos)
}

// .network.TItemPos item_cell = 3;
inline bool CGCostumeBonusTransferPacket::_internal_has_item_cell() const {
  return this != internal_default_instance() && _impl_.item_cell_ != nullptr;
}
inline bool CGCostumeBonusTransferPacket::has_item_cell() const {
  return _internal_has_item_cell();
}
inline const ::network::TItemPos& CGCostumeBonusTransferPacket::_internal_item_cell() const {
  const ::network::TItemPos* p = _impl_.item_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGCostumeBonusTransferPacket::item_cell() const {
  // @@protoc_insertion_point(field_get:network.CGCostumeBonusTransferPacket.item_cell)
  return _internal_item_cell();
}
inline void CGCostumeBonusTransferPacket::unsafe_arena_set_allocated_item_cell(
    ::network::TItemPos* item_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_cell_);
  }
  _impl_.item_cell_ = item_cell;
  if (item_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGCostumeBonusTransferPacket.item_cell)
}
inline ::network::TItemPos* CGCostumeBonusTransferPacket::release_item_cell() {
  
  ::network::TItemPos* temp = _impl_.item_cell_;
  _impl_.item_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGCostumeBonusTransferPacket::unsafe_arena_release_item_cell() {
  // @@protoc_insertion_point(field_release:network.CGCostumeBonusTransferPacket.item_cell)
  
  ::network::TItemPos* temp = _impl_.item_cell_;
  _impl_.item_cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGCostumeBonusTransferPacket::_internal_mutable_item_cell() {
  
  if (_impl_.item_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.item_cell_ = p;
  }
  return _impl_.item_cell_;
}
inline ::network::TItemPos* CGCostumeBonusTransferPacket::mutable_item_cell() {
  ::network::TItemPos* _msg = _internal_mutable_item_cell();
  // @@protoc_insertion_point(field_mutable:network.CGCostumeBonusTransferPacket.item_cell)
  return _msg;
}
inline void CGCostumeBonusTransferPacket::set_allocated_item_cell(::network::TItemPos* item_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_cell_);
  }
  if (item_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_cell));
    if (message_arena != submessage_arena) {
      item_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_cell_ = item_cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGCostumeBonusTransferPacket.item_cell)
}

// -------------------------------------------------------------------

// CGRunePagePacket

// .TRunePageData data = 1;
inline bool CGRunePagePacket::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool CGRunePagePacket::has_data() const {
  return _internal_has_data();
}
inline const ::TRunePageData& CGRunePagePacket::_internal_data() const {
  const ::TRunePageData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TRunePageData&>(
      ::_TRunePageData_default_instance_);
}
inline const ::TRunePageData& CGRunePagePacket::data() const {
  // @@protoc_insertion_point(field_get:network.CGRunePagePacket.data)
  return _internal_data();
}
inline void CGRunePagePacket::unsafe_arena_set_allocated_data(
    ::TRunePageData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGRunePagePacket.data)
}
inline ::TRunePageData* CGRunePagePacket::release_data() {
  
  ::TRunePageData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TRunePageData* CGRunePagePacket::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:network.CGRunePagePacket.data)
  
  ::TRunePageData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::TRunePageData* CGRunePagePacket::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TRunePageData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::TRunePageData* CGRunePagePacket::mutable_data() {
  ::TRunePageData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:network.CGRunePagePacket.data)
  return _msg;
}
inline void CGRunePagePacket::set_allocated_data(::TRunePageData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:network.CGRunePagePacket.data)
}

// -------------------------------------------------------------------

// CGRecvWikiPacket

// uint32 vnum = 1;
inline void CGRecvWikiPacket::clear_vnum() {
  _impl_.vnum_ = 0u;
}
inline uint32_t CGRecvWikiPacket::_internal_vnum() const {
  return _impl_.vnum_;
}
inline uint32_t CGRecvWikiPacket::vnum() const {
  // @@protoc_insertion_point(field_get:network.CGRecvWikiPacket.vnum)
  return _internal_vnum();
}
inline void CGRecvWikiPacket::_internal_set_vnum(uint32_t value) {
  
  _impl_.vnum_ = value;
}
inline void CGRecvWikiPacket::set_vnum(uint32_t value) {
  _internal_set_vnum(value);
  // @@protoc_insertion_point(field_set:network.CGRecvWikiPacket.vnum)
}

// bool is_mob = 2;
inline void CGRecvWikiPacket::clear_is_mob() {
  _impl_.is_mob_ = false;
}
inline bool CGRecvWikiPacket::_internal_is_mob() const {
  return _impl_.is_mob_;
}
inline bool CGRecvWikiPacket::is_mob() const {
  // @@protoc_insertion_point(field_get:network.CGRecvWikiPacket.is_mob)
  return _internal_is_mob();
}
inline void CGRecvWikiPacket::_internal_set_is_mob(bool value) {
  
  _impl_.is_mob_ = value;
}
inline void CGRecvWikiPacket::set_is_mob(bool value) {
  _internal_set_is_mob(value);
  // @@protoc_insertion_point(field_set:network.CGRecvWikiPacket.is_mob)
}

// uint64 ret_id = 3;
inline void CGRecvWikiPacket::clear_ret_id() {
  _impl_.ret_id_ = uint64_t{0u};
}
inline uint64_t CGRecvWikiPacket::_internal_ret_id() const {
  return _impl_.ret_id_;
}
inline uint64_t CGRecvWikiPacket::ret_id() const {
  // @@protoc_insertion_point(field_get:network.CGRecvWikiPacket.ret_id)
  return _internal_ret_id();
}
inline void CGRecvWikiPacket::_internal_set_ret_id(uint64_t value) {
  
  _impl_.ret_id_ = value;
}
inline void CGRecvWikiPacket::set_ret_id(uint64_t value) {
  _internal_set_ret_id(value);
  // @@protoc_insertion_point(field_set:network.CGRecvWikiPacket.ret_id)
}

// -------------------------------------------------------------------

// CGSetSkillColorPacket

// uint32 skill = 1;
inline void CGSetSkillColorPacket::clear_skill() {
  _impl_.skill_ = 0u;
}
inline uint32_t CGSetSkillColorPacket::_internal_skill() const {
  return _impl_.skill_;
}
inline uint32_t CGSetSkillColorPacket::skill() const {
  // @@protoc_insertion_point(field_get:network.CGSetSkillColorPacket.skill)
  return _internal_skill();
}
inline void CGSetSkillColorPacket::_internal_set_skill(uint32_t value) {
  
  _impl_.skill_ = value;
}
inline void CGSetSkillColorPacket::set_skill(uint32_t value) {
  _internal_set_skill(value);
  // @@protoc_insertion_point(field_set:network.CGSetSkillColorPacket.skill)
}

// uint32 col1 = 2;
inline void CGSetSkillColorPacket::clear_col1() {
  _impl_.col1_ = 0u;
}
inline uint32_t CGSetSkillColorPacket::_internal_col1() const {
  return _impl_.col1_;
}
inline uint32_t CGSetSkillColorPacket::col1() const {
  // @@protoc_insertion_point(field_get:network.CGSetSkillColorPacket.col1)
  return _internal_col1();
}
inline void CGSetSkillColorPacket::_internal_set_col1(uint32_t value) {
  
  _impl_.col1_ = value;
}
inline void CGSetSkillColorPacket::set_col1(uint32_t value) {
  _internal_set_col1(value);
  // @@protoc_insertion_point(field_set:network.CGSetSkillColorPacket.col1)
}

// uint32 col2 = 3;
inline void CGSetSkillColorPacket::clear_col2() {
  _impl_.col2_ = 0u;
}
inline uint32_t CGSetSkillColorPacket::_internal_col2() const {
  return _impl_.col2_;
}
inline uint32_t CGSetSkillColorPacket::col2() const {
  // @@protoc_insertion_point(field_get:network.CGSetSkillColorPacket.col2)
  return _internal_col2();
}
inline void CGSetSkillColorPacket::_internal_set_col2(uint32_t value) {
  
  _impl_.col2_ = value;
}
inline void CGSetSkillColorPacket::set_col2(uint32_t value) {
  _internal_set_col2(value);
  // @@protoc_insertion_point(field_set:network.CGSetSkillColorPacket.col2)
}

// uint32 col3 = 4;
inline void CGSetSkillColorPacket::clear_col3() {
  _impl_.col3_ = 0u;
}
inline uint32_t CGSetSkillColorPacket::_internal_col3() const {
  return _impl_.col3_;
}
inline uint32_t CGSetSkillColorPacket::col3() const {
  // @@protoc_insertion_point(field_get:network.CGSetSkillColorPacket.col3)
  return _internal_col3();
}
inline void CGSetSkillColorPacket::_internal_set_col3(uint32_t value) {
  
  _impl_.col3_ = value;
}
inline void CGSetSkillColorPacket::set_col3(uint32_t value) {
  _internal_set_col3(value);
  // @@protoc_insertion_point(field_set:network.CGSetSkillColorPacket.col3)
}

// uint32 col4 = 5;
inline void CGSetSkillColorPacket::clear_col4() {
  _impl_.col4_ = 0u;
}
inline uint32_t CGSetSkillColorPacket::_internal_col4() const {
  return _impl_.col4_;
}
inline uint32_t CGSetSkillColorPacket::col4() const {
  // @@protoc_insertion_point(field_get:network.CGSetSkillColorPacket.col4)
  return _internal_col4();
}
inline void CGSetSkillColorPacket::_internal_set_col4(uint32_t value) {
  
  _impl_.col4_ = value;
}
inline void CGSetSkillColorPacket::set_col4(uint32_t value) {
  _internal_set_col4(value);
  // @@protoc_insertion_point(field_set:network.CGSetSkillColorPacket.col4)
}

// uint32 col5 = 6;
inline void CGSetSkillColorPacket::clear_col5() {
  _impl_.col5_ = 0u;
}
inline uint32_t CGSetSkillColorPacket::_internal_col5() const {
  return _impl_.col5_;
}
inline uint32_t CGSetSkillColorPacket::col5() const {
  // @@protoc_insertion_point(field_get:network.CGSetSkillColorPacket.col5)
  return _internal_col5();
}
inline void CGSetSkillColorPacket::_internal_set_col5(uint32_t value) {
  
  _impl_.col5_ = value;
}
inline void CGSetSkillColorPacket::set_col5(uint32_t value) {
  _internal_set_col5(value);
  // @@protoc_insertion_point(field_set:network.CGSetSkillColorPacket.col5)
}

// -------------------------------------------------------------------

// CGEquipmentPageAddPacket

// bytes name = 1;
inline void CGEquipmentPageAddPacket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CGEquipmentPageAddPacket::name() const {
  // @@protoc_insertion_point(field_get:network.CGEquipmentPageAddPacket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGEquipmentPageAddPacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGEquipmentPageAddPacket.name)
}
inline std::string* CGEquipmentPageAddPacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:network.CGEquipmentPageAddPacket.name)
  return _s;
}
inline const std::string& CGEquipmentPageAddPacket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CGEquipmentPageAddPacket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGEquipmentPageAddPacket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGEquipmentPageAddPacket::release_name() {
  // @@protoc_insertion_point(field_release:network.CGEquipmentPageAddPacket.name)
  return _impl_.name_.Release();
}
inline void CGEquipmentPageAddPacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGEquipmentPageAddPacket.name)
}

// -------------------------------------------------------------------

// CGEquipmentPageDeletePacket

// uint32 index = 1;
inline void CGEquipmentPageDeletePacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGEquipmentPageDeletePacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGEquipmentPageDeletePacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGEquipmentPageDeletePacket.index)
  return _internal_index();
}
inline void CGEquipmentPageDeletePacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGEquipmentPageDeletePacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGEquipmentPageDeletePacket.index)
}

// -------------------------------------------------------------------

// CGEquipmentPageSelectPacket

// uint32 index = 1;
inline void CGEquipmentPageSelectPacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGEquipmentPageSelectPacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGEquipmentPageSelectPacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGEquipmentPageSelectPacket.index)
  return _internal_index();
}
inline void CGEquipmentPageSelectPacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGEquipmentPageSelectPacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGEquipmentPageSelectPacket.index)
}

// -------------------------------------------------------------------

// CGCombatZoneRequestActionPacket

// int32 action = 1;
inline void CGCombatZoneRequestActionPacket::clear_action() {
  _impl_.action_ = 0;
}
inline int32_t CGCombatZoneRequestActionPacket::_internal_action() const {
  return _impl_.action_;
}
inline int32_t CGCombatZoneRequestActionPacket::action() const {
  // @@protoc_insertion_point(field_get:network.CGCombatZoneRequestActionPacket.action)
  return _internal_action();
}
inline void CGCombatZoneRequestActionPacket::_internal_set_action(int32_t value) {
  
  _impl_.action_ = value;
}
inline void CGCombatZoneRequestActionPacket::set_action(int32_t value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:network.CGCombatZoneRequestActionPacket.action)
}

// int32 value = 2;
inline void CGCombatZoneRequestActionPacket::clear_value() {
  _impl_.value_ = 0;
}
inline int32_t CGCombatZoneRequestActionPacket::_internal_value() const {
  return _impl_.value_;
}
inline int32_t CGCombatZoneRequestActionPacket::value() const {
  // @@protoc_insertion_point(field_get:network.CGCombatZoneRequestActionPacket.value)
  return _internal_value();
}
inline void CGCombatZoneRequestActionPacket::_internal_set_value(int32_t value) {
  
  _impl_.value_ = value;
}
inline void CGCombatZoneRequestActionPacket::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:network.CGCombatZoneRequestActionPacket.value)
}

// -------------------------------------------------------------------

// CGCrystalRefinePacket

// .network.TItemPos crystal_cell = 1;
inline bool CGCrystalRefinePacket::_internal_has_crystal_cell() const {
  return this != internal_default_instance() && _impl_.crystal_cell_ != nullptr;
}
inline bool CGCrystalRefinePacket::has_crystal_cell() const {
  return _internal_has_crystal_cell();
}
inline const ::network::TItemPos& CGCrystalRefinePacket::_internal_crystal_cell() const {
  const ::network::TItemPos* p = _impl_.crystal_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGCrystalRefinePacket::crystal_cell() const {
  // @@protoc_insertion_point(field_get:network.CGCrystalRefinePacket.crystal_cell)
  return _internal_crystal_cell();
}
inline void CGCrystalRefinePacket::unsafe_arena_set_allocated_crystal_cell(
    ::network::TItemPos* crystal_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.crystal_cell_);
  }
  _impl_.crystal_cell_ = crystal_cell;
  if (crystal_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGCrystalRefinePacket.crystal_cell)
}
inline ::network::TItemPos* CGCrystalRefinePacket::release_crystal_cell() {
  
  ::network::TItemPos* temp = _impl_.crystal_cell_;
  _impl_.crystal_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGCrystalRefinePacket::unsafe_arena_release_crystal_cell() {
  // @@protoc_insertion_point(field_release:network.CGCrystalRefinePacket.crystal_cell)
  
  ::network::TItemPos* temp = _impl_.crystal_cell_;
  _impl_.crystal_cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGCrystalRefinePacket::_internal_mutable_crystal_cell() {
  
  if (_impl_.crystal_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.crystal_cell_ = p;
  }
  return _impl_.crystal_cell_;
}
inline ::network::TItemPos* CGCrystalRefinePacket::mutable_crystal_cell() {
  ::network::TItemPos* _msg = _internal_mutable_crystal_cell();
  // @@protoc_insertion_point(field_mutable:network.CGCrystalRefinePacket.crystal_cell)
  return _msg;
}
inline void CGCrystalRefinePacket::set_allocated_crystal_cell(::network::TItemPos* crystal_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.crystal_cell_);
  }
  if (crystal_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(crystal_cell));
    if (message_arena != submessage_arena) {
      crystal_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crystal_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.crystal_cell_ = crystal_cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGCrystalRefinePacket.crystal_cell)
}

// .network.TItemPos scroll_cell = 2;
inline bool CGCrystalRefinePacket::_internal_has_scroll_cell() const {
  return this != internal_default_instance() && _impl_.scroll_cell_ != nullptr;
}
inline bool CGCrystalRefinePacket::has_scroll_cell() const {
  return _internal_has_scroll_cell();
}
inline const ::network::TItemPos& CGCrystalRefinePacket::_internal_scroll_cell() const {
  const ::network::TItemPos* p = _impl_.scroll_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGCrystalRefinePacket::scroll_cell() const {
  // @@protoc_insertion_point(field_get:network.CGCrystalRefinePacket.scroll_cell)
  return _internal_scroll_cell();
}
inline void CGCrystalRefinePacket::unsafe_arena_set_allocated_scroll_cell(
    ::network::TItemPos* scroll_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scroll_cell_);
  }
  _impl_.scroll_cell_ = scroll_cell;
  if (scroll_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGCrystalRefinePacket.scroll_cell)
}
inline ::network::TItemPos* CGCrystalRefinePacket::release_scroll_cell() {
  
  ::network::TItemPos* temp = _impl_.scroll_cell_;
  _impl_.scroll_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGCrystalRefinePacket::unsafe_arena_release_scroll_cell() {
  // @@protoc_insertion_point(field_release:network.CGCrystalRefinePacket.scroll_cell)
  
  ::network::TItemPos* temp = _impl_.scroll_cell_;
  _impl_.scroll_cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGCrystalRefinePacket::_internal_mutable_scroll_cell() {
  
  if (_impl_.scroll_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.scroll_cell_ = p;
  }
  return _impl_.scroll_cell_;
}
inline ::network::TItemPos* CGCrystalRefinePacket::mutable_scroll_cell() {
  ::network::TItemPos* _msg = _internal_mutable_scroll_cell();
  // @@protoc_insertion_point(field_mutable:network.CGCrystalRefinePacket.scroll_cell)
  return _msg;
}
inline void CGCrystalRefinePacket::set_allocated_scroll_cell(::network::TItemPos* scroll_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scroll_cell_);
  }
  if (scroll_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scroll_cell));
    if (message_arena != submessage_arena) {
      scroll_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scroll_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scroll_cell_ = scroll_cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGCrystalRefinePacket.scroll_cell)
}

// -------------------------------------------------------------------

// CGAuctionInsertItemPacket

// .network.TItemPos cell = 1;
inline bool CGAuctionInsertItemPacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGAuctionInsertItemPacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGAuctionInsertItemPacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGAuctionInsertItemPacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionInsertItemPacket.cell)
  return _internal_cell();
}
inline void CGAuctionInsertItemPacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGAuctionInsertItemPacket.cell)
}
inline ::network::TItemPos* CGAuctionInsertItemPacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGAuctionInsertItemPacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGAuctionInsertItemPacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGAuctionInsertItemPacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGAuctionInsertItemPacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGAuctionInsertItemPacket.cell)
  return _msg;
}
inline void CGAuctionInsertItemPacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGAuctionInsertItemPacket.cell)
}

// .network.TItemPos target_cell = 2;
inline bool CGAuctionInsertItemPacket::_internal_has_target_cell() const {
  return this != internal_default_instance() && _impl_.target_cell_ != nullptr;
}
inline bool CGAuctionInsertItemPacket::has_target_cell() const {
  return _internal_has_target_cell();
}
inline const ::network::TItemPos& CGAuctionInsertItemPacket::_internal_target_cell() const {
  const ::network::TItemPos* p = _impl_.target_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGAuctionInsertItemPacket::target_cell() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionInsertItemPacket.target_cell)
  return _internal_target_cell();
}
inline void CGAuctionInsertItemPacket::unsafe_arena_set_allocated_target_cell(
    ::network::TItemPos* target_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_cell_);
  }
  _impl_.target_cell_ = target_cell;
  if (target_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGAuctionInsertItemPacket.target_cell)
}
inline ::network::TItemPos* CGAuctionInsertItemPacket::release_target_cell() {
  
  ::network::TItemPos* temp = _impl_.target_cell_;
  _impl_.target_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGAuctionInsertItemPacket::unsafe_arena_release_target_cell() {
  // @@protoc_insertion_point(field_release:network.CGAuctionInsertItemPacket.target_cell)
  
  ::network::TItemPos* temp = _impl_.target_cell_;
  _impl_.target_cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGAuctionInsertItemPacket::_internal_mutable_target_cell() {
  
  if (_impl_.target_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.target_cell_ = p;
  }
  return _impl_.target_cell_;
}
inline ::network::TItemPos* CGAuctionInsertItemPacket::mutable_target_cell() {
  ::network::TItemPos* _msg = _internal_mutable_target_cell();
  // @@protoc_insertion_point(field_mutable:network.CGAuctionInsertItemPacket.target_cell)
  return _msg;
}
inline void CGAuctionInsertItemPacket::set_allocated_target_cell(::network::TItemPos* target_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_cell_);
  }
  if (target_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_cell));
    if (message_arena != submessage_arena) {
      target_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_cell_ = target_cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGAuctionInsertItemPacket.target_cell)
}

// uint64 price = 3;
inline void CGAuctionInsertItemPacket::clear_price() {
  _impl_.price_ = uint64_t{0u};
}
inline uint64_t CGAuctionInsertItemPacket::_internal_price() const {
  return _impl_.price_;
}
inline uint64_t CGAuctionInsertItemPacket::price() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionInsertItemPacket.price)
  return _internal_price();
}
inline void CGAuctionInsertItemPacket::_internal_set_price(uint64_t value) {
  
  _impl_.price_ = value;
}
inline void CGAuctionInsertItemPacket::set_price(uint64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionInsertItemPacket.price)
}

// -------------------------------------------------------------------

// CGAuctionTakeItemPacket

// uint32 item_id = 1;
inline void CGAuctionTakeItemPacket::clear_item_id() {
  _impl_.item_id_ = 0u;
}
inline uint32_t CGAuctionTakeItemPacket::_internal_item_id() const {
  return _impl_.item_id_;
}
inline uint32_t CGAuctionTakeItemPacket::item_id() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionTakeItemPacket.item_id)
  return _internal_item_id();
}
inline void CGAuctionTakeItemPacket::_internal_set_item_id(uint32_t value) {
  
  _impl_.item_id_ = value;
}
inline void CGAuctionTakeItemPacket::set_item_id(uint32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionTakeItemPacket.item_id)
}

// uint32 inventory_pos = 2;
inline void CGAuctionTakeItemPacket::clear_inventory_pos() {
  _impl_.inventory_pos_ = 0u;
}
inline uint32_t CGAuctionTakeItemPacket::_internal_inventory_pos() const {
  return _impl_.inventory_pos_;
}
inline uint32_t CGAuctionTakeItemPacket::inventory_pos() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionTakeItemPacket.inventory_pos)
  return _internal_inventory_pos();
}
inline void CGAuctionTakeItemPacket::_internal_set_inventory_pos(uint32_t value) {
  
  _impl_.inventory_pos_ = value;
}
inline void CGAuctionTakeItemPacket::set_inventory_pos(uint32_t value) {
  _internal_set_inventory_pos(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionTakeItemPacket.inventory_pos)
}

// -------------------------------------------------------------------

// CGAuctionBuyItemPacket

// uint32 item_id = 1;
inline void CGAuctionBuyItemPacket::clear_item_id() {
  _impl_.item_id_ = 0u;
}
inline uint32_t CGAuctionBuyItemPacket::_internal_item_id() const {
  return _impl_.item_id_;
}
inline uint32_t CGAuctionBuyItemPacket::item_id() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionBuyItemPacket.item_id)
  return _internal_item_id();
}
inline void CGAuctionBuyItemPacket::_internal_set_item_id(uint32_t value) {
  
  _impl_.item_id_ = value;
}
inline void CGAuctionBuyItemPacket::set_item_id(uint32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionBuyItemPacket.item_id)
}

// uint64 price = 2;
inline void CGAuctionBuyItemPacket::clear_price() {
  _impl_.price_ = uint64_t{0u};
}
inline uint64_t CGAuctionBuyItemPacket::_internal_price() const {
  return _impl_.price_;
}
inline uint64_t CGAuctionBuyItemPacket::price() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionBuyItemPacket.price)
  return _internal_price();
}
inline void CGAuctionBuyItemPacket::_internal_set_price(uint64_t value) {
  
  _impl_.price_ = value;
}
inline void CGAuctionBuyItemPacket::set_price(uint64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionBuyItemPacket.price)
}

// -------------------------------------------------------------------

// CGAuctionTakeGoldPacket

// uint64 gold = 1;
inline void CGAuctionTakeGoldPacket::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t CGAuctionTakeGoldPacket::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t CGAuctionTakeGoldPacket::gold() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionTakeGoldPacket.gold)
  return _internal_gold();
}
inline void CGAuctionTakeGoldPacket::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void CGAuctionTakeGoldPacket::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionTakeGoldPacket.gold)
}

// -------------------------------------------------------------------

// CGAuctionSearchItemsPacket

// uint32 page = 1;
inline void CGAuctionSearchItemsPacket::clear_page() {
  _impl_.page_ = 0u;
}
inline uint32_t CGAuctionSearchItemsPacket::_internal_page() const {
  return _impl_.page_;
}
inline uint32_t CGAuctionSearchItemsPacket::page() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionSearchItemsPacket.page)
  return _internal_page();
}
inline void CGAuctionSearchItemsPacket::_internal_set_page(uint32_t value) {
  
  _impl_.page_ = value;
}
inline void CGAuctionSearchItemsPacket::set_page(uint32_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionSearchItemsPacket.page)
}

// .network.TDataAuctionSearch options = 2;
inline bool CGAuctionSearchItemsPacket::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool CGAuctionSearchItemsPacket::has_options() const {
  return _internal_has_options();
}
inline const ::network::TDataAuctionSearch& CGAuctionSearchItemsPacket::_internal_options() const {
  const ::network::TDataAuctionSearch* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TDataAuctionSearch&>(
      ::network::_TDataAuctionSearch_default_instance_);
}
inline const ::network::TDataAuctionSearch& CGAuctionSearchItemsPacket::options() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionSearchItemsPacket.options)
  return _internal_options();
}
inline void CGAuctionSearchItemsPacket::unsafe_arena_set_allocated_options(
    ::network::TDataAuctionSearch* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGAuctionSearchItemsPacket.options)
}
inline ::network::TDataAuctionSearch* CGAuctionSearchItemsPacket::release_options() {
  
  ::network::TDataAuctionSearch* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TDataAuctionSearch* CGAuctionSearchItemsPacket::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:network.CGAuctionSearchItemsPacket.options)
  
  ::network::TDataAuctionSearch* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::network::TDataAuctionSearch* CGAuctionSearchItemsPacket::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TDataAuctionSearch>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::network::TDataAuctionSearch* CGAuctionSearchItemsPacket::mutable_options() {
  ::network::TDataAuctionSearch* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:network.CGAuctionSearchItemsPacket.options)
  return _msg;
}
inline void CGAuctionSearchItemsPacket::set_allocated_options(::network::TDataAuctionSearch* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:network.CGAuctionSearchItemsPacket.options)
}

// -------------------------------------------------------------------

// CGAuctionExtendedSearchItemsPacket

// uint32 page = 1;
inline void CGAuctionExtendedSearchItemsPacket::clear_page() {
  _impl_.page_ = 0u;
}
inline uint32_t CGAuctionExtendedSearchItemsPacket::_internal_page() const {
  return _impl_.page_;
}
inline uint32_t CGAuctionExtendedSearchItemsPacket::page() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionExtendedSearchItemsPacket.page)
  return _internal_page();
}
inline void CGAuctionExtendedSearchItemsPacket::_internal_set_page(uint32_t value) {
  
  _impl_.page_ = value;
}
inline void CGAuctionExtendedSearchItemsPacket::set_page(uint32_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionExtendedSearchItemsPacket.page)
}

// .network.TExtendedDataAuctionSearch options = 2;
inline bool CGAuctionExtendedSearchItemsPacket::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool CGAuctionExtendedSearchItemsPacket::has_options() const {
  return _internal_has_options();
}
inline const ::network::TExtendedDataAuctionSearch& CGAuctionExtendedSearchItemsPacket::_internal_options() const {
  const ::network::TExtendedDataAuctionSearch* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TExtendedDataAuctionSearch&>(
      ::network::_TExtendedDataAuctionSearch_default_instance_);
}
inline const ::network::TExtendedDataAuctionSearch& CGAuctionExtendedSearchItemsPacket::options() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionExtendedSearchItemsPacket.options)
  return _internal_options();
}
inline void CGAuctionExtendedSearchItemsPacket::unsafe_arena_set_allocated_options(
    ::network::TExtendedDataAuctionSearch* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGAuctionExtendedSearchItemsPacket.options)
}
inline ::network::TExtendedDataAuctionSearch* CGAuctionExtendedSearchItemsPacket::release_options() {
  
  ::network::TExtendedDataAuctionSearch* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TExtendedDataAuctionSearch* CGAuctionExtendedSearchItemsPacket::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:network.CGAuctionExtendedSearchItemsPacket.options)
  
  ::network::TExtendedDataAuctionSearch* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::network::TExtendedDataAuctionSearch* CGAuctionExtendedSearchItemsPacket::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TExtendedDataAuctionSearch>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::network::TExtendedDataAuctionSearch* CGAuctionExtendedSearchItemsPacket::mutable_options() {
  ::network::TExtendedDataAuctionSearch* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:network.CGAuctionExtendedSearchItemsPacket.options)
  return _msg;
}
inline void CGAuctionExtendedSearchItemsPacket::set_allocated_options(::network::TExtendedDataAuctionSearch* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:network.CGAuctionExtendedSearchItemsPacket.options)
}

// -------------------------------------------------------------------

// CGAuctionMarkShopPacket

// uint32 item_id = 1;
inline void CGAuctionMarkShopPacket::clear_item_id() {
  _impl_.item_id_ = 0u;
}
inline uint32_t CGAuctionMarkShopPacket::_internal_item_id() const {
  return _impl_.item_id_;
}
inline uint32_t CGAuctionMarkShopPacket::item_id() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionMarkShopPacket.item_id)
  return _internal_item_id();
}
inline void CGAuctionMarkShopPacket::_internal_set_item_id(uint32_t value) {
  
  _impl_.item_id_ = value;
}
inline void CGAuctionMarkShopPacket::set_item_id(uint32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionMarkShopPacket.item_id)
}

// -------------------------------------------------------------------

// CGAuctionShopOpenPacket

// bytes name = 1;
inline void CGAuctionShopOpenPacket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CGAuctionShopOpenPacket::name() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGAuctionShopOpenPacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGAuctionShopOpenPacket.name)
}
inline std::string* CGAuctionShopOpenPacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:network.CGAuctionShopOpenPacket.name)
  return _s;
}
inline const std::string& CGAuctionShopOpenPacket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CGAuctionShopOpenPacket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGAuctionShopOpenPacket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGAuctionShopOpenPacket::release_name() {
  // @@protoc_insertion_point(field_release:network.CGAuctionShopOpenPacket.name)
  return _impl_.name_.Release();
}
inline void CGAuctionShopOpenPacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGAuctionShopOpenPacket.name)
}

// uint32 style = 2;
inline void CGAuctionShopOpenPacket::clear_style() {
  _impl_.style_ = 0u;
}
inline uint32_t CGAuctionShopOpenPacket::_internal_style() const {
  return _impl_.style_;
}
inline uint32_t CGAuctionShopOpenPacket::style() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.style)
  return _internal_style();
}
inline void CGAuctionShopOpenPacket::_internal_set_style(uint32_t value) {
  
  _impl_.style_ = value;
}
inline void CGAuctionShopOpenPacket::set_style(uint32_t value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopOpenPacket.style)
}

// uint32 model = 3;
inline void CGAuctionShopOpenPacket::clear_model() {
  _impl_.model_ = 0u;
}
inline uint32_t CGAuctionShopOpenPacket::_internal_model() const {
  return _impl_.model_;
}
inline uint32_t CGAuctionShopOpenPacket::model() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.model)
  return _internal_model();
}
inline void CGAuctionShopOpenPacket::_internal_set_model(uint32_t value) {
  
  _impl_.model_ = value;
}
inline void CGAuctionShopOpenPacket::set_model(uint32_t value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopOpenPacket.model)
}

// float color_red = 4;
inline void CGAuctionShopOpenPacket::clear_color_red() {
  _impl_.color_red_ = 0;
}
inline float CGAuctionShopOpenPacket::_internal_color_red() const {
  return _impl_.color_red_;
}
inline float CGAuctionShopOpenPacket::color_red() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.color_red)
  return _internal_color_red();
}
inline void CGAuctionShopOpenPacket::_internal_set_color_red(float value) {
  
  _impl_.color_red_ = value;
}
inline void CGAuctionShopOpenPacket::set_color_red(float value) {
  _internal_set_color_red(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopOpenPacket.color_red)
}

// float color_green = 5;
inline void CGAuctionShopOpenPacket::clear_color_green() {
  _impl_.color_green_ = 0;
}
inline float CGAuctionShopOpenPacket::_internal_color_green() const {
  return _impl_.color_green_;
}
inline float CGAuctionShopOpenPacket::color_green() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.color_green)
  return _internal_color_green();
}
inline void CGAuctionShopOpenPacket::_internal_set_color_green(float value) {
  
  _impl_.color_green_ = value;
}
inline void CGAuctionShopOpenPacket::set_color_green(float value) {
  _internal_set_color_green(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopOpenPacket.color_green)
}

// float color_blue = 6;
inline void CGAuctionShopOpenPacket::clear_color_blue() {
  _impl_.color_blue_ = 0;
}
inline float CGAuctionShopOpenPacket::_internal_color_blue() const {
  return _impl_.color_blue_;
}
inline float CGAuctionShopOpenPacket::color_blue() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.color_blue)
  return _internal_color_blue();
}
inline void CGAuctionShopOpenPacket::_internal_set_color_blue(float value) {
  
  _impl_.color_blue_ = value;
}
inline void CGAuctionShopOpenPacket::set_color_blue(float value) {
  _internal_set_color_blue(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopOpenPacket.color_blue)
}

// uint32 x = 7;
inline void CGAuctionShopOpenPacket::clear_x() {
  _impl_.x_ = 0u;
}
inline uint32_t CGAuctionShopOpenPacket::_internal_x() const {
  return _impl_.x_;
}
inline uint32_t CGAuctionShopOpenPacket::x() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.x)
  return _internal_x();
}
inline void CGAuctionShopOpenPacket::_internal_set_x(uint32_t value) {
  
  _impl_.x_ = value;
}
inline void CGAuctionShopOpenPacket::set_x(uint32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopOpenPacket.x)
}

// uint32 y = 8;
inline void CGAuctionShopOpenPacket::clear_y() {
  _impl_.y_ = 0u;
}
inline uint32_t CGAuctionShopOpenPacket::_internal_y() const {
  return _impl_.y_;
}
inline uint32_t CGAuctionShopOpenPacket::y() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.y)
  return _internal_y();
}
inline void CGAuctionShopOpenPacket::_internal_set_y(uint32_t value) {
  
  _impl_.y_ = value;
}
inline void CGAuctionShopOpenPacket::set_y(uint32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopOpenPacket.y)
}

// repeated .network.TShopItemTable items = 9;
inline int CGAuctionShopOpenPacket::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int CGAuctionShopOpenPacket::items_size() const {
  return _internal_items_size();
}
inline ::network::TShopItemTable* CGAuctionShopOpenPacket::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:network.CGAuctionShopOpenPacket.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable >*
CGAuctionShopOpenPacket::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:network.CGAuctionShopOpenPacket.items)
  return &_impl_.items_;
}
inline const ::network::TShopItemTable& CGAuctionShopOpenPacket::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::network::TShopItemTable& CGAuctionShopOpenPacket::items(int index) const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopOpenPacket.items)
  return _internal_items(index);
}
inline ::network::TShopItemTable* CGAuctionShopOpenPacket::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::network::TShopItemTable* CGAuctionShopOpenPacket::add_items() {
  ::network::TShopItemTable* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:network.CGAuctionShopOpenPacket.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::network::TShopItemTable >&
CGAuctionShopOpenPacket::items() const {
  // @@protoc_insertion_point(field_list:network.CGAuctionShopOpenPacket.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// CGAuctionShopClosePacket

// bool has_items = 1;
inline void CGAuctionShopClosePacket::clear_has_items() {
  _impl_.has_items_ = false;
}
inline bool CGAuctionShopClosePacket::_internal_has_items() const {
  return _impl_.has_items_;
}
inline bool CGAuctionShopClosePacket::has_items() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopClosePacket.has_items)
  return _internal_has_items();
}
inline void CGAuctionShopClosePacket::_internal_set_has_items(bool value) {
  
  _impl_.has_items_ = value;
}
inline void CGAuctionShopClosePacket::set_has_items(bool value) {
  _internal_set_has_items(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopClosePacket.has_items)
}

// -------------------------------------------------------------------

// CGAuctionShopTakeGoldPacket

// uint64 gold = 1;
inline void CGAuctionShopTakeGoldPacket::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t CGAuctionShopTakeGoldPacket::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t CGAuctionShopTakeGoldPacket::gold() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionShopTakeGoldPacket.gold)
  return _internal_gold();
}
inline void CGAuctionShopTakeGoldPacket::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void CGAuctionShopTakeGoldPacket::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionShopTakeGoldPacket.gold)
}

// -------------------------------------------------------------------

// CGAuctionRequestAveragePricePacket

// uint32 requestor = 1;
inline void CGAuctionRequestAveragePricePacket::clear_requestor() {
  _impl_.requestor_ = 0u;
}
inline uint32_t CGAuctionRequestAveragePricePacket::_internal_requestor() const {
  return _impl_.requestor_;
}
inline uint32_t CGAuctionRequestAveragePricePacket::requestor() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionRequestAveragePricePacket.requestor)
  return _internal_requestor();
}
inline void CGAuctionRequestAveragePricePacket::_internal_set_requestor(uint32_t value) {
  
  _impl_.requestor_ = value;
}
inline void CGAuctionRequestAveragePricePacket::set_requestor(uint32_t value) {
  _internal_set_requestor(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionRequestAveragePricePacket.requestor)
}

// uint32 vnum = 2;
inline void CGAuctionRequestAveragePricePacket::clear_vnum() {
  _impl_.vnum_ = 0u;
}
inline uint32_t CGAuctionRequestAveragePricePacket::_internal_vnum() const {
  return _impl_.vnum_;
}
inline uint32_t CGAuctionRequestAveragePricePacket::vnum() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionRequestAveragePricePacket.vnum)
  return _internal_vnum();
}
inline void CGAuctionRequestAveragePricePacket::_internal_set_vnum(uint32_t value) {
  
  _impl_.vnum_ = value;
}
inline void CGAuctionRequestAveragePricePacket::set_vnum(uint32_t value) {
  _internal_set_vnum(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionRequestAveragePricePacket.vnum)
}

// uint32 count = 3;
inline void CGAuctionRequestAveragePricePacket::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CGAuctionRequestAveragePricePacket::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CGAuctionRequestAveragePricePacket::count() const {
  // @@protoc_insertion_point(field_get:network.CGAuctionRequestAveragePricePacket.count)
  return _internal_count();
}
inline void CGAuctionRequestAveragePricePacket::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CGAuctionRequestAveragePricePacket::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:network.CGAuctionRequestAveragePricePacket.count)
}

// -------------------------------------------------------------------

// CGScriptAnswerPacket

// uint32 answer = 1;
inline void CGScriptAnswerPacket::clear_answer() {
  _impl_.answer_ = 0u;
}
inline uint32_t CGScriptAnswerPacket::_internal_answer() const {
  return _impl_.answer_;
}
inline uint32_t CGScriptAnswerPacket::answer() const {
  // @@protoc_insertion_point(field_get:network.CGScriptAnswerPacket.answer)
  return _internal_answer();
}
inline void CGScriptAnswerPacket::_internal_set_answer(uint32_t value) {
  
  _impl_.answer_ = value;
}
inline void CGScriptAnswerPacket::set_answer(uint32_t value) {
  _internal_set_answer(value);
  // @@protoc_insertion_point(field_set:network.CGScriptAnswerPacket.answer)
}

// -------------------------------------------------------------------

// CGScriptButtonPacket

// uint32 index = 1;
inline void CGScriptButtonPacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGScriptButtonPacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGScriptButtonPacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGScriptButtonPacket.index)
  return _internal_index();
}
inline void CGScriptButtonPacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGScriptButtonPacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGScriptButtonPacket.index)
}

// -------------------------------------------------------------------

// CGScriptSelectItemPacket

// uint32 selection = 1;
inline void CGScriptSelectItemPacket::clear_selection() {
  _impl_.selection_ = 0u;
}
inline uint32_t CGScriptSelectItemPacket::_internal_selection() const {
  return _impl_.selection_;
}
inline uint32_t CGScriptSelectItemPacket::selection() const {
  // @@protoc_insertion_point(field_get:network.CGScriptSelectItemPacket.selection)
  return _internal_selection();
}
inline void CGScriptSelectItemPacket::_internal_set_selection(uint32_t value) {
  
  _impl_.selection_ = value;
}
inline void CGScriptSelectItemPacket::set_selection(uint32_t value) {
  _internal_set_selection(value);
  // @@protoc_insertion_point(field_set:network.CGScriptSelectItemPacket.selection)
}

// -------------------------------------------------------------------

// CGQuestInputStringPacket

// bytes message = 1;
inline void CGQuestInputStringPacket::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CGQuestInputStringPacket::message() const {
  // @@protoc_insertion_point(field_get:network.CGQuestInputStringPacket.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGQuestInputStringPacket::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGQuestInputStringPacket.message)
}
inline std::string* CGQuestInputStringPacket::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:network.CGQuestInputStringPacket.message)
  return _s;
}
inline const std::string& CGQuestInputStringPacket::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CGQuestInputStringPacket::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CGQuestInputStringPacket::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CGQuestInputStringPacket::release_message() {
  // @@protoc_insertion_point(field_release:network.CGQuestInputStringPacket.message)
  return _impl_.message_.Release();
}
inline void CGQuestInputStringPacket::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGQuestInputStringPacket.message)
}

// -------------------------------------------------------------------

// CGQuestConfirmPacket

// uint32 answer = 1;
inline void CGQuestConfirmPacket::clear_answer() {
  _impl_.answer_ = 0u;
}
inline uint32_t CGQuestConfirmPacket::_internal_answer() const {
  return _impl_.answer_;
}
inline uint32_t CGQuestConfirmPacket::answer() const {
  // @@protoc_insertion_point(field_get:network.CGQuestConfirmPacket.answer)
  return _internal_answer();
}
inline void CGQuestConfirmPacket::_internal_set_answer(uint32_t value) {
  
  _impl_.answer_ = value;
}
inline void CGQuestConfirmPacket::set_answer(uint32_t value) {
  _internal_set_answer(value);
  // @@protoc_insertion_point(field_set:network.CGQuestConfirmPacket.answer)
}

// uint32 request_pid = 2;
inline void CGQuestConfirmPacket::clear_request_pid() {
  _impl_.request_pid_ = 0u;
}
inline uint32_t CGQuestConfirmPacket::_internal_request_pid() const {
  return _impl_.request_pid_;
}
inline uint32_t CGQuestConfirmPacket::request_pid() const {
  // @@protoc_insertion_point(field_get:network.CGQuestConfirmPacket.request_pid)
  return _internal_request_pid();
}
inline void CGQuestConfirmPacket::_internal_set_request_pid(uint32_t value) {
  
  _impl_.request_pid_ = value;
}
inline void CGQuestConfirmPacket::set_request_pid(uint32_t value) {
  _internal_set_request_pid(value);
  // @@protoc_insertion_point(field_set:network.CGQuestConfirmPacket.request_pid)
}

// -------------------------------------------------------------------

// CGItemUsePacket

// .network.TItemPos cell = 1;
inline bool CGItemUsePacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGItemUsePacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGItemUsePacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGItemUsePacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGItemUsePacket.cell)
  return _internal_cell();
}
inline void CGItemUsePacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGItemUsePacket.cell)
}
inline ::network::TItemPos* CGItemUsePacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGItemUsePacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGItemUsePacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGItemUsePacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGItemUsePacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGItemUsePacket.cell)
  return _msg;
}
inline void CGItemUsePacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGItemUsePacket.cell)
}

// uint32 count = 2;
inline void CGItemUsePacket::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CGItemUsePacket::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CGItemUsePacket::count() const {
  // @@protoc_insertion_point(field_get:network.CGItemUsePacket.count)
  return _internal_count();
}
inline void CGItemUsePacket::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CGItemUsePacket::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:network.CGItemUsePacket.count)
}

// -------------------------------------------------------------------

// CGItemUseToItemPacket

// .network.TItemPos cell = 1;
inline bool CGItemUseToItemPacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGItemUseToItemPacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGItemUseToItemPacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGItemUseToItemPacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGItemUseToItemPacket.cell)
  return _internal_cell();
}
inline void CGItemUseToItemPacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGItemUseToItemPacket.cell)
}
inline ::network::TItemPos* CGItemUseToItemPacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGItemUseToItemPacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGItemUseToItemPacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGItemUseToItemPacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGItemUseToItemPacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGItemUseToItemPacket.cell)
  return _msg;
}
inline void CGItemUseToItemPacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGItemUseToItemPacket.cell)
}

// .network.TItemPos target_cell = 2;
inline bool CGItemUseToItemPacket::_internal_has_target_cell() const {
  return this != internal_default_instance() && _impl_.target_cell_ != nullptr;
}
inline bool CGItemUseToItemPacket::has_target_cell() const {
  return _internal_has_target_cell();
}
inline const ::network::TItemPos& CGItemUseToItemPacket::_internal_target_cell() const {
  const ::network::TItemPos* p = _impl_.target_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGItemUseToItemPacket::target_cell() const {
  // @@protoc_insertion_point(field_get:network.CGItemUseToItemPacket.target_cell)
  return _internal_target_cell();
}
inline void CGItemUseToItemPacket::unsafe_arena_set_allocated_target_cell(
    ::network::TItemPos* target_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_cell_);
  }
  _impl_.target_cell_ = target_cell;
  if (target_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGItemUseToItemPacket.target_cell)
}
inline ::network::TItemPos* CGItemUseToItemPacket::release_target_cell() {
  
  ::network::TItemPos* temp = _impl_.target_cell_;
  _impl_.target_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGItemUseToItemPacket::unsafe_arena_release_target_cell() {
  // @@protoc_insertion_point(field_release:network.CGItemUseToItemPacket.target_cell)
  
  ::network::TItemPos* temp = _impl_.target_cell_;
  _impl_.target_cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGItemUseToItemPacket::_internal_mutable_target_cell() {
  
  if (_impl_.target_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.target_cell_ = p;
  }
  return _impl_.target_cell_;
}
inline ::network::TItemPos* CGItemUseToItemPacket::mutable_target_cell() {
  ::network::TItemPos* _msg = _internal_mutable_target_cell();
  // @@protoc_insertion_point(field_mutable:network.CGItemUseToItemPacket.target_cell)
  return _msg;
}
inline void CGItemUseToItemPacket::set_allocated_target_cell(::network::TItemPos* target_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_cell_);
  }
  if (target_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_cell));
    if (message_arena != submessage_arena) {
      target_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_cell_ = target_cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGItemUseToItemPacket.target_cell)
}

// -------------------------------------------------------------------

// CGItemDropPacket

// .network.TItemPos cell = 1;
inline bool CGItemDropPacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGItemDropPacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGItemDropPacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGItemDropPacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGItemDropPacket.cell)
  return _internal_cell();
}
inline void CGItemDropPacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGItemDropPacket.cell)
}
inline ::network::TItemPos* CGItemDropPacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGItemDropPacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGItemDropPacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGItemDropPacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGItemDropPacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGItemDropPacket.cell)
  return _msg;
}
inline void CGItemDropPacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGItemDropPacket.cell)
}

// uint32 gold = 2;
inline void CGItemDropPacket::clear_gold() {
  _impl_.gold_ = 0u;
}
inline uint32_t CGItemDropPacket::_internal_gold() const {
  return _impl_.gold_;
}
inline uint32_t CGItemDropPacket::gold() const {
  // @@protoc_insertion_point(field_get:network.CGItemDropPacket.gold)
  return _internal_gold();
}
inline void CGItemDropPacket::_internal_set_gold(uint32_t value) {
  
  _impl_.gold_ = value;
}
inline void CGItemDropPacket::set_gold(uint32_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:network.CGItemDropPacket.gold)
}

// uint32 count = 3;
inline void CGItemDropPacket::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CGItemDropPacket::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CGItemDropPacket::count() const {
  // @@protoc_insertion_point(field_get:network.CGItemDropPacket.count)
  return _internal_count();
}
inline void CGItemDropPacket::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CGItemDropPacket::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:network.CGItemDropPacket.count)
}

// -------------------------------------------------------------------

// CGItemDestroyPacket

// .network.TItemPos cell = 1;
inline bool CGItemDestroyPacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGItemDestroyPacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGItemDestroyPacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGItemDestroyPacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGItemDestroyPacket.cell)
  return _internal_cell();
}
inline void CGItemDestroyPacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGItemDestroyPacket.cell)
}
inline ::network::TItemPos* CGItemDestroyPacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGItemDestroyPacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGItemDestroyPacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGItemDestroyPacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGItemDestroyPacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGItemDestroyPacket.cell)
  return _msg;
}
inline void CGItemDestroyPacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGItemDestroyPacket.cell)
}

// uint32 num = 2;
inline void CGItemDestroyPacket::clear_num() {
  _impl_.num_ = 0u;
}
inline uint32_t CGItemDestroyPacket::_internal_num() const {
  return _impl_.num_;
}
inline uint32_t CGItemDestroyPacket::num() const {
  // @@protoc_insertion_point(field_get:network.CGItemDestroyPacket.num)
  return _internal_num();
}
inline void CGItemDestroyPacket::_internal_set_num(uint32_t value) {
  
  _impl_.num_ = value;
}
inline void CGItemDestroyPacket::set_num(uint32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:network.CGItemDestroyPacket.num)
}

// -------------------------------------------------------------------

// CGItemMovePacket

// .network.TItemPos cell = 1;
inline bool CGItemMovePacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGItemMovePacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGItemMovePacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGItemMovePacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGItemMovePacket.cell)
  return _internal_cell();
}
inline void CGItemMovePacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGItemMovePacket.cell)
}
inline ::network::TItemPos* CGItemMovePacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGItemMovePacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGItemMovePacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGItemMovePacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGItemMovePacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGItemMovePacket.cell)
  return _msg;
}
inline void CGItemMovePacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGItemMovePacket.cell)
}

// .network.TItemPos cell_to = 2;
inline bool CGItemMovePacket::_internal_has_cell_to() const {
  return this != internal_default_instance() && _impl_.cell_to_ != nullptr;
}
inline bool CGItemMovePacket::has_cell_to() const {
  return _internal_has_cell_to();
}
inline const ::network::TItemPos& CGItemMovePacket::_internal_cell_to() const {
  const ::network::TItemPos* p = _impl_.cell_to_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGItemMovePacket::cell_to() const {
  // @@protoc_insertion_point(field_get:network.CGItemMovePacket.cell_to)
  return _internal_cell_to();
}
inline void CGItemMovePacket::unsafe_arena_set_allocated_cell_to(
    ::network::TItemPos* cell_to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_to_);
  }
  _impl_.cell_to_ = cell_to;
  if (cell_to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGItemMovePacket.cell_to)
}
inline ::network::TItemPos* CGItemMovePacket::release_cell_to() {
  
  ::network::TItemPos* temp = _impl_.cell_to_;
  _impl_.cell_to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGItemMovePacket::unsafe_arena_release_cell_to() {
  // @@protoc_insertion_point(field_release:network.CGItemMovePacket.cell_to)
  
  ::network::TItemPos* temp = _impl_.cell_to_;
  _impl_.cell_to_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGItemMovePacket::_internal_mutable_cell_to() {
  
  if (_impl_.cell_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_to_ = p;
  }
  return _impl_.cell_to_;
}
inline ::network::TItemPos* CGItemMovePacket::mutable_cell_to() {
  ::network::TItemPos* _msg = _internal_mutable_cell_to();
  // @@protoc_insertion_point(field_mutable:network.CGItemMovePacket.cell_to)
  return _msg;
}
inline void CGItemMovePacket::set_allocated_cell_to(::network::TItemPos* cell_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_to_);
  }
  if (cell_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_to));
    if (message_arena != submessage_arena) {
      cell_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell_to, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_to_ = cell_to;
  // @@protoc_insertion_point(field_set_allocated:network.CGItemMovePacket.cell_to)
}

// uint32 count = 3;
inline void CGItemMovePacket::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CGItemMovePacket::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CGItemMovePacket::count() const {
  // @@protoc_insertion_point(field_get:network.CGItemMovePacket.count)
  return _internal_count();
}
inline void CGItemMovePacket::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CGItemMovePacket::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:network.CGItemMovePacket.count)
}

// -------------------------------------------------------------------

// CGItemPickupPacket

// uint32 vid = 1;
inline void CGItemPickupPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGItemPickupPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGItemPickupPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGItemPickupPacket.vid)
  return _internal_vid();
}
inline void CGItemPickupPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGItemPickupPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGItemPickupPacket.vid)
}

// -------------------------------------------------------------------

// CGSafeboxCheckinPacket

// uint32 safebox_pos = 1;
inline void CGSafeboxCheckinPacket::clear_safebox_pos() {
  _impl_.safebox_pos_ = 0u;
}
inline uint32_t CGSafeboxCheckinPacket::_internal_safebox_pos() const {
  return _impl_.safebox_pos_;
}
inline uint32_t CGSafeboxCheckinPacket::safebox_pos() const {
  // @@protoc_insertion_point(field_get:network.CGSafeboxCheckinPacket.safebox_pos)
  return _internal_safebox_pos();
}
inline void CGSafeboxCheckinPacket::_internal_set_safebox_pos(uint32_t value) {
  
  _impl_.safebox_pos_ = value;
}
inline void CGSafeboxCheckinPacket::set_safebox_pos(uint32_t value) {
  _internal_set_safebox_pos(value);
  // @@protoc_insertion_point(field_set:network.CGSafeboxCheckinPacket.safebox_pos)
}

// .network.TItemPos inventory_pos = 2;
inline bool CGSafeboxCheckinPacket::_internal_has_inventory_pos() const {
  return this != internal_default_instance() && _impl_.inventory_pos_ != nullptr;
}
inline bool CGSafeboxCheckinPacket::has_inventory_pos() const {
  return _internal_has_inventory_pos();
}
inline const ::network::TItemPos& CGSafeboxCheckinPacket::_internal_inventory_pos() const {
  const ::network::TItemPos* p = _impl_.inventory_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGSafeboxCheckinPacket::inventory_pos() const {
  // @@protoc_insertion_point(field_get:network.CGSafeboxCheckinPacket.inventory_pos)
  return _internal_inventory_pos();
}
inline void CGSafeboxCheckinPacket::unsafe_arena_set_allocated_inventory_pos(
    ::network::TItemPos* inventory_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inventory_pos_);
  }
  _impl_.inventory_pos_ = inventory_pos;
  if (inventory_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGSafeboxCheckinPacket.inventory_pos)
}
inline ::network::TItemPos* CGSafeboxCheckinPacket::release_inventory_pos() {
  
  ::network::TItemPos* temp = _impl_.inventory_pos_;
  _impl_.inventory_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGSafeboxCheckinPacket::unsafe_arena_release_inventory_pos() {
  // @@protoc_insertion_point(field_release:network.CGSafeboxCheckinPacket.inventory_pos)
  
  ::network::TItemPos* temp = _impl_.inventory_pos_;
  _impl_.inventory_pos_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGSafeboxCheckinPacket::_internal_mutable_inventory_pos() {
  
  if (_impl_.inventory_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.inventory_pos_ = p;
  }
  return _impl_.inventory_pos_;
}
inline ::network::TItemPos* CGSafeboxCheckinPacket::mutable_inventory_pos() {
  ::network::TItemPos* _msg = _internal_mutable_inventory_pos();
  // @@protoc_insertion_point(field_mutable:network.CGSafeboxCheckinPacket.inventory_pos)
  return _msg;
}
inline void CGSafeboxCheckinPacket::set_allocated_inventory_pos(::network::TItemPos* inventory_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inventory_pos_);
  }
  if (inventory_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inventory_pos));
    if (message_arena != submessage_arena) {
      inventory_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inventory_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inventory_pos_ = inventory_pos;
  // @@protoc_insertion_point(field_set_allocated:network.CGSafeboxCheckinPacket.inventory_pos)
}

// -------------------------------------------------------------------

// CGSafeboxCheckoutPacket

// uint32 safebox_pos = 1;
inline void CGSafeboxCheckoutPacket::clear_safebox_pos() {
  _impl_.safebox_pos_ = 0u;
}
inline uint32_t CGSafeboxCheckoutPacket::_internal_safebox_pos() const {
  return _impl_.safebox_pos_;
}
inline uint32_t CGSafeboxCheckoutPacket::safebox_pos() const {
  // @@protoc_insertion_point(field_get:network.CGSafeboxCheckoutPacket.safebox_pos)
  return _internal_safebox_pos();
}
inline void CGSafeboxCheckoutPacket::_internal_set_safebox_pos(uint32_t value) {
  
  _impl_.safebox_pos_ = value;
}
inline void CGSafeboxCheckoutPacket::set_safebox_pos(uint32_t value) {
  _internal_set_safebox_pos(value);
  // @@protoc_insertion_point(field_set:network.CGSafeboxCheckoutPacket.safebox_pos)
}

// .network.TItemPos inventory_pos = 2;
inline bool CGSafeboxCheckoutPacket::_internal_has_inventory_pos() const {
  return this != internal_default_instance() && _impl_.inventory_pos_ != nullptr;
}
inline bool CGSafeboxCheckoutPacket::has_inventory_pos() const {
  return _internal_has_inventory_pos();
}
inline const ::network::TItemPos& CGSafeboxCheckoutPacket::_internal_inventory_pos() const {
  const ::network::TItemPos* p = _impl_.inventory_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGSafeboxCheckoutPacket::inventory_pos() const {
  // @@protoc_insertion_point(field_get:network.CGSafeboxCheckoutPacket.inventory_pos)
  return _internal_inventory_pos();
}
inline void CGSafeboxCheckoutPacket::unsafe_arena_set_allocated_inventory_pos(
    ::network::TItemPos* inventory_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inventory_pos_);
  }
  _impl_.inventory_pos_ = inventory_pos;
  if (inventory_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGSafeboxCheckoutPacket.inventory_pos)
}
inline ::network::TItemPos* CGSafeboxCheckoutPacket::release_inventory_pos() {
  
  ::network::TItemPos* temp = _impl_.inventory_pos_;
  _impl_.inventory_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGSafeboxCheckoutPacket::unsafe_arena_release_inventory_pos() {
  // @@protoc_insertion_point(field_release:network.CGSafeboxCheckoutPacket.inventory_pos)
  
  ::network::TItemPos* temp = _impl_.inventory_pos_;
  _impl_.inventory_pos_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGSafeboxCheckoutPacket::_internal_mutable_inventory_pos() {
  
  if (_impl_.inventory_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.inventory_pos_ = p;
  }
  return _impl_.inventory_pos_;
}
inline ::network::TItemPos* CGSafeboxCheckoutPacket::mutable_inventory_pos() {
  ::network::TItemPos* _msg = _internal_mutable_inventory_pos();
  // @@protoc_insertion_point(field_mutable:network.CGSafeboxCheckoutPacket.inventory_pos)
  return _msg;
}
inline void CGSafeboxCheckoutPacket::set_allocated_inventory_pos(::network::TItemPos* inventory_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inventory_pos_);
  }
  if (inventory_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inventory_pos));
    if (message_arena != submessage_arena) {
      inventory_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inventory_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inventory_pos_ = inventory_pos;
  // @@protoc_insertion_point(field_set_allocated:network.CGSafeboxCheckoutPacket.inventory_pos)
}

// bool is_mall = 3;
inline void CGSafeboxCheckoutPacket::clear_is_mall() {
  _impl_.is_mall_ = false;
}
inline bool CGSafeboxCheckoutPacket::_internal_is_mall() const {
  return _impl_.is_mall_;
}
inline bool CGSafeboxCheckoutPacket::is_mall() const {
  // @@protoc_insertion_point(field_get:network.CGSafeboxCheckoutPacket.is_mall)
  return _internal_is_mall();
}
inline void CGSafeboxCheckoutPacket::_internal_set_is_mall(bool value) {
  
  _impl_.is_mall_ = value;
}
inline void CGSafeboxCheckoutPacket::set_is_mall(bool value) {
  _internal_set_is_mall(value);
  // @@protoc_insertion_point(field_set:network.CGSafeboxCheckoutPacket.is_mall)
}

// -------------------------------------------------------------------

// CGSafeboxItemMovePacket

// uint32 source_pos = 1;
inline void CGSafeboxItemMovePacket::clear_source_pos() {
  _impl_.source_pos_ = 0u;
}
inline uint32_t CGSafeboxItemMovePacket::_internal_source_pos() const {
  return _impl_.source_pos_;
}
inline uint32_t CGSafeboxItemMovePacket::source_pos() const {
  // @@protoc_insertion_point(field_get:network.CGSafeboxItemMovePacket.source_pos)
  return _internal_source_pos();
}
inline void CGSafeboxItemMovePacket::_internal_set_source_pos(uint32_t value) {
  
  _impl_.source_pos_ = value;
}
inline void CGSafeboxItemMovePacket::set_source_pos(uint32_t value) {
  _internal_set_source_pos(value);
  // @@protoc_insertion_point(field_set:network.CGSafeboxItemMovePacket.source_pos)
}

// uint32 target_pos = 2;
inline void CGSafeboxItemMovePacket::clear_target_pos() {
  _impl_.target_pos_ = 0u;
}
inline uint32_t CGSafeboxItemMovePacket::_internal_target_pos() const {
  return _impl_.target_pos_;
}
inline uint32_t CGSafeboxItemMovePacket::target_pos() const {
  // @@protoc_insertion_point(field_get:network.CGSafeboxItemMovePacket.target_pos)
  return _internal_target_pos();
}
inline void CGSafeboxItemMovePacket::_internal_set_target_pos(uint32_t value) {
  
  _impl_.target_pos_ = value;
}
inline void CGSafeboxItemMovePacket::set_target_pos(uint32_t value) {
  _internal_set_target_pos(value);
  // @@protoc_insertion_point(field_set:network.CGSafeboxItemMovePacket.target_pos)
}

// uint32 count = 3;
inline void CGSafeboxItemMovePacket::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CGSafeboxItemMovePacket::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CGSafeboxItemMovePacket::count() const {
  // @@protoc_insertion_point(field_get:network.CGSafeboxItemMovePacket.count)
  return _internal_count();
}
inline void CGSafeboxItemMovePacket::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CGSafeboxItemMovePacket::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:network.CGSafeboxItemMovePacket.count)
}

// -------------------------------------------------------------------

// CGAcceRefineCheckinPacket

// .network.TItemPos item_cell = 1;
inline bool CGAcceRefineCheckinPacket::_internal_has_item_cell() const {
  return this != internal_default_instance() && _impl_.item_cell_ != nullptr;
}
inline bool CGAcceRefineCheckinPacket::has_item_cell() const {
  return _internal_has_item_cell();
}
inline const ::network::TItemPos& CGAcceRefineCheckinPacket::_internal_item_cell() const {
  const ::network::TItemPos* p = _impl_.item_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGAcceRefineCheckinPacket::item_cell() const {
  // @@protoc_insertion_point(field_get:network.CGAcceRefineCheckinPacket.item_cell)
  return _internal_item_cell();
}
inline void CGAcceRefineCheckinPacket::unsafe_arena_set_allocated_item_cell(
    ::network::TItemPos* item_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_cell_);
  }
  _impl_.item_cell_ = item_cell;
  if (item_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGAcceRefineCheckinPacket.item_cell)
}
inline ::network::TItemPos* CGAcceRefineCheckinPacket::release_item_cell() {
  
  ::network::TItemPos* temp = _impl_.item_cell_;
  _impl_.item_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGAcceRefineCheckinPacket::unsafe_arena_release_item_cell() {
  // @@protoc_insertion_point(field_release:network.CGAcceRefineCheckinPacket.item_cell)
  
  ::network::TItemPos* temp = _impl_.item_cell_;
  _impl_.item_cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGAcceRefineCheckinPacket::_internal_mutable_item_cell() {
  
  if (_impl_.item_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.item_cell_ = p;
  }
  return _impl_.item_cell_;
}
inline ::network::TItemPos* CGAcceRefineCheckinPacket::mutable_item_cell() {
  ::network::TItemPos* _msg = _internal_mutable_item_cell();
  // @@protoc_insertion_point(field_mutable:network.CGAcceRefineCheckinPacket.item_cell)
  return _msg;
}
inline void CGAcceRefineCheckinPacket::set_allocated_item_cell(::network::TItemPos* item_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_cell_);
  }
  if (item_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_cell));
    if (message_arena != submessage_arena) {
      item_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_cell_ = item_cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGAcceRefineCheckinPacket.item_cell)
}

// uint32 acce_pos = 2;
inline void CGAcceRefineCheckinPacket::clear_acce_pos() {
  _impl_.acce_pos_ = 0u;
}
inline uint32_t CGAcceRefineCheckinPacket::_internal_acce_pos() const {
  return _impl_.acce_pos_;
}
inline uint32_t CGAcceRefineCheckinPacket::acce_pos() const {
  // @@protoc_insertion_point(field_get:network.CGAcceRefineCheckinPacket.acce_pos)
  return _internal_acce_pos();
}
inline void CGAcceRefineCheckinPacket::_internal_set_acce_pos(uint32_t value) {
  
  _impl_.acce_pos_ = value;
}
inline void CGAcceRefineCheckinPacket::set_acce_pos(uint32_t value) {
  _internal_set_acce_pos(value);
  // @@protoc_insertion_point(field_set:network.CGAcceRefineCheckinPacket.acce_pos)
}

// -------------------------------------------------------------------

// CGAcceRefineCheckoutPacket

// uint32 acce_pos = 1;
inline void CGAcceRefineCheckoutPacket::clear_acce_pos() {
  _impl_.acce_pos_ = 0u;
}
inline uint32_t CGAcceRefineCheckoutPacket::_internal_acce_pos() const {
  return _impl_.acce_pos_;
}
inline uint32_t CGAcceRefineCheckoutPacket::acce_pos() const {
  // @@protoc_insertion_point(field_get:network.CGAcceRefineCheckoutPacket.acce_pos)
  return _internal_acce_pos();
}
inline void CGAcceRefineCheckoutPacket::_internal_set_acce_pos(uint32_t value) {
  
  _impl_.acce_pos_ = value;
}
inline void CGAcceRefineCheckoutPacket::set_acce_pos(uint32_t value) {
  _internal_set_acce_pos(value);
  // @@protoc_insertion_point(field_set:network.CGAcceRefineCheckoutPacket.acce_pos)
}

// -------------------------------------------------------------------

// CGAcceRefineAcceptPacket

// uint32 window_type = 1;
inline void CGAcceRefineAcceptPacket::clear_window_type() {
  _impl_.window_type_ = 0u;
}
inline uint32_t CGAcceRefineAcceptPacket::_internal_window_type() const {
  return _impl_.window_type_;
}
inline uint32_t CGAcceRefineAcceptPacket::window_type() const {
  // @@protoc_insertion_point(field_get:network.CGAcceRefineAcceptPacket.window_type)
  return _internal_window_type();
}
inline void CGAcceRefineAcceptPacket::_internal_set_window_type(uint32_t value) {
  
  _impl_.window_type_ = value;
}
inline void CGAcceRefineAcceptPacket::set_window_type(uint32_t value) {
  _internal_set_window_type(value);
  // @@protoc_insertion_point(field_set:network.CGAcceRefineAcceptPacket.window_type)
}

// -------------------------------------------------------------------

// CGQuickslotAddPacket

// uint32 pos = 1;
inline void CGQuickslotAddPacket::clear_pos() {
  _impl_.pos_ = 0u;
}
inline uint32_t CGQuickslotAddPacket::_internal_pos() const {
  return _impl_.pos_;
}
inline uint32_t CGQuickslotAddPacket::pos() const {
  // @@protoc_insertion_point(field_get:network.CGQuickslotAddPacket.pos)
  return _internal_pos();
}
inline void CGQuickslotAddPacket::_internal_set_pos(uint32_t value) {
  
  _impl_.pos_ = value;
}
inline void CGQuickslotAddPacket::set_pos(uint32_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:network.CGQuickslotAddPacket.pos)
}

// .TQuickslot slot = 2;
inline bool CGQuickslotAddPacket::_internal_has_slot() const {
  return this != internal_default_instance() && _impl_.slot_ != nullptr;
}
inline bool CGQuickslotAddPacket::has_slot() const {
  return _internal_has_slot();
}
inline const ::TQuickslot& CGQuickslotAddPacket::_internal_slot() const {
  const ::TQuickslot* p = _impl_.slot_;
  return p != nullptr ? *p : reinterpret_cast<const ::TQuickslot&>(
      ::_TQuickslot_default_instance_);
}
inline const ::TQuickslot& CGQuickslotAddPacket::slot() const {
  // @@protoc_insertion_point(field_get:network.CGQuickslotAddPacket.slot)
  return _internal_slot();
}
inline void CGQuickslotAddPacket::unsafe_arena_set_allocated_slot(
    ::TQuickslot* slot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.slot_);
  }
  _impl_.slot_ = slot;
  if (slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGQuickslotAddPacket.slot)
}
inline ::TQuickslot* CGQuickslotAddPacket::release_slot() {
  
  ::TQuickslot* temp = _impl_.slot_;
  _impl_.slot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TQuickslot* CGQuickslotAddPacket::unsafe_arena_release_slot() {
  // @@protoc_insertion_point(field_release:network.CGQuickslotAddPacket.slot)
  
  ::TQuickslot* temp = _impl_.slot_;
  _impl_.slot_ = nullptr;
  return temp;
}
inline ::TQuickslot* CGQuickslotAddPacket::_internal_mutable_slot() {
  
  if (_impl_.slot_ == nullptr) {
    auto* p = CreateMaybeMessage<::TQuickslot>(GetArenaForAllocation());
    _impl_.slot_ = p;
  }
  return _impl_.slot_;
}
inline ::TQuickslot* CGQuickslotAddPacket::mutable_slot() {
  ::TQuickslot* _msg = _internal_mutable_slot();
  // @@protoc_insertion_point(field_mutable:network.CGQuickslotAddPacket.slot)
  return _msg;
}
inline void CGQuickslotAddPacket::set_allocated_slot(::TQuickslot* slot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.slot_);
  }
  if (slot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slot));
    if (message_arena != submessage_arena) {
      slot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slot, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.slot_ = slot;
  // @@protoc_insertion_point(field_set_allocated:network.CGQuickslotAddPacket.slot)
}

// -------------------------------------------------------------------

// CGQuickslotDeletePacket

// uint32 pos = 1;
inline void CGQuickslotDeletePacket::clear_pos() {
  _impl_.pos_ = 0u;
}
inline uint32_t CGQuickslotDeletePacket::_internal_pos() const {
  return _impl_.pos_;
}
inline uint32_t CGQuickslotDeletePacket::pos() const {
  // @@protoc_insertion_point(field_get:network.CGQuickslotDeletePacket.pos)
  return _internal_pos();
}
inline void CGQuickslotDeletePacket::_internal_set_pos(uint32_t value) {
  
  _impl_.pos_ = value;
}
inline void CGQuickslotDeletePacket::set_pos(uint32_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:network.CGQuickslotDeletePacket.pos)
}

// -------------------------------------------------------------------

// CGQuickslotSwapPacket

// uint32 pos = 1;
inline void CGQuickslotSwapPacket::clear_pos() {
  _impl_.pos_ = 0u;
}
inline uint32_t CGQuickslotSwapPacket::_internal_pos() const {
  return _impl_.pos_;
}
inline uint32_t CGQuickslotSwapPacket::pos() const {
  // @@protoc_insertion_point(field_get:network.CGQuickslotSwapPacket.pos)
  return _internal_pos();
}
inline void CGQuickslotSwapPacket::_internal_set_pos(uint32_t value) {
  
  _impl_.pos_ = value;
}
inline void CGQuickslotSwapPacket::set_pos(uint32_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:network.CGQuickslotSwapPacket.pos)
}

// uint32 change_pos = 2;
inline void CGQuickslotSwapPacket::clear_change_pos() {
  _impl_.change_pos_ = 0u;
}
inline uint32_t CGQuickslotSwapPacket::_internal_change_pos() const {
  return _impl_.change_pos_;
}
inline uint32_t CGQuickslotSwapPacket::change_pos() const {
  // @@protoc_insertion_point(field_get:network.CGQuickslotSwapPacket.change_pos)
  return _internal_change_pos();
}
inline void CGQuickslotSwapPacket::_internal_set_change_pos(uint32_t value) {
  
  _impl_.change_pos_ = value;
}
inline void CGQuickslotSwapPacket::set_change_pos(uint32_t value) {
  _internal_set_change_pos(value);
  // @@protoc_insertion_point(field_set:network.CGQuickslotSwapPacket.change_pos)
}

// -------------------------------------------------------------------

// CGShopBuyPacket

// uint32 pos = 1;
inline void CGShopBuyPacket::clear_pos() {
  _impl_.pos_ = 0u;
}
inline uint32_t CGShopBuyPacket::_internal_pos() const {
  return _impl_.pos_;
}
inline uint32_t CGShopBuyPacket::pos() const {
  // @@protoc_insertion_point(field_get:network.CGShopBuyPacket.pos)
  return _internal_pos();
}
inline void CGShopBuyPacket::_internal_set_pos(uint32_t value) {
  
  _impl_.pos_ = value;
}
inline void CGShopBuyPacket::set_pos(uint32_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:network.CGShopBuyPacket.pos)
}

// -------------------------------------------------------------------

// CGShopSellPacket

// .network.TItemPos cell = 1;
inline bool CGShopSellPacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGShopSellPacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGShopSellPacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGShopSellPacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGShopSellPacket.cell)
  return _internal_cell();
}
inline void CGShopSellPacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGShopSellPacket.cell)
}
inline ::network::TItemPos* CGShopSellPacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGShopSellPacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGShopSellPacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGShopSellPacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGShopSellPacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGShopSellPacket.cell)
  return _msg;
}
inline void CGShopSellPacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGShopSellPacket.cell)
}

// uint32 count = 2;
inline void CGShopSellPacket::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CGShopSellPacket::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CGShopSellPacket::count() const {
  // @@protoc_insertion_point(field_get:network.CGShopSellPacket.count)
  return _internal_count();
}
inline void CGShopSellPacket::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CGShopSellPacket::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:network.CGShopSellPacket.count)
}

// -------------------------------------------------------------------

// CGExchangeStartPacket

// uint32 other_vid = 1;
inline void CGExchangeStartPacket::clear_other_vid() {
  _impl_.other_vid_ = 0u;
}
inline uint32_t CGExchangeStartPacket::_internal_other_vid() const {
  return _impl_.other_vid_;
}
inline uint32_t CGExchangeStartPacket::other_vid() const {
  // @@protoc_insertion_point(field_get:network.CGExchangeStartPacket.other_vid)
  return _internal_other_vid();
}
inline void CGExchangeStartPacket::_internal_set_other_vid(uint32_t value) {
  
  _impl_.other_vid_ = value;
}
inline void CGExchangeStartPacket::set_other_vid(uint32_t value) {
  _internal_set_other_vid(value);
  // @@protoc_insertion_point(field_set:network.CGExchangeStartPacket.other_vid)
}

// -------------------------------------------------------------------

// CGExchangeItemAddPacket

// .network.TItemPos cell = 1;
inline bool CGExchangeItemAddPacket::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool CGExchangeItemAddPacket::has_cell() const {
  return _internal_has_cell();
}
inline const ::network::TItemPos& CGExchangeItemAddPacket::_internal_cell() const {
  const ::network::TItemPos* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGExchangeItemAddPacket::cell() const {
  // @@protoc_insertion_point(field_get:network.CGExchangeItemAddPacket.cell)
  return _internal_cell();
}
inline void CGExchangeItemAddPacket::unsafe_arena_set_allocated_cell(
    ::network::TItemPos* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGExchangeItemAddPacket.cell)
}
inline ::network::TItemPos* CGExchangeItemAddPacket::release_cell() {
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGExchangeItemAddPacket::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:network.CGExchangeItemAddPacket.cell)
  
  ::network::TItemPos* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGExchangeItemAddPacket::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::network::TItemPos* CGExchangeItemAddPacket::mutable_cell() {
  ::network::TItemPos* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:network.CGExchangeItemAddPacket.cell)
  return _msg;
}
inline void CGExchangeItemAddPacket::set_allocated_cell(::network::TItemPos* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGExchangeItemAddPacket.cell)
}

// uint32 display_pos = 2;
inline void CGExchangeItemAddPacket::clear_display_pos() {
  _impl_.display_pos_ = 0u;
}
inline uint32_t CGExchangeItemAddPacket::_internal_display_pos() const {
  return _impl_.display_pos_;
}
inline uint32_t CGExchangeItemAddPacket::display_pos() const {
  // @@protoc_insertion_point(field_get:network.CGExchangeItemAddPacket.display_pos)
  return _internal_display_pos();
}
inline void CGExchangeItemAddPacket::_internal_set_display_pos(uint32_t value) {
  
  _impl_.display_pos_ = value;
}
inline void CGExchangeItemAddPacket::set_display_pos(uint32_t value) {
  _internal_set_display_pos(value);
  // @@protoc_insertion_point(field_set:network.CGExchangeItemAddPacket.display_pos)
}

// -------------------------------------------------------------------

// CGExchangeItemDelPacket

// uint32 display_pos = 1;
inline void CGExchangeItemDelPacket::clear_display_pos() {
  _impl_.display_pos_ = 0u;
}
inline uint32_t CGExchangeItemDelPacket::_internal_display_pos() const {
  return _impl_.display_pos_;
}
inline uint32_t CGExchangeItemDelPacket::display_pos() const {
  // @@protoc_insertion_point(field_get:network.CGExchangeItemDelPacket.display_pos)
  return _internal_display_pos();
}
inline void CGExchangeItemDelPacket::_internal_set_display_pos(uint32_t value) {
  
  _impl_.display_pos_ = value;
}
inline void CGExchangeItemDelPacket::set_display_pos(uint32_t value) {
  _internal_set_display_pos(value);
  // @@protoc_insertion_point(field_set:network.CGExchangeItemDelPacket.display_pos)
}

// -------------------------------------------------------------------

// CGExchangeGoldAddPacket

// uint64 gold = 1;
inline void CGExchangeGoldAddPacket::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t CGExchangeGoldAddPacket::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t CGExchangeGoldAddPacket::gold() const {
  // @@protoc_insertion_point(field_get:network.CGExchangeGoldAddPacket.gold)
  return _internal_gold();
}
inline void CGExchangeGoldAddPacket::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void CGExchangeGoldAddPacket::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:network.CGExchangeGoldAddPacket.gold)
}

// -------------------------------------------------------------------

// CGMessengerAddByVIDPacket

// uint32 vid = 1;
inline void CGMessengerAddByVIDPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGMessengerAddByVIDPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGMessengerAddByVIDPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGMessengerAddByVIDPacket.vid)
  return _internal_vid();
}
inline void CGMessengerAddByVIDPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGMessengerAddByVIDPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGMessengerAddByVIDPacket.vid)
}

// -------------------------------------------------------------------

// CGMessengerAddByNamePacket

// bytes name = 1;
inline void CGMessengerAddByNamePacket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CGMessengerAddByNamePacket::name() const {
  // @@protoc_insertion_point(field_get:network.CGMessengerAddByNamePacket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGMessengerAddByNamePacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGMessengerAddByNamePacket.name)
}
inline std::string* CGMessengerAddByNamePacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:network.CGMessengerAddByNamePacket.name)
  return _s;
}
inline const std::string& CGMessengerAddByNamePacket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CGMessengerAddByNamePacket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGMessengerAddByNamePacket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGMessengerAddByNamePacket::release_name() {
  // @@protoc_insertion_point(field_release:network.CGMessengerAddByNamePacket.name)
  return _impl_.name_.Release();
}
inline void CGMessengerAddByNamePacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGMessengerAddByNamePacket.name)
}

// -------------------------------------------------------------------

// CGMessengerRemovePacket

// bytes name = 1;
inline void CGMessengerRemovePacket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CGMessengerRemovePacket::name() const {
  // @@protoc_insertion_point(field_get:network.CGMessengerRemovePacket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGMessengerRemovePacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGMessengerRemovePacket.name)
}
inline std::string* CGMessengerRemovePacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:network.CGMessengerRemovePacket.name)
  return _s;
}
inline const std::string& CGMessengerRemovePacket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CGMessengerRemovePacket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGMessengerRemovePacket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGMessengerRemovePacket::release_name() {
  // @@protoc_insertion_point(field_release:network.CGMessengerRemovePacket.name)
  return _impl_.name_.Release();
}
inline void CGMessengerRemovePacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGMessengerRemovePacket.name)
}

// -------------------------------------------------------------------

// CGMessengerAddBlockByVIDPacket

// uint32 vid = 1;
inline void CGMessengerAddBlockByVIDPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGMessengerAddBlockByVIDPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGMessengerAddBlockByVIDPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGMessengerAddBlockByVIDPacket.vid)
  return _internal_vid();
}
inline void CGMessengerAddBlockByVIDPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGMessengerAddBlockByVIDPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGMessengerAddBlockByVIDPacket.vid)
}

// -------------------------------------------------------------------

// CGMessengerAddBlockByNamePacket

// bytes name = 1;
inline void CGMessengerAddBlockByNamePacket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CGMessengerAddBlockByNamePacket::name() const {
  // @@protoc_insertion_point(field_get:network.CGMessengerAddBlockByNamePacket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGMessengerAddBlockByNamePacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGMessengerAddBlockByNamePacket.name)
}
inline std::string* CGMessengerAddBlockByNamePacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:network.CGMessengerAddBlockByNamePacket.name)
  return _s;
}
inline const std::string& CGMessengerAddBlockByNamePacket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CGMessengerAddBlockByNamePacket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGMessengerAddBlockByNamePacket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGMessengerAddBlockByNamePacket::release_name() {
  // @@protoc_insertion_point(field_release:network.CGMessengerAddBlockByNamePacket.name)
  return _impl_.name_.Release();
}
inline void CGMessengerAddBlockByNamePacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGMessengerAddBlockByNamePacket.name)
}

// -------------------------------------------------------------------

// CGMessengerRemoveBlockPacket

// bytes name = 1;
inline void CGMessengerRemoveBlockPacket::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CGMessengerRemoveBlockPacket::name() const {
  // @@protoc_insertion_point(field_get:network.CGMessengerRemoveBlockPacket.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGMessengerRemoveBlockPacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGMessengerRemoveBlockPacket.name)
}
inline std::string* CGMessengerRemoveBlockPacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:network.CGMessengerRemoveBlockPacket.name)
  return _s;
}
inline const std::string& CGMessengerRemoveBlockPacket::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CGMessengerRemoveBlockPacket::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGMessengerRemoveBlockPacket::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGMessengerRemoveBlockPacket::release_name() {
  // @@protoc_insertion_point(field_release:network.CGMessengerRemoveBlockPacket.name)
  return _impl_.name_.Release();
}
inline void CGMessengerRemoveBlockPacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGMessengerRemoveBlockPacket.name)
}

// -------------------------------------------------------------------

// CGPartyInvitePacket

// uint32 vid = 1;
inline void CGPartyInvitePacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGPartyInvitePacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGPartyInvitePacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGPartyInvitePacket.vid)
  return _internal_vid();
}
inline void CGPartyInvitePacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGPartyInvitePacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGPartyInvitePacket.vid)
}

// -------------------------------------------------------------------

// CGPartyInviteAnswerPacket

// uint32 leader_vid = 1;
inline void CGPartyInviteAnswerPacket::clear_leader_vid() {
  _impl_.leader_vid_ = 0u;
}
inline uint32_t CGPartyInviteAnswerPacket::_internal_leader_vid() const {
  return _impl_.leader_vid_;
}
inline uint32_t CGPartyInviteAnswerPacket::leader_vid() const {
  // @@protoc_insertion_point(field_get:network.CGPartyInviteAnswerPacket.leader_vid)
  return _internal_leader_vid();
}
inline void CGPartyInviteAnswerPacket::_internal_set_leader_vid(uint32_t value) {
  
  _impl_.leader_vid_ = value;
}
inline void CGPartyInviteAnswerPacket::set_leader_vid(uint32_t value) {
  _internal_set_leader_vid(value);
  // @@protoc_insertion_point(field_set:network.CGPartyInviteAnswerPacket.leader_vid)
}

// bool accept = 2;
inline void CGPartyInviteAnswerPacket::clear_accept() {
  _impl_.accept_ = false;
}
inline bool CGPartyInviteAnswerPacket::_internal_accept() const {
  return _impl_.accept_;
}
inline bool CGPartyInviteAnswerPacket::accept() const {
  // @@protoc_insertion_point(field_get:network.CGPartyInviteAnswerPacket.accept)
  return _internal_accept();
}
inline void CGPartyInviteAnswerPacket::_internal_set_accept(bool value) {
  
  _impl_.accept_ = value;
}
inline void CGPartyInviteAnswerPacket::set_accept(bool value) {
  _internal_set_accept(value);
  // @@protoc_insertion_point(field_set:network.CGPartyInviteAnswerPacket.accept)
}

// -------------------------------------------------------------------

// CGPartyRemovePacket

// uint32 pid = 1;
inline void CGPartyRemovePacket::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t CGPartyRemovePacket::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t CGPartyRemovePacket::pid() const {
  // @@protoc_insertion_point(field_get:network.CGPartyRemovePacket.pid)
  return _internal_pid();
}
inline void CGPartyRemovePacket::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void CGPartyRemovePacket::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:network.CGPartyRemovePacket.pid)
}

// -------------------------------------------------------------------

// CGPartySetStatePacket

// uint32 pid = 1;
inline void CGPartySetStatePacket::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t CGPartySetStatePacket::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t CGPartySetStatePacket::pid() const {
  // @@protoc_insertion_point(field_get:network.CGPartySetStatePacket.pid)
  return _internal_pid();
}
inline void CGPartySetStatePacket::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void CGPartySetStatePacket::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:network.CGPartySetStatePacket.pid)
}

// uint32 role = 2;
inline void CGPartySetStatePacket::clear_role() {
  _impl_.role_ = 0u;
}
inline uint32_t CGPartySetStatePacket::_internal_role() const {
  return _impl_.role_;
}
inline uint32_t CGPartySetStatePacket::role() const {
  // @@protoc_insertion_point(field_get:network.CGPartySetStatePacket.role)
  return _internal_role();
}
inline void CGPartySetStatePacket::_internal_set_role(uint32_t value) {
  
  _impl_.role_ = value;
}
inline void CGPartySetStatePacket::set_role(uint32_t value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:network.CGPartySetStatePacket.role)
}

// bool flag = 3;
inline void CGPartySetStatePacket::clear_flag() {
  _impl_.flag_ = false;
}
inline bool CGPartySetStatePacket::_internal_flag() const {
  return _impl_.flag_;
}
inline bool CGPartySetStatePacket::flag() const {
  // @@protoc_insertion_point(field_get:network.CGPartySetStatePacket.flag)
  return _internal_flag();
}
inline void CGPartySetStatePacket::_internal_set_flag(bool value) {
  
  _impl_.flag_ = value;
}
inline void CGPartySetStatePacket::set_flag(bool value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:network.CGPartySetStatePacket.flag)
}

// -------------------------------------------------------------------

// CGPartyUseSkillPacket

// uint32 skill_index = 1;
inline void CGPartyUseSkillPacket::clear_skill_index() {
  _impl_.skill_index_ = 0u;
}
inline uint32_t CGPartyUseSkillPacket::_internal_skill_index() const {
  return _impl_.skill_index_;
}
inline uint32_t CGPartyUseSkillPacket::skill_index() const {
  // @@protoc_insertion_point(field_get:network.CGPartyUseSkillPacket.skill_index)
  return _internal_skill_index();
}
inline void CGPartyUseSkillPacket::_internal_set_skill_index(uint32_t value) {
  
  _impl_.skill_index_ = value;
}
inline void CGPartyUseSkillPacket::set_skill_index(uint32_t value) {
  _internal_set_skill_index(value);
  // @@protoc_insertion_point(field_set:network.CGPartyUseSkillPacket.skill_index)
}

// uint32 vid = 2;
inline void CGPartyUseSkillPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGPartyUseSkillPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGPartyUseSkillPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGPartyUseSkillPacket.vid)
  return _internal_vid();
}
inline void CGPartyUseSkillPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGPartyUseSkillPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGPartyUseSkillPacket.vid)
}

// -------------------------------------------------------------------

// CGPartyParameterPacket

// uint32 distribute_mode = 1;
inline void CGPartyParameterPacket::clear_distribute_mode() {
  _impl_.distribute_mode_ = 0u;
}
inline uint32_t CGPartyParameterPacket::_internal_distribute_mode() const {
  return _impl_.distribute_mode_;
}
inline uint32_t CGPartyParameterPacket::distribute_mode() const {
  // @@protoc_insertion_point(field_get:network.CGPartyParameterPacket.distribute_mode)
  return _internal_distribute_mode();
}
inline void CGPartyParameterPacket::_internal_set_distribute_mode(uint32_t value) {
  
  _impl_.distribute_mode_ = value;
}
inline void CGPartyParameterPacket::set_distribute_mode(uint32_t value) {
  _internal_set_distribute_mode(value);
  // @@protoc_insertion_point(field_set:network.CGPartyParameterPacket.distribute_mode)
}

// -------------------------------------------------------------------

// CGGuildDepositMoneyPacket

// uint32 gold = 1;
inline void CGGuildDepositMoneyPacket::clear_gold() {
  _impl_.gold_ = 0u;
}
inline uint32_t CGGuildDepositMoneyPacket::_internal_gold() const {
  return _impl_.gold_;
}
inline uint32_t CGGuildDepositMoneyPacket::gold() const {
  // @@protoc_insertion_point(field_get:network.CGGuildDepositMoneyPacket.gold)
  return _internal_gold();
}
inline void CGGuildDepositMoneyPacket::_internal_set_gold(uint32_t value) {
  
  _impl_.gold_ = value;
}
inline void CGGuildDepositMoneyPacket::set_gold(uint32_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:network.CGGuildDepositMoneyPacket.gold)
}

// -------------------------------------------------------------------

// CGGuildWithdrawMoneyPacket

// uint32 gold = 1;
inline void CGGuildWithdrawMoneyPacket::clear_gold() {
  _impl_.gold_ = 0u;
}
inline uint32_t CGGuildWithdrawMoneyPacket::_internal_gold() const {
  return _impl_.gold_;
}
inline uint32_t CGGuildWithdrawMoneyPacket::gold() const {
  // @@protoc_insertion_point(field_get:network.CGGuildWithdrawMoneyPacket.gold)
  return _internal_gold();
}
inline void CGGuildWithdrawMoneyPacket::_internal_set_gold(uint32_t value) {
  
  _impl_.gold_ = value;
}
inline void CGGuildWithdrawMoneyPacket::set_gold(uint32_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:network.CGGuildWithdrawMoneyPacket.gold)
}

// -------------------------------------------------------------------

// CGGuildAddMemberPacket

// uint32 vid = 1;
inline void CGGuildAddMemberPacket::clear_vid() {
  _impl_.vid_ = 0u;
}
inline uint32_t CGGuildAddMemberPacket::_internal_vid() const {
  return _impl_.vid_;
}
inline uint32_t CGGuildAddMemberPacket::vid() const {
  // @@protoc_insertion_point(field_get:network.CGGuildAddMemberPacket.vid)
  return _internal_vid();
}
inline void CGGuildAddMemberPacket::_internal_set_vid(uint32_t value) {
  
  _impl_.vid_ = value;
}
inline void CGGuildAddMemberPacket::set_vid(uint32_t value) {
  _internal_set_vid(value);
  // @@protoc_insertion_point(field_set:network.CGGuildAddMemberPacket.vid)
}

// -------------------------------------------------------------------

// CGGuildRemoveMemberPacket

// uint32 pid = 1;
inline void CGGuildRemoveMemberPacket::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t CGGuildRemoveMemberPacket::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t CGGuildRemoveMemberPacket::pid() const {
  // @@protoc_insertion_point(field_get:network.CGGuildRemoveMemberPacket.pid)
  return _internal_pid();
}
inline void CGGuildRemoveMemberPacket::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void CGGuildRemoveMemberPacket::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:network.CGGuildRemoveMemberPacket.pid)
}

// -------------------------------------------------------------------

// CGGuildChangeGradeNamePacket

// uint32 grade = 1;
inline void CGGuildChangeGradeNamePacket::clear_grade() {
  _impl_.grade_ = 0u;
}
inline uint32_t CGGuildChangeGradeNamePacket::_internal_grade() const {
  return _impl_.grade_;
}
inline uint32_t CGGuildChangeGradeNamePacket::grade() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChangeGradeNamePacket.grade)
  return _internal_grade();
}
inline void CGGuildChangeGradeNamePacket::_internal_set_grade(uint32_t value) {
  
  _impl_.grade_ = value;
}
inline void CGGuildChangeGradeNamePacket::set_grade(uint32_t value) {
  _internal_set_grade(value);
  // @@protoc_insertion_point(field_set:network.CGGuildChangeGradeNamePacket.grade)
}

// bytes gradename = 2;
inline void CGGuildChangeGradeNamePacket::clear_gradename() {
  _impl_.gradename_.ClearToEmpty();
}
inline const std::string& CGGuildChangeGradeNamePacket::gradename() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChangeGradeNamePacket.gradename)
  return _internal_gradename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGGuildChangeGradeNamePacket::set_gradename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gradename_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGGuildChangeGradeNamePacket.gradename)
}
inline std::string* CGGuildChangeGradeNamePacket::mutable_gradename() {
  std::string* _s = _internal_mutable_gradename();
  // @@protoc_insertion_point(field_mutable:network.CGGuildChangeGradeNamePacket.gradename)
  return _s;
}
inline const std::string& CGGuildChangeGradeNamePacket::_internal_gradename() const {
  return _impl_.gradename_.Get();
}
inline void CGGuildChangeGradeNamePacket::_internal_set_gradename(const std::string& value) {
  
  _impl_.gradename_.Set(value, GetArenaForAllocation());
}
inline std::string* CGGuildChangeGradeNamePacket::_internal_mutable_gradename() {
  
  return _impl_.gradename_.Mutable(GetArenaForAllocation());
}
inline std::string* CGGuildChangeGradeNamePacket::release_gradename() {
  // @@protoc_insertion_point(field_release:network.CGGuildChangeGradeNamePacket.gradename)
  return _impl_.gradename_.Release();
}
inline void CGGuildChangeGradeNamePacket::set_allocated_gradename(std::string* gradename) {
  if (gradename != nullptr) {
    
  } else {
    
  }
  _impl_.gradename_.SetAllocated(gradename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gradename_.IsDefault()) {
    _impl_.gradename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGGuildChangeGradeNamePacket.gradename)
}

// -------------------------------------------------------------------

// CGGuildChangeGradeAuthorityPacket

// uint32 grade = 1;
inline void CGGuildChangeGradeAuthorityPacket::clear_grade() {
  _impl_.grade_ = 0u;
}
inline uint32_t CGGuildChangeGradeAuthorityPacket::_internal_grade() const {
  return _impl_.grade_;
}
inline uint32_t CGGuildChangeGradeAuthorityPacket::grade() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChangeGradeAuthorityPacket.grade)
  return _internal_grade();
}
inline void CGGuildChangeGradeAuthorityPacket::_internal_set_grade(uint32_t value) {
  
  _impl_.grade_ = value;
}
inline void CGGuildChangeGradeAuthorityPacket::set_grade(uint32_t value) {
  _internal_set_grade(value);
  // @@protoc_insertion_point(field_set:network.CGGuildChangeGradeAuthorityPacket.grade)
}

// uint32 authority = 2;
inline void CGGuildChangeGradeAuthorityPacket::clear_authority() {
  _impl_.authority_ = 0u;
}
inline uint32_t CGGuildChangeGradeAuthorityPacket::_internal_authority() const {
  return _impl_.authority_;
}
inline uint32_t CGGuildChangeGradeAuthorityPacket::authority() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChangeGradeAuthorityPacket.authority)
  return _internal_authority();
}
inline void CGGuildChangeGradeAuthorityPacket::_internal_set_authority(uint32_t value) {
  
  _impl_.authority_ = value;
}
inline void CGGuildChangeGradeAuthorityPacket::set_authority(uint32_t value) {
  _internal_set_authority(value);
  // @@protoc_insertion_point(field_set:network.CGGuildChangeGradeAuthorityPacket.authority)
}

// -------------------------------------------------------------------

// CGGuildOfferExpPacket

// uint32 exp = 1;
inline void CGGuildOfferExpPacket::clear_exp() {
  _impl_.exp_ = 0u;
}
inline uint32_t CGGuildOfferExpPacket::_internal_exp() const {
  return _impl_.exp_;
}
inline uint32_t CGGuildOfferExpPacket::exp() const {
  // @@protoc_insertion_point(field_get:network.CGGuildOfferExpPacket.exp)
  return _internal_exp();
}
inline void CGGuildOfferExpPacket::_internal_set_exp(uint32_t value) {
  
  _impl_.exp_ = value;
}
inline void CGGuildOfferExpPacket::set_exp(uint32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:network.CGGuildOfferExpPacket.exp)
}

// -------------------------------------------------------------------

// CGGuildChargeGSPPacket

// uint32 amount = 1;
inline void CGGuildChargeGSPPacket::clear_amount() {
  _impl_.amount_ = 0u;
}
inline uint32_t CGGuildChargeGSPPacket::_internal_amount() const {
  return _impl_.amount_;
}
inline uint32_t CGGuildChargeGSPPacket::amount() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChargeGSPPacket.amount)
  return _internal_amount();
}
inline void CGGuildChargeGSPPacket::_internal_set_amount(uint32_t value) {
  
  _impl_.amount_ = value;
}
inline void CGGuildChargeGSPPacket::set_amount(uint32_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:network.CGGuildChargeGSPPacket.amount)
}

// -------------------------------------------------------------------

// CGGuildPostCommentPacket

// bytes message = 1;
inline void CGGuildPostCommentPacket::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CGGuildPostCommentPacket::message() const {
  // @@protoc_insertion_point(field_get:network.CGGuildPostCommentPacket.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGGuildPostCommentPacket::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGGuildPostCommentPacket.message)
}
inline std::string* CGGuildPostCommentPacket::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:network.CGGuildPostCommentPacket.message)
  return _s;
}
inline const std::string& CGGuildPostCommentPacket::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CGGuildPostCommentPacket::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CGGuildPostCommentPacket::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CGGuildPostCommentPacket::release_message() {
  // @@protoc_insertion_point(field_release:network.CGGuildPostCommentPacket.message)
  return _impl_.message_.Release();
}
inline void CGGuildPostCommentPacket::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGGuildPostCommentPacket.message)
}

// -------------------------------------------------------------------

// CGGuildDeleteCommentPacket

// uint32 comment_id = 1;
inline void CGGuildDeleteCommentPacket::clear_comment_id() {
  _impl_.comment_id_ = 0u;
}
inline uint32_t CGGuildDeleteCommentPacket::_internal_comment_id() const {
  return _impl_.comment_id_;
}
inline uint32_t CGGuildDeleteCommentPacket::comment_id() const {
  // @@protoc_insertion_point(field_get:network.CGGuildDeleteCommentPacket.comment_id)
  return _internal_comment_id();
}
inline void CGGuildDeleteCommentPacket::_internal_set_comment_id(uint32_t value) {
  
  _impl_.comment_id_ = value;
}
inline void CGGuildDeleteCommentPacket::set_comment_id(uint32_t value) {
  _internal_set_comment_id(value);
  // @@protoc_insertion_point(field_set:network.CGGuildDeleteCommentPacket.comment_id)
}

// -------------------------------------------------------------------

// CGGuildChangeMemberGradePacket

// uint32 pid = 1;
inline void CGGuildChangeMemberGradePacket::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t CGGuildChangeMemberGradePacket::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t CGGuildChangeMemberGradePacket::pid() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChangeMemberGradePacket.pid)
  return _internal_pid();
}
inline void CGGuildChangeMemberGradePacket::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void CGGuildChangeMemberGradePacket::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:network.CGGuildChangeMemberGradePacket.pid)
}

// uint32 grade = 2;
inline void CGGuildChangeMemberGradePacket::clear_grade() {
  _impl_.grade_ = 0u;
}
inline uint32_t CGGuildChangeMemberGradePacket::_internal_grade() const {
  return _impl_.grade_;
}
inline uint32_t CGGuildChangeMemberGradePacket::grade() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChangeMemberGradePacket.grade)
  return _internal_grade();
}
inline void CGGuildChangeMemberGradePacket::_internal_set_grade(uint32_t value) {
  
  _impl_.grade_ = value;
}
inline void CGGuildChangeMemberGradePacket::set_grade(uint32_t value) {
  _internal_set_grade(value);
  // @@protoc_insertion_point(field_set:network.CGGuildChangeMemberGradePacket.grade)
}

// -------------------------------------------------------------------

// CGGuildUseSkillPacket

// uint32 vnum = 1;
inline void CGGuildUseSkillPacket::clear_vnum() {
  _impl_.vnum_ = 0u;
}
inline uint32_t CGGuildUseSkillPacket::_internal_vnum() const {
  return _impl_.vnum_;
}
inline uint32_t CGGuildUseSkillPacket::vnum() const {
  // @@protoc_insertion_point(field_get:network.CGGuildUseSkillPacket.vnum)
  return _internal_vnum();
}
inline void CGGuildUseSkillPacket::_internal_set_vnum(uint32_t value) {
  
  _impl_.vnum_ = value;
}
inline void CGGuildUseSkillPacket::set_vnum(uint32_t value) {
  _internal_set_vnum(value);
  // @@protoc_insertion_point(field_set:network.CGGuildUseSkillPacket.vnum)
}

// uint32 pid = 2;
inline void CGGuildUseSkillPacket::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t CGGuildUseSkillPacket::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t CGGuildUseSkillPacket::pid() const {
  // @@protoc_insertion_point(field_get:network.CGGuildUseSkillPacket.pid)
  return _internal_pid();
}
inline void CGGuildUseSkillPacket::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void CGGuildUseSkillPacket::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:network.CGGuildUseSkillPacket.pid)
}

// -------------------------------------------------------------------

// CGGuildChangeMemberGeneralPacket

// uint32 pid = 1;
inline void CGGuildChangeMemberGeneralPacket::clear_pid() {
  _impl_.pid_ = 0u;
}
inline uint32_t CGGuildChangeMemberGeneralPacket::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t CGGuildChangeMemberGeneralPacket::pid() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChangeMemberGeneralPacket.pid)
  return _internal_pid();
}
inline void CGGuildChangeMemberGeneralPacket::_internal_set_pid(uint32_t value) {
  
  _impl_.pid_ = value;
}
inline void CGGuildChangeMemberGeneralPacket::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:network.CGGuildChangeMemberGeneralPacket.pid)
}

// bool is_general = 2;
inline void CGGuildChangeMemberGeneralPacket::clear_is_general() {
  _impl_.is_general_ = false;
}
inline bool CGGuildChangeMemberGeneralPacket::_internal_is_general() const {
  return _impl_.is_general_;
}
inline bool CGGuildChangeMemberGeneralPacket::is_general() const {
  // @@protoc_insertion_point(field_get:network.CGGuildChangeMemberGeneralPacket.is_general)
  return _internal_is_general();
}
inline void CGGuildChangeMemberGeneralPacket::_internal_set_is_general(bool value) {
  
  _impl_.is_general_ = value;
}
inline void CGGuildChangeMemberGeneralPacket::set_is_general(bool value) {
  _internal_set_is_general(value);
  // @@protoc_insertion_point(field_set:network.CGGuildChangeMemberGeneralPacket.is_general)
}

// -------------------------------------------------------------------

// CGGuildInviteAnswerPacket

// uint32 guild_id = 1;
inline void CGGuildInviteAnswerPacket::clear_guild_id() {
  _impl_.guild_id_ = 0u;
}
inline uint32_t CGGuildInviteAnswerPacket::_internal_guild_id() const {
  return _impl_.guild_id_;
}
inline uint32_t CGGuildInviteAnswerPacket::guild_id() const {
  // @@protoc_insertion_point(field_get:network.CGGuildInviteAnswerPacket.guild_id)
  return _internal_guild_id();
}
inline void CGGuildInviteAnswerPacket::_internal_set_guild_id(uint32_t value) {
  
  _impl_.guild_id_ = value;
}
inline void CGGuildInviteAnswerPacket::set_guild_id(uint32_t value) {
  _internal_set_guild_id(value);
  // @@protoc_insertion_point(field_set:network.CGGuildInviteAnswerPacket.guild_id)
}

// bool accept = 2;
inline void CGGuildInviteAnswerPacket::clear_accept() {
  _impl_.accept_ = false;
}
inline bool CGGuildInviteAnswerPacket::_internal_accept() const {
  return _impl_.accept_;
}
inline bool CGGuildInviteAnswerPacket::accept() const {
  // @@protoc_insertion_point(field_get:network.CGGuildInviteAnswerPacket.accept)
  return _internal_accept();
}
inline void CGGuildInviteAnswerPacket::_internal_set_accept(bool value) {
  
  _impl_.accept_ = value;
}
inline void CGGuildInviteAnswerPacket::set_accept(bool value) {
  _internal_set_accept(value);
  // @@protoc_insertion_point(field_set:network.CGGuildInviteAnswerPacket.accept)
}

// -------------------------------------------------------------------

// CGGuildAnswerMakePacket

// bytes guild_name = 1;
inline void CGGuildAnswerMakePacket::clear_guild_name() {
  _impl_.guild_name_.ClearToEmpty();
}
inline const std::string& CGGuildAnswerMakePacket::guild_name() const {
  // @@protoc_insertion_point(field_get:network.CGGuildAnswerMakePacket.guild_name)
  return _internal_guild_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGGuildAnswerMakePacket::set_guild_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.guild_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGGuildAnswerMakePacket.guild_name)
}
inline std::string* CGGuildAnswerMakePacket::mutable_guild_name() {
  std::string* _s = _internal_mutable_guild_name();
  // @@protoc_insertion_point(field_mutable:network.CGGuildAnswerMakePacket.guild_name)
  return _s;
}
inline const std::string& CGGuildAnswerMakePacket::_internal_guild_name() const {
  return _impl_.guild_name_.Get();
}
inline void CGGuildAnswerMakePacket::_internal_set_guild_name(const std::string& value) {
  
  _impl_.guild_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGGuildAnswerMakePacket::_internal_mutable_guild_name() {
  
  return _impl_.guild_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGGuildAnswerMakePacket::release_guild_name() {
  // @@protoc_insertion_point(field_release:network.CGGuildAnswerMakePacket.guild_name)
  return _impl_.guild_name_.Release();
}
inline void CGGuildAnswerMakePacket::set_allocated_guild_name(std::string* guild_name) {
  if (guild_name != nullptr) {
    
  } else {
    
  }
  _impl_.guild_name_.SetAllocated(guild_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.guild_name_.IsDefault()) {
    _impl_.guild_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGGuildAnswerMakePacket.guild_name)
}

// -------------------------------------------------------------------

// CGGuildRequestListPacket

// uint32 page_number = 1;
inline void CGGuildRequestListPacket::clear_page_number() {
  _impl_.page_number_ = 0u;
}
inline uint32_t CGGuildRequestListPacket::_internal_page_number() const {
  return _impl_.page_number_;
}
inline uint32_t CGGuildRequestListPacket::page_number() const {
  // @@protoc_insertion_point(field_get:network.CGGuildRequestListPacket.page_number)
  return _internal_page_number();
}
inline void CGGuildRequestListPacket::_internal_set_page_number(uint32_t value) {
  
  _impl_.page_number_ = value;
}
inline void CGGuildRequestListPacket::set_page_number(uint32_t value) {
  _internal_set_page_number(value);
  // @@protoc_insertion_point(field_set:network.CGGuildRequestListPacket.page_number)
}

// uint32 page_type = 2;
inline void CGGuildRequestListPacket::clear_page_type() {
  _impl_.page_type_ = 0u;
}
inline uint32_t CGGuildRequestListPacket::_internal_page_type() const {
  return _impl_.page_type_;
}
inline uint32_t CGGuildRequestListPacket::page_type() const {
  // @@protoc_insertion_point(field_get:network.CGGuildRequestListPacket.page_type)
  return _internal_page_type();
}
inline void CGGuildRequestListPacket::_internal_set_page_type(uint32_t value) {
  
  _impl_.page_type_ = value;
}
inline void CGGuildRequestListPacket::set_page_type(uint32_t value) {
  _internal_set_page_type(value);
  // @@protoc_insertion_point(field_set:network.CGGuildRequestListPacket.page_type)
}

// uint32 empire = 3;
inline void CGGuildRequestListPacket::clear_empire() {
  _impl_.empire_ = 0u;
}
inline uint32_t CGGuildRequestListPacket::_internal_empire() const {
  return _impl_.empire_;
}
inline uint32_t CGGuildRequestListPacket::empire() const {
  // @@protoc_insertion_point(field_get:network.CGGuildRequestListPacket.empire)
  return _internal_empire();
}
inline void CGGuildRequestListPacket::_internal_set_empire(uint32_t value) {
  
  _impl_.empire_ = value;
}
inline void CGGuildRequestListPacket::set_empire(uint32_t value) {
  _internal_set_empire(value);
  // @@protoc_insertion_point(field_set:network.CGGuildRequestListPacket.empire)
}

// -------------------------------------------------------------------

// CGGuildSearchPacket

// bytes search_name = 1;
inline void CGGuildSearchPacket::clear_search_name() {
  _impl_.search_name_.ClearToEmpty();
}
inline const std::string& CGGuildSearchPacket::search_name() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSearchPacket.search_name)
  return _internal_search_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGGuildSearchPacket::set_search_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.search_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGGuildSearchPacket.search_name)
}
inline std::string* CGGuildSearchPacket::mutable_search_name() {
  std::string* _s = _internal_mutable_search_name();
  // @@protoc_insertion_point(field_mutable:network.CGGuildSearchPacket.search_name)
  return _s;
}
inline const std::string& CGGuildSearchPacket::_internal_search_name() const {
  return _impl_.search_name_.Get();
}
inline void CGGuildSearchPacket::_internal_set_search_name(const std::string& value) {
  
  _impl_.search_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGGuildSearchPacket::_internal_mutable_search_name() {
  
  return _impl_.search_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGGuildSearchPacket::release_search_name() {
  // @@protoc_insertion_point(field_release:network.CGGuildSearchPacket.search_name)
  return _impl_.search_name_.Release();
}
inline void CGGuildSearchPacket::set_allocated_search_name(std::string* search_name) {
  if (search_name != nullptr) {
    
  } else {
    
  }
  _impl_.search_name_.SetAllocated(search_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.search_name_.IsDefault()) {
    _impl_.search_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGGuildSearchPacket.search_name)
}

// uint32 page_type = 2;
inline void CGGuildSearchPacket::clear_page_type() {
  _impl_.page_type_ = 0u;
}
inline uint32_t CGGuildSearchPacket::_internal_page_type() const {
  return _impl_.page_type_;
}
inline uint32_t CGGuildSearchPacket::page_type() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSearchPacket.page_type)
  return _internal_page_type();
}
inline void CGGuildSearchPacket::_internal_set_page_type(uint32_t value) {
  
  _impl_.page_type_ = value;
}
inline void CGGuildSearchPacket::set_page_type(uint32_t value) {
  _internal_set_page_type(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSearchPacket.page_type)
}

// uint32 empire = 3;
inline void CGGuildSearchPacket::clear_empire() {
  _impl_.empire_ = 0u;
}
inline uint32_t CGGuildSearchPacket::_internal_empire() const {
  return _impl_.empire_;
}
inline uint32_t CGGuildSearchPacket::empire() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSearchPacket.empire)
  return _internal_empire();
}
inline void CGGuildSearchPacket::_internal_set_empire(uint32_t value) {
  
  _impl_.empire_ = value;
}
inline void CGGuildSearchPacket::set_empire(uint32_t value) {
  _internal_set_empire(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSearchPacket.empire)
}

// -------------------------------------------------------------------

// CGGuildSafeboxCheckinPacket

// .network.TItemPos item_pos = 1;
inline bool CGGuildSafeboxCheckinPacket::_internal_has_item_pos() const {
  return this != internal_default_instance() && _impl_.item_pos_ != nullptr;
}
inline bool CGGuildSafeboxCheckinPacket::has_item_pos() const {
  return _internal_has_item_pos();
}
inline const ::network::TItemPos& CGGuildSafeboxCheckinPacket::_internal_item_pos() const {
  const ::network::TItemPos* p = _impl_.item_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGGuildSafeboxCheckinPacket::item_pos() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxCheckinPacket.item_pos)
  return _internal_item_pos();
}
inline void CGGuildSafeboxCheckinPacket::unsafe_arena_set_allocated_item_pos(
    ::network::TItemPos* item_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_pos_);
  }
  _impl_.item_pos_ = item_pos;
  if (item_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGGuildSafeboxCheckinPacket.item_pos)
}
inline ::network::TItemPos* CGGuildSafeboxCheckinPacket::release_item_pos() {
  
  ::network::TItemPos* temp = _impl_.item_pos_;
  _impl_.item_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGGuildSafeboxCheckinPacket::unsafe_arena_release_item_pos() {
  // @@protoc_insertion_point(field_release:network.CGGuildSafeboxCheckinPacket.item_pos)
  
  ::network::TItemPos* temp = _impl_.item_pos_;
  _impl_.item_pos_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGGuildSafeboxCheckinPacket::_internal_mutable_item_pos() {
  
  if (_impl_.item_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.item_pos_ = p;
  }
  return _impl_.item_pos_;
}
inline ::network::TItemPos* CGGuildSafeboxCheckinPacket::mutable_item_pos() {
  ::network::TItemPos* _msg = _internal_mutable_item_pos();
  // @@protoc_insertion_point(field_mutable:network.CGGuildSafeboxCheckinPacket.item_pos)
  return _msg;
}
inline void CGGuildSafeboxCheckinPacket::set_allocated_item_pos(::network::TItemPos* item_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_pos_);
  }
  if (item_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_pos));
    if (message_arena != submessage_arena) {
      item_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_pos_ = item_pos;
  // @@protoc_insertion_point(field_set_allocated:network.CGGuildSafeboxCheckinPacket.item_pos)
}

// uint32 safebox_pos = 2;
inline void CGGuildSafeboxCheckinPacket::clear_safebox_pos() {
  _impl_.safebox_pos_ = 0u;
}
inline uint32_t CGGuildSafeboxCheckinPacket::_internal_safebox_pos() const {
  return _impl_.safebox_pos_;
}
inline uint32_t CGGuildSafeboxCheckinPacket::safebox_pos() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxCheckinPacket.safebox_pos)
  return _internal_safebox_pos();
}
inline void CGGuildSafeboxCheckinPacket::_internal_set_safebox_pos(uint32_t value) {
  
  _impl_.safebox_pos_ = value;
}
inline void CGGuildSafeboxCheckinPacket::set_safebox_pos(uint32_t value) {
  _internal_set_safebox_pos(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSafeboxCheckinPacket.safebox_pos)
}

// -------------------------------------------------------------------

// CGGuildSafeboxCheckoutPacket

// uint32 safebox_pos = 1;
inline void CGGuildSafeboxCheckoutPacket::clear_safebox_pos() {
  _impl_.safebox_pos_ = 0u;
}
inline uint32_t CGGuildSafeboxCheckoutPacket::_internal_safebox_pos() const {
  return _impl_.safebox_pos_;
}
inline uint32_t CGGuildSafeboxCheckoutPacket::safebox_pos() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxCheckoutPacket.safebox_pos)
  return _internal_safebox_pos();
}
inline void CGGuildSafeboxCheckoutPacket::_internal_set_safebox_pos(uint32_t value) {
  
  _impl_.safebox_pos_ = value;
}
inline void CGGuildSafeboxCheckoutPacket::set_safebox_pos(uint32_t value) {
  _internal_set_safebox_pos(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSafeboxCheckoutPacket.safebox_pos)
}

// .network.TItemPos item_pos = 2;
inline bool CGGuildSafeboxCheckoutPacket::_internal_has_item_pos() const {
  return this != internal_default_instance() && _impl_.item_pos_ != nullptr;
}
inline bool CGGuildSafeboxCheckoutPacket::has_item_pos() const {
  return _internal_has_item_pos();
}
inline const ::network::TItemPos& CGGuildSafeboxCheckoutPacket::_internal_item_pos() const {
  const ::network::TItemPos* p = _impl_.item_pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGGuildSafeboxCheckoutPacket::item_pos() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxCheckoutPacket.item_pos)
  return _internal_item_pos();
}
inline void CGGuildSafeboxCheckoutPacket::unsafe_arena_set_allocated_item_pos(
    ::network::TItemPos* item_pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_pos_);
  }
  _impl_.item_pos_ = item_pos;
  if (item_pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGGuildSafeboxCheckoutPacket.item_pos)
}
inline ::network::TItemPos* CGGuildSafeboxCheckoutPacket::release_item_pos() {
  
  ::network::TItemPos* temp = _impl_.item_pos_;
  _impl_.item_pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGGuildSafeboxCheckoutPacket::unsafe_arena_release_item_pos() {
  // @@protoc_insertion_point(field_release:network.CGGuildSafeboxCheckoutPacket.item_pos)
  
  ::network::TItemPos* temp = _impl_.item_pos_;
  _impl_.item_pos_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGGuildSafeboxCheckoutPacket::_internal_mutable_item_pos() {
  
  if (_impl_.item_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.item_pos_ = p;
  }
  return _impl_.item_pos_;
}
inline ::network::TItemPos* CGGuildSafeboxCheckoutPacket::mutable_item_pos() {
  ::network::TItemPos* _msg = _internal_mutable_item_pos();
  // @@protoc_insertion_point(field_mutable:network.CGGuildSafeboxCheckoutPacket.item_pos)
  return _msg;
}
inline void CGGuildSafeboxCheckoutPacket::set_allocated_item_pos(::network::TItemPos* item_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_pos_);
  }
  if (item_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_pos));
    if (message_arena != submessage_arena) {
      item_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_pos_ = item_pos;
  // @@protoc_insertion_point(field_set_allocated:network.CGGuildSafeboxCheckoutPacket.item_pos)
}

// -------------------------------------------------------------------

// CGGuildSafeboxItemMovePacket

// uint32 source_pos = 1;
inline void CGGuildSafeboxItemMovePacket::clear_source_pos() {
  _impl_.source_pos_ = 0u;
}
inline uint32_t CGGuildSafeboxItemMovePacket::_internal_source_pos() const {
  return _impl_.source_pos_;
}
inline uint32_t CGGuildSafeboxItemMovePacket::source_pos() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxItemMovePacket.source_pos)
  return _internal_source_pos();
}
inline void CGGuildSafeboxItemMovePacket::_internal_set_source_pos(uint32_t value) {
  
  _impl_.source_pos_ = value;
}
inline void CGGuildSafeboxItemMovePacket::set_source_pos(uint32_t value) {
  _internal_set_source_pos(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSafeboxItemMovePacket.source_pos)
}

// uint32 target_pos = 2;
inline void CGGuildSafeboxItemMovePacket::clear_target_pos() {
  _impl_.target_pos_ = 0u;
}
inline uint32_t CGGuildSafeboxItemMovePacket::_internal_target_pos() const {
  return _impl_.target_pos_;
}
inline uint32_t CGGuildSafeboxItemMovePacket::target_pos() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxItemMovePacket.target_pos)
  return _internal_target_pos();
}
inline void CGGuildSafeboxItemMovePacket::_internal_set_target_pos(uint32_t value) {
  
  _impl_.target_pos_ = value;
}
inline void CGGuildSafeboxItemMovePacket::set_target_pos(uint32_t value) {
  _internal_set_target_pos(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSafeboxItemMovePacket.target_pos)
}

// uint32 count = 3;
inline void CGGuildSafeboxItemMovePacket::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t CGGuildSafeboxItemMovePacket::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CGGuildSafeboxItemMovePacket::count() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxItemMovePacket.count)
  return _internal_count();
}
inline void CGGuildSafeboxItemMovePacket::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void CGGuildSafeboxItemMovePacket::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSafeboxItemMovePacket.count)
}

// -------------------------------------------------------------------

// CGGuildSafeboxGiveGoldPacket

// uint64 gold = 1;
inline void CGGuildSafeboxGiveGoldPacket::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t CGGuildSafeboxGiveGoldPacket::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t CGGuildSafeboxGiveGoldPacket::gold() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxGiveGoldPacket.gold)
  return _internal_gold();
}
inline void CGGuildSafeboxGiveGoldPacket::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void CGGuildSafeboxGiveGoldPacket::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSafeboxGiveGoldPacket.gold)
}

// -------------------------------------------------------------------

// CGGuildSafeboxGetGoldPacket

// uint64 gold = 1;
inline void CGGuildSafeboxGetGoldPacket::clear_gold() {
  _impl_.gold_ = uint64_t{0u};
}
inline uint64_t CGGuildSafeboxGetGoldPacket::_internal_gold() const {
  return _impl_.gold_;
}
inline uint64_t CGGuildSafeboxGetGoldPacket::gold() const {
  // @@protoc_insertion_point(field_get:network.CGGuildSafeboxGetGoldPacket.gold)
  return _internal_gold();
}
inline void CGGuildSafeboxGetGoldPacket::_internal_set_gold(uint64_t value) {
  
  _impl_.gold_ = value;
}
inline void CGGuildSafeboxGetGoldPacket::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:network.CGGuildSafeboxGetGoldPacket.gold)
}

// -------------------------------------------------------------------

// CGPetUseEggPacket

// .network.TItemPos egg_cell = 1;
inline bool CGPetUseEggPacket::_internal_has_egg_cell() const {
  return this != internal_default_instance() && _impl_.egg_cell_ != nullptr;
}
inline bool CGPetUseEggPacket::has_egg_cell() const {
  return _internal_has_egg_cell();
}
inline const ::network::TItemPos& CGPetUseEggPacket::_internal_egg_cell() const {
  const ::network::TItemPos* p = _impl_.egg_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGPetUseEggPacket::egg_cell() const {
  // @@protoc_insertion_point(field_get:network.CGPetUseEggPacket.egg_cell)
  return _internal_egg_cell();
}
inline void CGPetUseEggPacket::unsafe_arena_set_allocated_egg_cell(
    ::network::TItemPos* egg_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.egg_cell_);
  }
  _impl_.egg_cell_ = egg_cell;
  if (egg_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGPetUseEggPacket.egg_cell)
}
inline ::network::TItemPos* CGPetUseEggPacket::release_egg_cell() {
  
  ::network::TItemPos* temp = _impl_.egg_cell_;
  _impl_.egg_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGPetUseEggPacket::unsafe_arena_release_egg_cell() {
  // @@protoc_insertion_point(field_release:network.CGPetUseEggPacket.egg_cell)
  
  ::network::TItemPos* temp = _impl_.egg_cell_;
  _impl_.egg_cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGPetUseEggPacket::_internal_mutable_egg_cell() {
  
  if (_impl_.egg_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.egg_cell_ = p;
  }
  return _impl_.egg_cell_;
}
inline ::network::TItemPos* CGPetUseEggPacket::mutable_egg_cell() {
  ::network::TItemPos* _msg = _internal_mutable_egg_cell();
  // @@protoc_insertion_point(field_mutable:network.CGPetUseEggPacket.egg_cell)
  return _msg;
}
inline void CGPetUseEggPacket::set_allocated_egg_cell(::network::TItemPos* egg_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.egg_cell_);
  }
  if (egg_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(egg_cell));
    if (message_arena != submessage_arena) {
      egg_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, egg_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.egg_cell_ = egg_cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGPetUseEggPacket.egg_cell)
}

// string pet_name = 2;
inline void CGPetUseEggPacket::clear_pet_name() {
  _impl_.pet_name_.ClearToEmpty();
}
inline const std::string& CGPetUseEggPacket::pet_name() const {
  // @@protoc_insertion_point(field_get:network.CGPetUseEggPacket.pet_name)
  return _internal_pet_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGPetUseEggPacket::set_pet_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pet_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:network.CGPetUseEggPacket.pet_name)
}
inline std::string* CGPetUseEggPacket::mutable_pet_name() {
  std::string* _s = _internal_mutable_pet_name();
  // @@protoc_insertion_point(field_mutable:network.CGPetUseEggPacket.pet_name)
  return _s;
}
inline const std::string& CGPetUseEggPacket::_internal_pet_name() const {
  return _impl_.pet_name_.Get();
}
inline void CGPetUseEggPacket::_internal_set_pet_name(const std::string& value) {
  
  _impl_.pet_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CGPetUseEggPacket::_internal_mutable_pet_name() {
  
  return _impl_.pet_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CGPetUseEggPacket::release_pet_name() {
  // @@protoc_insertion_point(field_release:network.CGPetUseEggPacket.pet_name)
  return _impl_.pet_name_.Release();
}
inline void CGPetUseEggPacket::set_allocated_pet_name(std::string* pet_name) {
  if (pet_name != nullptr) {
    
  } else {
    
  }
  _impl_.pet_name_.SetAllocated(pet_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pet_name_.IsDefault()) {
    _impl_.pet_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:network.CGPetUseEggPacket.pet_name)
}

// -------------------------------------------------------------------

// CGPetResetSkillPacket

// .network.TItemPos reset_cell = 1;
inline bool CGPetResetSkillPacket::_internal_has_reset_cell() const {
  return this != internal_default_instance() && _impl_.reset_cell_ != nullptr;
}
inline bool CGPetResetSkillPacket::has_reset_cell() const {
  return _internal_has_reset_cell();
}
inline const ::network::TItemPos& CGPetResetSkillPacket::_internal_reset_cell() const {
  const ::network::TItemPos* p = _impl_.reset_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::network::TItemPos&>(
      ::network::_TItemPos_default_instance_);
}
inline const ::network::TItemPos& CGPetResetSkillPacket::reset_cell() const {
  // @@protoc_insertion_point(field_get:network.CGPetResetSkillPacket.reset_cell)
  return _internal_reset_cell();
}
inline void CGPetResetSkillPacket::unsafe_arena_set_allocated_reset_cell(
    ::network::TItemPos* reset_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_cell_);
  }
  _impl_.reset_cell_ = reset_cell;
  if (reset_cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:network.CGPetResetSkillPacket.reset_cell)
}
inline ::network::TItemPos* CGPetResetSkillPacket::release_reset_cell() {
  
  ::network::TItemPos* temp = _impl_.reset_cell_;
  _impl_.reset_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::network::TItemPos* CGPetResetSkillPacket::unsafe_arena_release_reset_cell() {
  // @@protoc_insertion_point(field_release:network.CGPetResetSkillPacket.reset_cell)
  
  ::network::TItemPos* temp = _impl_.reset_cell_;
  _impl_.reset_cell_ = nullptr;
  return temp;
}
inline ::network::TItemPos* CGPetResetSkillPacket::_internal_mutable_reset_cell() {
  
  if (_impl_.reset_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::network::TItemPos>(GetArenaForAllocation());
    _impl_.reset_cell_ = p;
  }
  return _impl_.reset_cell_;
}
inline ::network::TItemPos* CGPetResetSkillPacket::mutable_reset_cell() {
  ::network::TItemPos* _msg = _internal_mutable_reset_cell();
  // @@protoc_insertion_point(field_mutable:network.CGPetResetSkillPacket.reset_cell)
  return _msg;
}
inline void CGPetResetSkillPacket::set_allocated_reset_cell(::network::TItemPos* reset_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reset_cell_);
  }
  if (reset_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reset_cell));
    if (message_arena != submessage_arena) {
      reset_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset_cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reset_cell_ = reset_cell;
  // @@protoc_insertion_point(field_set_allocated:network.CGPetResetSkillPacket.reset_cell)
}

// uint32 skill_index = 2;
inline void CGPetResetSkillPacket::clear_skill_index() {
  _impl_.skill_index_ = 0u;
}
inline uint32_t CGPetResetSkillPacket::_internal_skill_index() const {
  return _impl_.skill_index_;
}
inline uint32_t CGPetResetSkillPacket::skill_index() const {
  // @@protoc_insertion_point(field_get:network.CGPetResetSkillPacket.skill_index)
  return _internal_skill_index();
}
inline void CGPetResetSkillPacket::_internal_set_skill_index(uint32_t value) {
  
  _impl_.skill_index_ = value;
}
inline void CGPetResetSkillPacket::set_skill_index(uint32_t value) {
  _internal_set_skill_index(value);
  // @@protoc_insertion_point(field_set:network.CGPetResetSkillPacket.skill_index)
}

// -------------------------------------------------------------------

// CGPetAttrRefineInfoPacket

// uint32 index = 1;
inline void CGPetAttrRefineInfoPacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGPetAttrRefineInfoPacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGPetAttrRefineInfoPacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGPetAttrRefineInfoPacket.index)
  return _internal_index();
}
inline void CGPetAttrRefineInfoPacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGPetAttrRefineInfoPacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGPetAttrRefineInfoPacket.index)
}

// -------------------------------------------------------------------

// CGPetAttrRefinePacket

// uint32 index = 1;
inline void CGPetAttrRefinePacket::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t CGPetAttrRefinePacket::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t CGPetAttrRefinePacket::index() const {
  // @@protoc_insertion_point(field_get:network.CGPetAttrRefinePacket.index)
  return _internal_index();
}
inline void CGPetAttrRefinePacket::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void CGPetAttrRefinePacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:network.CGPetAttrRefinePacket.index)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace network

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cg_5fpackets_2eproto
